================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\ui\theme\Color.kt
================================================================================
package com.hereliesaz.cuedetat.ui.theme

import androidx.compose.ui.graphics.Color

// New Theme Colors based on the 8-ball aesthetic
val AppYellow = Color(0xFFFCC506)
val AppBlack = Color(0xFF000000)
val AppWhite = Color(0xFFFFFFFF)
val AppDarkGray = Color(0xFF333333) // For containers or darker accents
val AppMediumGray = Color(0xFF725F5F) // User's provided gray, good for tertiary
val AppLightGrayTextOnDark = Color(0xFFCCCCCC) // For text on dark containers
val AppDarkYellow = Color(0xFFE5B205) // A darker variant of the main yellow
val AppPurple = Color(0xFF6200EE) // A standard purple for the extended shot line

val AppErrorRed = Color(0xFFFF5252)
// AppHelpTextDefault was moved to AppConfig.kt for consistent text styling.
// The line `val AppHelpTextDefault = Color(0xFFD1C4E9)` must be REMOVED from here.

// Specific Helper Text Colors (can reuse AppColors or define new ones)
val AppHelpTextPhoneOverCue = AppDarkYellow
val AppHelpTextTangentLine = Color(0xFFBB86FC)
val AppHelpTextPocketAim = Color(0xFF018786)

val AppHelpTextTargetBallLabel = AppPurple
// val AppHelpTextCueBallLabel = AppMediumGray // Old color for "Cue Ball"
val AppHelpTextGhostBallLabel = AppLightGrayTextOnDark // New color for "Ghost Ball" label

val AppHelpTextProjectedShotLineActual = AppDarkYellow


val AppHelpTextYellow = AppYellow
val AppHelpTextWhite = AppWhite
val AppHelpTextPurple = AppPurple


val AppWarningText = AppErrorRed


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\ui\theme\Theme.kt
================================================================================
// FILE: app\src\main\java\com\hereliesaz\cuedetat\ui\theme\Theme.kt
package com.hereliesaz.cuedetat.ui.theme

import android.app.Activity
import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext

// DarkColorScheme is not actively used due to MyApplication forcing light mode,
// but defined for completeness or future changes.
private val DarkColorScheme = darkColorScheme(
    primary = AppYellow,
    onPrimary = AppBlack,
    primaryContainer = AppDarkGray,
    onPrimaryContainer = AppYellow,
    secondary = AppWhite, // A bright secondary for dark theme
    onSecondary = AppBlack,
    secondaryContainer = Color(0xFF4A4A4A), // Darker gray for containers
    onSecondaryContainer = AppYellow,
    tertiary = AppMediumGray,
    onTertiary = AppWhite,
    background = AppBlack,
    onBackground = AppYellow,
    surface = AppBlack,
    onSurface = AppYellow,
    surfaceVariant = Color(0xFF2A2A2A), // Even darker variant for surfaces
    onSurfaceVariant = AppLightGrayTextOnDark,
    outline = AppMediumGray,
    error = AppErrorRed,
    onError = AppBlack
)

private val LightColorScheme = lightColorScheme(
    primary = AppBlack,                 // Main interactive element, text on yellow
    onPrimary = AppYellow,              // Text/icons on black primary element
    primaryContainer = AppDarkGray,     // Containers for primary actions (e.g., Reset FAB)
    onPrimaryContainer = AppYellow,     // Icons/text on primaryContainer

    secondary = AppBlack,               // Accent element, could also be a less dominant color
    onSecondary = AppYellow,            // Text/icons on secondary element
    secondaryContainer = AppDarkGray,   // Containers for secondary actions (e.g., Help, Zoom FABs)
    onSecondaryContainer = AppYellow,   // Icons/text on secondaryContainer

    tertiary = AppMediumGray,           // Less emphasized element
    onTertiary = AppWhite,              // Text/icons on tertiary (gray)
    tertiaryContainer = Color(0xFFE0E0E0), // Light gray container for tertiary if needed
    onTertiaryContainer = AppBlack,

    background = AppYellow,             // Main app background
    onBackground = AppBlack,            // Text on yellow background

    surface = AppYellow,                // Surfaces like cards, dialogs (can be slightly different)
    onSurface = AppBlack,               // Text on yellow surfaces
    surfaceVariant = AppDarkYellow,     // For element like inactive slider track on yellow background
    onSurfaceVariant = AppBlack,        // Text on surfaceVariant

    outline = AppBlack,                 // Outlines for components

    error = AppErrorRed,                // Error color
    onError = AppBlack,                 // Text/icons on error color
    errorContainer = Color(0xFFFFCDD2), // Light red for error container background
    onErrorContainer = AppBlack         // Text on error container
)


@Composable
fun PoolProtractorTheme(
    darkTheme: Boolean = isSystemInDarkTheme(), // Still here, but MyApplication overrides
    dynamicColor: Boolean = false, // Disable dynamic color to enforce our theme
    content: @Composable () -> Unit
) {
    // MyApplication forces Light Theme (AppCompatDelegate.MODE_NIGHT_NO)
    // So, we will primarily use LightColorScheme.
    // The darkTheme parameter from isSystemInDarkTheme() will be false.
    val effectiveDarkTheme = false // Hardcode or ensure this reflects MyApplication's choice

    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            // This path should ideally not be taken if dynamicColor is false or due to MyApplication
            if (effectiveDarkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }
        effectiveDarkTheme -> DarkColorScheme // Fallback if dynamic is off or unsupported
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\ui\theme\Type.kt
================================================================================
// app/src/main/java/com/hereliesaz/cuedetat/ui/theme/Type.kt
package com.hereliesaz.cuedetat.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
    /* Other default text styles to override
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
    */
)


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\system\CameraManager.kt
================================================================================
package com.hereliesaz.cuedetat.system

import android.Manifest
import android.content.pm.PackageManager
import android.util.Log
import android.util.Size
import android.widget.Toast
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.camera.core.Camera
import androidx.camera.core.CameraInfo
import androidx.camera.core.CameraSelector
import androidx.camera.core.ImageAnalysis
import androidx.camera.core.ImageProxy
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.content.ContextCompat
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.lifecycleScope
import com.google.common.util.concurrent.ListenableFuture
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.tracking.ball_detector.BallDetector
import com.hereliesaz.cuedetat.view.MainOverlayView
import kotlinx.coroutines.guava.await
import kotlinx.coroutines.launch
import java.util.concurrent.Executors



class CameraManager(
    private val activity: AppCompatActivity,
    private val lifecycleOwner: LifecycleOwner,
    private val previewView: PreviewView,
    private val mainOverlayView: MainOverlayView // MainOverlayView instance to pass detected balls
) {
    private companion object {
        private val TAG = AppConfig.TAG + "_CameraManager"
        private const val IMAGE_ANALYSIS_WIDTH = 640 // Resolution for image analysis
        private const val IMAGE_ANALYSIS_HEIGHT = 480 // Resolution for image analysis
    }

    private lateinit var cameraProviderFuture: ListenableFuture<ProcessCameraProvider>
    private var requestCameraPermissionLauncher: ActivityResultLauncher<String>

    private val analysisExecutor = Executors.newSingleThreadExecutor() // Single thread for image analysis to avoid frame drops
    private lateinit var ballDetector: BallDetector

    private var activeCamera: Camera? = null // Store the active camera instance

    init {
        requestCameraPermissionLauncher = activity.registerForActivityResult(
            ActivityResultContracts.RequestPermission()
        ) { isGranted: Boolean ->
            if (isGranted) {
                Log.i(TAG, "Camera permission granted. Initializing camera.")
                initializeCamera()
            } else {
                Log.w(TAG, "Camera permission denied.")
                Toast.makeText(activity, "Camera permission is required to use this app.", Toast.LENGTH_LONG).show()
                // Optionally, guide user to settings or disable camera-dependent features
            }
        }
    }

    fun checkPermissionsAndSetupCamera() {
        when {
            ContextCompat.checkSelfPermission(
                activity,
                Manifest.permission.CAMERA
            ) == PackageManager.PERMISSION_GRANTED -> {
                Log.i(TAG, "Camera permission already granted. Initializing camera.")
                initializeCamera()
            }
            activity.shouldShowRequestPermissionRationale(Manifest.permission.CAMERA) -> {
                Log.i(TAG, "Showing rationale for camera permission.")
                Toast.makeText(activity, "Camera access is crucial for the augmented reality features.", Toast.LENGTH_LONG).show()
                requestCameraPermissionLauncher.launch(Manifest.permission.CAMERA)
            }
            else -> {
                Log.i(TAG, "Requesting camera permission.")
                requestCameraPermissionLauncher.launch(Manifest.permission.CAMERA)
            }
        }
    }

    private fun initializeCamera() {
        ballDetector = BallDetector() // Initialize ML Kit BallDetector
        cameraProviderFuture = ProcessCameraProvider.getInstance(activity)
        lifecycleOwner.lifecycleScope.launch {
            try {
                val cameraProvider = cameraProviderFuture.await()
                bindCameraUseCases(cameraProvider)
            } catch (e: Exception) {
                Log.e(TAG, "Error initializing camera provider or binding use cases: ", e)
                Toast.makeText(activity, "Could not initialize camera: ${e.message}", Toast.LENGTH_LONG).show()
            }
        }
    }

    private fun bindCameraUseCases(cameraProvider: ProcessCameraProvider) {
        val preview = Preview.Builder().build()
        val cameraSelector = CameraSelector.Builder()
            .requireLensFacing(CameraSelector.LENS_FACING_BACK) // Use back camera
            .build()

        preview.surfaceProvider = previewView.surfaceProvider

        val imageAnalysis: ImageAnalysis = ImageAnalysis.Builder()
            .setTargetResolution(Size(IMAGE_ANALYSIS_WIDTH, IMAGE_ANALYSIS_HEIGHT))
            .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST) // Only analyze the most recent frame
            .build()
            .also {
                it.setAnalyzer(analysisExecutor, BallDetectionAnalyzer()) // Set custom analyzer
            }

        try {
            cameraProvider.unbindAll() // Unbind use cases before rebinding to prevent errors
            activeCamera = cameraProvider.bindToLifecycle(
                lifecycleOwner,
                cameraSelector,
                preview,
                imageAnalysis // Bind ImageAnalysis along with Preview
            )
            Log.i(TAG, "Camera preview and image analysis bound to lifecycle.")

            // Update AppState with camera zoom capabilities
            val cameraInfo = activeCamera?.cameraInfo
            if (cameraInfo != null) {
                mainOverlayView.updateCameraZoomCapabilities(
                    cameraInfo.zoomState.value?.minZoomRatio ?: 1.0f,
                    cameraInfo.zoomState.value?.maxZoomRatio ?: 1.0f
                )
                Log.d(TAG, "Camera Zoom Capabilities: Min=${cameraInfo.zoomState.value?.minZoomRatio}, Max=${cameraInfo.zoomState.value?.maxZoomRatio}")
            }

        } catch (exception: Exception) {
            Log.e(TAG, "Use case binding failed for camera: ", exception)
            Toast.makeText(activity, "Camera binding failed: ${exception.message}", Toast.LENGTH_LONG).show()
        }
    }

    /**
     * Sets the camera's zoom ratio.
     * @param ratio The desired zoom ratio. Will be clamped between min and max supported ratios.
     */
    fun setCameraZoomRatio(ratio: Float) {
        activeCamera?.cameraControl?.setZoomRatio(ratio)
        // No direct callback for zoom ratio change, but zoomState can be observed.
        // For simplicity, we assume the command will be executed.
    }

    /**
     * Gets the camera's current zoom ratio.
     */
    fun getCurrentZoomRatio(): Float {
        return activeCamera?.cameraInfo?.zoomState?.value?.zoomRatio ?: 1.0f
    }

    /**
     * Gets the camera's minimum supported zoom ratio.
     */
    fun getMinZoomRatio(): Float {
        return activeCamera?.cameraInfo?.zoomState?.value?.minZoomRatio ?: 1.0f
    }

    /**
     * Gets the camera's maximum supported zoom ratio.
     */
    fun getMaxZoomRatio(): Float {
        return activeCamera?.cameraInfo?.zoomState?.value?.maxZoomRatio ?: 1.0f
    }

    // Custom ImageAnalysis Analyzer for ball detection using ML Kit
    private inner class BallDetectionAnalyzer : ImageAnalysis.Analyzer {
        override fun analyze(imageProxy: ImageProxy) {
            ballDetector.detectBalls(
                imageProxy,
                onDetectionSuccess = { balls ->
                    // Pass detected balls and the original camera frame dimensions to MainOverlayView on the UI thread
                    activity.runOnUiThread {
                        mainOverlayView.updateTrackedBalls(balls, imageProxy.width, imageProxy.height)
                    }
                },
                onDetectionFailure = { e ->
                    Log.e(TAG, "Ball detection failed: $e")
                    // You might want to clear tracked balls or show a message on UI
                    activity.runOnUiThread {
                        mainOverlayView.updateTrackedBalls(emptyList(), imageProxy.width, imageProxy.height)
                    }
                }
            )
            // ImageProxy is closed within BallDetector.detectBalls on completion listener.
        }
    }

    /**
     * Shuts down the camera executor and unbinds camera use cases.
     */
    fun shutdown() {
        analysisExecutor.shutdown()
        ballDetector.shutdown() // Shutdown ML Kit detector
        // It's good practice to unbind all use cases on shutdown
        cameraProviderFuture.get()?.unbindAll()
        Log.i(TAG, "CameraManager shutdown complete.")
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\system\PitchSensor.kt
================================================================================
package com.hereliesaz.cuedetat.system

import android.content.Context
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.util.Log
import android.widget.Toast
import com.hereliesaz.cuedetat.config.AppConfig // For TAG only

class PitchSensor(
    private val context: Context,
    private val forwardTiltOffsetDegrees: Float, // Specific value passed in
    private val onPitchChanged: (Float) -> Unit
) : SensorEventListener {

    private companion object {
        private val TAG = AppConfig.TAG + "_PitchSensor"
    }

    private var sensorManager: SensorManager? = null
    private var rotationVectorSensor: Sensor? = null
    private val rotationMatrix = FloatArray(9)
    private val orientationAngles = FloatArray(3)

    init {
        sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as? SensorManager
        if (sensorManager == null) {
            Log.e(TAG, "Failed to get SensorManager service.")
            Toast.makeText(context, "Sensor service not available.", Toast.LENGTH_LONG).show()
        } else {
            rotationVectorSensor = sensorManager?.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR)
            if (rotationVectorSensor == null) {
                Log.w(TAG, "Rotation Vector Sensor not available on this device.")
                Toast.makeText(context, "Rotation Vector Sensor not available.", Toast.LENGTH_LONG).show()
            } else {
                Log.i(TAG, "Rotation Vector Sensor initialized.")
            }
        }
    }

    fun register() {
        if (rotationVectorSensor == null || sensorManager == null) {
            Log.w(TAG, "Cannot register listener: Sensor or SensorManager not available.")
            return
        }
        val registered = sensorManager?.registerListener(this, rotationVectorSensor, SensorManager.SENSOR_DELAY_GAME)
        if (registered == true) {
            Log.i(TAG, "PitchSensor listener registered.")
        } else {
            Log.e(TAG, "Failed to register PitchSensor listener.")
        }
    }

    fun unregister() {
        if (sensorManager == null) {
            Log.w(TAG, "Cannot unregister listener: SensorManager not available.")
            return
        }
        sensorManager?.unregisterListener(this)
        Log.i(TAG, "PitchSensor listener unregistered.")
    }

    override fun onSensorChanged(event: SensorEvent?) {
        if (event?.sensor?.type == Sensor.TYPE_ROTATION_VECTOR) {
            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)
            SensorManager.getOrientation(rotationMatrix, orientationAngles)

            val rawPitchInRadians = orientationAngles[1]
            val rawPitchInDegrees = Math.toDegrees(rawPitchInRadians.toDouble()).toFloat()
            val conventionalAppPitch = -rawPitchInDegrees
            val finalAppPitch = conventionalAppPitch - forwardTiltOffsetDegrees // Use passed offset
            onPitchChanged(finalAppPitch)
        }
    }

    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {
        // Log.d(TAG, "Sensor accuracy changed for ${sensor?.name}: $accuracy")
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\config\AppConfig.kt
================================================================================
package com.hereliesaz.cuedetat.config

object AppConfig {
    const val TAG = "CueDEtatApp"

    // Zoom Configuration
    const val MIN_ZOOM_FACTOR = 0.1f
    const val MAX_ZOOM_FACTOR = 4.0f
    const val DEFAULT_ZOOM_FACTOR = 0.4f

    // Pitch Sensor and Angle Configuration
    const val PITCH_SMOOTHING_FACTOR = 0.15f
    const val FORWARD_TILT_AS_FLAT_OFFSET_DEGREES = 15.0f

    // Protractor Visuals Configuration
    val PROTRACTOR_ANGLES = floatArrayOf(0f, 14f, 30f, 36f, 43f, 48f)

    // Interaction Configuration
    const val PAN_ROTATE_SENSITIVITY = 0.3f
    const val DEFAULT_ROTATION_ANGLE = 0.0f

    // General Graphics Configuration
    const val GLOW_RADIUS_FIXED = 8f

    // Text Size Configuration
    const val GHOST_BALL_NAME_BASE_SIZE = 40f
    const val FIT_TARGET_INSTRUCTION_BASE_SIZE_FACTOR = 0.9f
    const val PLACE_CUE_INSTRUCTION_BASE_SIZE_FACTOR = 0.9f
    const val HINT_TEXT_BASE_SIZE = 40f
    const val HINT_TEXT_SIZE_MULTIPLIER = 0.70f
    const val INVALID_SHOT_WARNING_BASE_SIZE = 160f
    const val SPECIAL_WARNING_TEXT_SMALLER_SIZE = 110f

    const val PLANE_LABEL_BASE_SIZE = 40f
    const val PROJECTED_SHOT_TEXT_SIZE_FACTOR = 1.0f
    const val TANGENT_LINE_TEXT_SIZE_FACTOR = 1.1f
    const val CUE_BALL_PATH_TEXT_SIZE_FACTOR = 1.1f
    const val POCKET_AIM_TEXT_SIZE_FACTOR = 1.25f

    const val TEXT_MIN_SCALE_FACTOR = 0.65f
    const val TEXT_MAX_SCALE_FACTOR = 1.5f

    // Default helper text color ARGB value
    const val DEFAULT_HELP_TEXT_COLOR_ARGB = 0xFFD1C4E9.toInt()

    // Paint Stroke Widths
    const val STROKE_AIM_LINE_NEAR = 4f
    const val STROKE_AIM_LINE_FAR = 2f
    const val STROKE_TARGET_LINE_GUIDE = 5f
    const val STROKE_DEFLECTION_LINE = 2f
    const val STROKE_DEFLECTION_LINE_BOLD_INCREASE = 4f
    const val STROKE_GHOST_BALL_OUTLINE = 3f
    const val STROKE_MAIN_CIRCLES = 5f
    const val STROKE_PROTRACTOR_ANGLE_LINES = 3f
    const val STROKE_AIMING_SIGHT = 2f
    const val STROKE_FOLLOW_DRAW_PATH = 3f // Correct constant name

    // Follow/Draw Path Visuals Configuration
    const val FOLLOW_EFFECT_DEVIATION_DEGREES = -25.0f // Negative for one side of tangent
    const val DRAW_EFFECT_DEVIATION_DEGREES = 25.0f    // Positive for the other side
    const val CURVE_CONTROL_POINT_FACTOR = 0.6f // Controls "bow" (0.0-1.0)
    const val PATH_DRAW_LENGTH_FACTOR = 0.7f    // Length of paths relative to deflection line length
    const val PATH_OPACITY_ALPHA = 180          // Opacity for these paths

    // GitHub Release Updater Configuration
    const val GITHUB_REPO_OWNER = "HereLiesAz" // Updated to match the provided URL
    const val GITHUB_REPO_NAME = "CueDetat" // Updated to match the provided URL
    const val GITHUB_RELEASE_ASSET_NAME_REGEX = ".*\\.apk" // Regex to match your APK asset name


    // Warning Strings
    const val WARNING_MRS_CALLED = "Your Mrs. called, she wants her title back."
    const val WARNING_YODA_SAYS = "Yoda says, 'A do not, this is.'"
    val INSULTING_WARNING_STRINGS = listOf( // Ensure this is used if random warnings are active
        "Nope.", "Not happening.", "Won't work.", "Please try harder.", "No.",
        "Physics says no.", WARNING_MRS_CALLED,
        "Hey batter, batter...", "In the beginning, God created a better shot.",
        WARNING_YODA_SAYS, "Am I crying from laughing, or is this just sad?",
        "Are you even trying?", "That's... an angle. Not a good one.",
        "My disappointment is immeasurable.", "Consult a physicist. Or a therapist."
    )
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\state\AppState.kt
================================================================================
package com.hereliesaz.cuedetat.state

import android.graphics.Camera
import android.graphics.Matrix
import android.graphics.PointF
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.tracking.ball_detector.Ball // Import Ball class
import kotlin.math.abs
import kotlin.math.cos
import kotlin.math.min
import kotlin.math.sin

class AppState(val config: AppConfig) { // Changed from 'private val' to 'val'

    // --- View Dimensions & Initialization ---
    var viewWidth: Int = 0
        private set
    var viewHeight: Int = 0
        private set
    var isInitialized: Boolean = false
        private set

    // --- Ball Tracking Data (Raw from ML Kit, scaled to MainOverlayView) ---
    var trackedBalls: List<Ball> = emptyList() // All detected balls from the camera frame
    var frameWidth: Int = 0 // Raw pixel dimensions of the camera frame used for tracking
    var frameHeight: Int = 0

    // --- Selected Ball Data (Screen-space, in MainOverlayView pixels) ---
    var selectedCueBallId: String? = null
        private set
    var selectedCueBallScreenCenter: PointF? = null
        private set
    var selectedCueBallScreenRadius: Float = 0f
        private set

    var selectedTargetBallId: String? = null
        private set
    var selectedTargetBallScreenCenter: PointF? = null
        private set
    var selectedTargetBallScreenRadius: Float = 0f
        private set

    // --- Protractor Plane Elements (Logical, derived from selected balls) ---
    // targetCircleCenter and cueCircleCenter are the *logical centers* of the protractor's balls
    // which represent the ghost balls on the 2D plane.
    var targetCircleCenter: PointF = PointF()
        private set
    var cueCircleCenter: PointF = PointF()
        private set
    // currentLogicalRadius now represents the effective radius of the target ball in logical units.
    // Its size directly reflects the detected pixel radius, as CameraX zoom controls the overall scale.
    var currentLogicalRadius: Float = 1f
        private set


    // --- User Interaction State ---
    // This zoomFactor now directly controls CameraX's zoom ratio (1.0f is no optical zoom).
    var zoomFactor: Float = 1.0f // Default camera zoom is 1.0x (no optical zoom)
        private set
    // CameraX capabilities
    var minCameraZoomRatio: Float = 1.0f
        private set
    var maxCameraZoomRatio: Float = 1.0f
        private set

    var protractorRotationAngle: Float = config.DEFAULT_ROTATION_ANGLE
        private set
    var currentMode: SelectionMode = SelectionMode.SELECTING_CUE_BALL // New: Initial selection mode

    // --- Device Orientation State ---
    var currentPitchAngle: Float = 0.0f
        private set
    var smoothedPitchAngle: Float = 0.0f
        private set

    // --- Graphics Matrices & Camera for 3D effect ---
    val graphicsCamera: Camera = Camera()
    val pitchMatrix: Matrix = Matrix()
    val inversePitchMatrix: Matrix = Matrix()

    // --- UI State ---
    var areHelperTextsVisible: Boolean = true // Default to ON for user guidance
        private set

    enum class SelectionMode {
        SELECTING_CUE_BALL,
        SELECTING_TARGET_BALL,
        AIMING
    }

    /**
     * Initializes or re-initializes the AppState with current view dimensions.
     * Sets default positions and radius if no ball is tracked or selected.
     */
    fun initialize(width: Int, height: Int) {
        if (width <= 0 || height <= 0) return

        viewWidth = width
        viewHeight = height

        // Update protractor's logical base based on selected target ball if available,
        // otherwise default to screen center.
        if (selectedTargetBallScreenCenter != null && selectedTargetBallScreenRadius > 0f) {
            targetCircleCenter.set(selectedTargetBallScreenCenter!!.x, selectedTargetBallScreenCenter!!.y)
            // currentLogicalRadius is now just the detected screen radius, as camera zoom handles scale.
            currentLogicalRadius = selectedTargetBallScreenRadius
        } else {
            targetCircleCenter.set(viewWidth / 2f, viewHeight / 2f) // Default to screen center
            // Default logical radius is a percentage of view size (if no ball is selected).
            currentLogicalRadius = min(viewWidth, viewHeight) * 0.15f
        }

        // Ensure a minimum radius to prevent division by zero or infinitesimally small elements
        if (currentLogicalRadius <= 0.01f) currentLogicalRadius = 0.01f

        smoothedPitchAngle = currentPitchAngle // Initialize smoothed pitch
        isInitialized = true
        updateCueBallPlanePosition() // Position logical cue ball relative to the (potentially tracked) target
    }

    /**
     * Updates the camera's zoom capabilities.
     */
    fun updateCameraZoomCapabilities(minZoom: Float, maxZoom: Float) {
        minCameraZoomRatio = minZoom
        maxCameraZoomRatio = maxZoom
        // Ensure current zoom is within new bounds if capabilities change mid-app
        zoomFactor = zoomFactor.coerceIn(minCameraZoomRatio, maxCameraZoomRatio)
    }

    /**
     * Updates the selected cue ball's tracked data.
     * @param ball The selected cue ball.
     */
    fun updateSelectedCueBall(ball: Ball) {
        selectedCueBallId = ball.id
        selectedCueBallScreenCenter = PointF(ball.x, ball.y)
        selectedCueBallScreenRadius = ball.radius
    }

    /**
     * Clears the selected cue ball data.
     */
    fun clearSelectedCueBall() {
        selectedCueBallId = null
        selectedCueBallScreenCenter = null
        selectedCueBallScreenRadius = 0f
    }

    /**
     * Updates the selected target ball's tracked data and repositions the protractor.
     * @param ball The selected target ball.
     */
    fun updateSelectedTargetBall(ball: Ball) {
        selectedTargetBallId = ball.id
        selectedTargetBallScreenCenter = PointF(ball.x, ball.y)
        selectedTargetBallScreenRadius = ball.radius

        // Re-initialize protractor base (logical target center and radius) to match the new target ball
        initialize(viewWidth, viewHeight)
    }

    /**
     * Clears the selected target ball data and resets protractor position to default.
     */
    fun clearSelectedTargetBall() {
        selectedTargetBallId = null
        selectedTargetBallScreenCenter = null
        selectedTargetBallScreenRadius = 0f
        initialize(viewWidth, viewHeight) // Re-initialize to set defaults if no tracked ball
    }


    /**
     * Updates the camera zoom factor. This value is clamped by camera capabilities.
     * @param newFactor The new desired camera zoom factor (e.g., 1.0f for no optical zoom).
     * @return True if the zoom factor changed significantly, false otherwise.
     */
    fun updateZoomFactor(newFactor: Float): Boolean {
        val coercedFactor = newFactor.coerceIn(minCameraZoomRatio, maxCameraZoomRatio)
        // Only update if there's a significant change to prevent unnecessary CameraX calls
        if (abs(zoomFactor - coercedFactor) < 0.001f) return false

        zoomFactor = coercedFactor
        // currentLogicalRadius is NOT updated here, it's updated in initialize() or setTrackedTargetBallData()
        // when a ball is detected/selected, using its *current detected pixel radius*.
        // The camera zoom *already* affects the detected pixel radius.
        return true
    }

    /**
     * Updates the rotation angle of the protractor.
     *
     * @param newAngle The new desired rotation angle in degrees.
     * @return True if the rotation angle changed significantly, false otherwise.
     */
    fun updateProtractorRotationAngle(newAngle: Float): Boolean {
        var normalizedAngle = newAngle % 360f
        if (normalizedAngle < 0) normalizedAngle += 360f // Normalize angle to 0-360 degrees

        // Only update if there's a significant change
        if (abs(protractorRotationAngle - normalizedAngle) < 0.01f) return false

        protractorRotationAngle = normalizedAngle
        updateCueBallPlanePosition() // Recalculate logical cue ball position as rotation changed
        return true
    }

    /**
     * Updates the device's pitch angle, applying a smoothing factor.
     *
     * @param newRawPitch The raw pitch angle from the sensor.
     * @return True if the smoothed pitch angle changed significantly, false otherwise.
     */
    fun updateDevicePitchAngle(newRawPitch: Float): Boolean {
        val newSmoothedPitch = (config.PITCH_SMOOTHING_FACTOR * newRawPitch) +
                ((1.0f - config.PITCH_SMOOTHING_FACTOR) * smoothedPitchAngle)

        // Only update if there's a significant change to prevent excessive redraws
        if (abs(currentPitchAngle - newSmoothedPitch) > 0.05f) {
            currentPitchAngle = newSmoothedPitch
            smoothedPitchAngle = newSmoothedPitch
            return true
        }
        smoothedPitchAngle = newSmoothedPitch // Always update smoothed value for next iteration
        return false
    }

    /**
     * Recalculates the position of the logical cue ball (ghost ball) based on the current logical target ball
     * position, logical radius, and protractor rotation.
     */
    private fun updateCueBallPlanePosition() {
        if (!isInitialized || currentLogicalRadius <= 0.01f) return

        val angleRad = Math.toRadians(protractorRotationAngle.toDouble())
        val distanceFromTarget = 2 * currentLogicalRadius // Logical cue ball is positioned two radii away from the target

        // Calculate logical cue ball's position relative to the logical target ball's center,
        // rotated by the protractor's current angle.
        cueCircleCenter.x = targetCircleCenter.x - (distanceFromTarget * sin(angleRad)).toFloat()
        cueCircleCenter.y = targetCircleCenter.y + (distanceFromTarget * cos(angleRad)).toFloat()
    }

    /**
     * Resets user-controlled interaction states (zoom, rotation, and target ball selection)
     * to their default values defined in `AppConfig`.
     */
    fun resetInteractions() {
        clearSelectedCueBall()
        clearSelectedTargetBall() // This calls initialize internally to reset targetCircleCenter etc.
        currentMode = SelectionMode.SELECTING_CUE_BALL // Reset to initial mode
        // Reset camera zoom to default (1.0f)
        updateZoomFactor(1.0f) // This will trigger CameraX zoom reset
        updateProtractorRotationAngle(config.DEFAULT_ROTATION_ANGLE)
    }

    /**
     * Toggles the visibility of all helper text labels on the overlay.
     */
    fun toggleHelperTextVisibility() {
        areHelperTextsVisible = !areHelperTextsVisible
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\state\AppPaints.kt
================================================================================
// FILE: app\src\main\java\com\hereliesaz\cuedetat\state\AppPaints.kt
package com.hereliesaz.cuedetat.state

import android.content.Context
import android.graphics.Color as AndroidColor
import android.graphics.DashPathEffect
import android.graphics.Paint
import android.graphics.Typeface
import androidx.compose.material3.ColorScheme
import androidx.compose.ui.graphics.toArgb
import androidx.core.content.res.ResourcesCompat
import com.hereliesaz.cuedetat.R
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.ui.theme.*

class AppPaints(private val context: Context, private val config: AppConfig) {

    private val archivoBlackTypeface: Typeface? = ResourcesCompat.getFont(context, R.font.archivo_black_regular)

    var M3_COLOR_PRIMARY: Int = AndroidColor.BLUE
    var M3_COLOR_SECONDARY: Int = AndroidColor.RED
    var M3_COLOR_TERTIARY: Int = AndroidColor.GREEN
    var M3_COLOR_ON_SURFACE: Int = AndroidColor.WHITE
    var M3_COLOR_OUTLINE: Int = AndroidColor.LTGRAY
    var M3_COLOR_ERROR: Int = AndroidColor.RED
    var M3_COLOR_PRIMARY_CONTAINER: Int = AndroidColor.CYAN
    var M3_COLOR_SECONDARY_CONTAINER: Int = AndroidColor.MAGENTA
    var M3_TEXT_SHADOW_COLOR: Int = AndroidColor.argb(180, 0, 0, 0)
    var M3_GLOW_COLOR: Int = AndroidColor.argb(100, 255, 255, 224)

    val targetCirclePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.STROKE; strokeWidth = config.STROKE_MAIN_CIRCLES }
    val cueCirclePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.STROKE; strokeWidth = config.STROKE_MAIN_CIRCLES }
    val centerMarkPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.FILL }
    val protractorAngleLinePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { strokeWidth = config.STROKE_PROTRACTOR_ANGLE_LINES }
    val targetLineGuidePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { strokeWidth = config.STROKE_TARGET_LINE_GUIDE }
    val deflectionDottedPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { strokeWidth = config.STROKE_DEFLECTION_LINE; style = Paint.Style.STROKE; pathEffect = DashPathEffect(floatArrayOf(15f, 10f), 0f) }
    val deflectionSolidPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        strokeWidth = config.STROKE_DEFLECTION_LINE + config.STROKE_DEFLECTION_LINE_BOLD_INCREASE
        style = Paint.Style.STROKE; pathEffect = null
    }
    val shotGuideNearPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.STROKE; strokeWidth = config.STROKE_AIM_LINE_NEAR }
    val shotGuideFarPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.STROKE; strokeWidth = config.STROKE_AIM_LINE_FAR }

    val ghostCueOutlinePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.STROKE; strokeWidth = config.STROKE_GHOST_BALL_OUTLINE }
    val ghostTargetOutlinePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.STROKE; strokeWidth = config.STROKE_GHOST_BALL_OUTLINE }
    val ghostCueAimingSightPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { strokeWidth = config.STROKE_AIMING_SIGHT; style = Paint.Style.STROKE }

    // Corrected paint names for Follow and Draw paths
    val followPathPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        style = Paint.Style.STROKE; strokeWidth = config.STROKE_FOLLOW_DRAW_PATH
    }
    val drawPathPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        style = Paint.Style.STROKE; strokeWidth = config.STROKE_FOLLOW_DRAW_PATH
    }

    private fun createBaseHelperTextPaint(): Paint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        typeface = archivoBlackTypeface; textAlign = Paint.Align.CENTER
    }
    val projectedShotTextPaint = createBaseHelperTextPaint().apply { color = AppHelpTextProjectedShotLineActual.toArgb() }
    val tangentLineTextPaint = createBaseHelperTextPaint().apply { color = AppHelpTextTangentLine.toArgb() } // Changed from AppPurple
    val cueBallPathTextPaint = createBaseHelperTextPaint().apply { color = AppHelpTextTangentLine.toArgb() }
    val pocketAimTextPaint = createBaseHelperTextPaint().apply { color = AppHelpTextPocketAim.toArgb() }
    val invalidShotWarningPaint = createBaseHelperTextPaint().apply {
        color = AppErrorRed.toArgb(); typeface = archivoBlackTypeface ?: Typeface.create(Typeface.DEFAULT, Typeface.BOLD)
        setShadowLayer(3f, 2f, 2f, AndroidColor.argb(180,0,0,0))
    }
    val ghostTargetNamePaint = createBaseHelperTextPaint().apply { color = AppHelpTextTargetBallLabel.toArgb() }
    val ghostCueNamePaint = createBaseHelperTextPaint().apply { color = AppHelpTextGhostBallLabel.toArgb() }
    val fitTargetInstructionPaint = createBaseHelperTextPaint().apply { color = AppHelpTextYellow.toArgb(); textAlign = Paint.Align.LEFT }
    val placeCueInstructionPaint = createBaseHelperTextPaint().apply { color = AppHelpTextPocketAim.toArgb() }
    // Update these two lines to use the AppConfig constant
    val panHintPaint = createBaseHelperTextPaint().apply { color = AndroidColor.argb(
        AndroidColor.alpha(config.DEFAULT_HELP_TEXT_COLOR_ARGB),
        AndroidColor.red(config.DEFAULT_HELP_TEXT_COLOR_ARGB),
        AndroidColor.green(config.DEFAULT_HELP_TEXT_COLOR_ARGB),
        AndroidColor.blue(config.DEFAULT_HELP_TEXT_COLOR_ARGB)
    ); textAlign = Paint.Align.LEFT }
    val pinchHintPaint = createBaseHelperTextPaint().apply { color = AndroidColor.argb(
        AndroidColor.alpha(config.DEFAULT_HELP_TEXT_COLOR_ARGB),
        AndroidColor.red(config.DEFAULT_HELP_TEXT_COLOR_ARGB),
        AndroidColor.green(config.DEFAULT_HELP_TEXT_COLOR_ARGB),
        AndroidColor.blue(config.DEFAULT_HELP_TEXT_COLOR_ARGB)
    ); textAlign = Paint.Align.LEFT }

    // New instruction paint for selection modes
    val selectionInstructionPaint = createBaseHelperTextPaint().apply {
        color = AppHelpTextYellow.toArgb()
        setShadowLayer(2f, 1f, 1f, AndroidColor.argb(120, 0, 0, 0))
    }


    init {
        targetCirclePaint.color = AppYellow.toArgb()
        cueCirclePaint.color = AppWhite.toArgb()
        centerMarkPaint.color = AppBlack.toArgb()
        protractorAngleLinePaint.color = AppMediumGray.toArgb()
        targetLineGuidePaint.color = AppYellow.toArgb()
        deflectionDottedPaint.color = AppWhite.toArgb()
        deflectionSolidPaint.color = AppWhite.toArgb()
        shotGuideNearPaint.color = AppWhite.toArgb()
        shotGuideFarPaint.color = AppPurple.toArgb()
        ghostTargetOutlinePaint.color = AppYellow.toArgb()
        ghostCueOutlinePaint.color = AppWhite.toArgb()
        ghostCueAimingSightPaint.color = AppYellow.toArgb()

        // Using AppConfig constants for opacity
        val followColorRGB = AppErrorRed.toArgb()
        followPathPaint.color = AndroidColor.argb(config.PATH_OPACITY_ALPHA, AndroidColor.red(followColorRGB), AndroidColor.green(followColorRGB), AndroidColor.blue(followColorRGB))
        val drawColorRGB = AppPurple.toArgb()
        drawPathPaint.color = AndroidColor.argb(config.PATH_OPACITY_ALPHA, AndroidColor.red(drawColorRGB), AndroidColor.green(drawColorRGB), AndroidColor.blue(drawColorRGB))
    }

    fun applyMaterialYouColors(colorScheme: ColorScheme) {
        M3_COLOR_PRIMARY = colorScheme.primary.toArgb(); M3_COLOR_SECONDARY = colorScheme.secondary.toArgb(); M3_COLOR_TERTIARY = colorScheme.tertiary.toArgb()
        M3_COLOR_ON_SURFACE = colorScheme.onSurface.toArgb(); M3_COLOR_OUTLINE = colorScheme.outline.toArgb(); M3_COLOR_ERROR = colorScheme.error.toArgb()
        M3_COLOR_PRIMARY_CONTAINER = colorScheme.primaryContainer.toArgb(); M3_COLOR_SECONDARY_CONTAINER = colorScheme.secondaryContainer.toArgb()
        val primaryComposeColor = colorScheme.primary
        M3_GLOW_COLOR = AndroidColor.argb(100, AndroidColor.red(primaryComposeColor.toArgb()), AndroidColor.green(primaryComposeColor.toArgb()), AndroidColor.blue(primaryComposeColor.toArgb()))
        val surfaceColor = colorScheme.surface.toArgb()
        val surfaceBrightness = (AndroidColor.red(surfaceColor) * 299 + AndroidColor.green(surfaceColor) * 587 + AndroidColor.blue(surfaceColor) * 114) / 1000
        M3_TEXT_SHADOW_COLOR = if (surfaceBrightness < 128) AndroidColor.argb(180,220,220,220) else AndroidColor.argb(180, 30,30,30)
        val tertiaryBase = M3_COLOR_TERTIARY
        protractorAngleLinePaint.color = AndroidColor.argb(170, AndroidColor.red(tertiaryBase), AndroidColor.green(tertiaryBase), AndroidColor.blue(tertiaryBase))
        centerMarkPaint.color = M3_COLOR_ON_SURFACE
        deflectionSolidPaint.setShadowLayer(config.GLOW_RADIUS_FIXED, 0f, 0f, M3_GLOW_COLOR)
        val helperShadowColor = AndroidColor.argb(120, 0,0,0)
        val allHelperTextPaints = listOf(
            projectedShotTextPaint, tangentLineTextPaint, cueBallPathTextPaint, pocketAimTextPaint,
            ghostTargetNamePaint, ghostCueNamePaint, fitTargetInstructionPaint, placeCueInstructionPaint,
            panHintPaint, pinchHintPaint, selectionInstructionPaint // Include new paint
        )
        allHelperTextPaints.forEach { paint ->
            paint.setShadowLayer(1.5f,1.5f,1.5f, helperShadowColor); paint.typeface = archivoBlackTypeface ?: paint.typeface
        }
        invalidShotWarningPaint.setShadowLayer(3f, 2f, 2f, M3_TEXT_SHADOW_COLOR)

        // Update Follow/Draw path colors if they should be themed, using config.PATH_OPACITY_ALPHA
        // Example: Using M3 secondary and tertiary
        val themedFollowColor = colorScheme.secondary.toArgb() // Or error, etc.
        followPathPaint.color = AndroidColor.argb(config.PATH_OPACITY_ALPHA, AndroidColor.red(themedFollowColor), AndroidColor.green(themedFollowColor), AndroidColor.blue(themedFollowColor))
        val themedDrawColor = colorScheme.tertiary.toArgb() // Or primary, etc.
        drawPathPaint.color = AndroidColor.argb(config.PATH_OPACITY_ALPHA, AndroidColor.red(themedDrawColor), AndroidColor.green(themedDrawColor), AndroidColor.blue(themedDrawColor))
    }
    fun resetDynamicPaintProperties() {
        targetLineGuidePaint.apply { strokeWidth = config.STROKE_TARGET_LINE_GUIDE; color = AppYellow.toArgb(); clearShadowLayer() }
        deflectionSolidPaint.clearShadowLayer()
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\view\gesture\GestureHandler.kt
================================================================================
package com.hereliesaz.cuedetat.view.gesture

import android.content.Context
import android.view.MotionEvent
import android.view.ScaleGestureDetector
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.state.AppState.SelectionMode // Import SelectionMode
import com.hereliesaz.cuedetat.view.MainOverlayView.AppStateListener // Assuming AppStateListener is nested or accessible
import kotlin.math.abs

class GestureHandler(
    context: Context,
    private val appState: AppState,
    private val config: AppConfig,
    private val listener: AppStateListener?, // Listener for state changes originating from gestures
    private val onZoomChangedByGesture: (Float) -> Unit,
    private val onRotationChangedByGesture: (Float) -> Unit
) {
    private var lastTouchX = 0f
    private var lastTouchY = 0f // Kept for potential future use (e.g., two-finger pan)

    private enum class InteractionMode { NONE, PINCH_ZOOMING, PAN_TO_ROTATE }
    private var currentInteractionMode = InteractionMode.NONE
    private var isPinching = false // Flag to manage pinch state across events

    val scaleGestureDetector: ScaleGestureDetector = ScaleGestureDetector(context, ScaleListener())

    private inner class ScaleListener : ScaleGestureDetector.SimpleOnScaleGestureListener() {
        override fun onScaleBegin(detector: ScaleGestureDetector): Boolean {
            // Allow zoom only in AIMING mode
            if (appState.currentMode != SelectionMode.AIMING) return false

            currentInteractionMode = InteractionMode.PINCH_ZOOMING
            isPinching = true
            listener?.onUserInteraction() // Notify general interaction
            return true
        }

        override fun onScale(detector: ScaleGestureDetector): Boolean {
            if (currentInteractionMode != InteractionMode.PINCH_ZOOMING || appState.currentMode != SelectionMode.AIMING) return false

            appState.zoomFactor
            // Detector scaleFactor is relative to the start of the current scale gesture
            val newZoomUncoerced = appState.zoomFactor * detector.scaleFactor

            // Check if the change is significant enough or if it's trying to scale
            // The actual updateZoomFactor in AppState will handle coercion and actual change detection.
            // We call onZoomChangedByGesture with the uncoerced factor, letting the MainOverlayView's
            // internal logic handle the update through AppState.
            if (detector.scaleFactor != 1.0f) { // If there's any scaling attempt
                onZoomChangedByGesture(newZoomUncoerced) // Pass the raw desired factor
            }
            return true
        }

        override fun onScaleEnd(detector: ScaleGestureDetector) {
            if (currentInteractionMode == InteractionMode.PINCH_ZOOMING) {
                currentInteractionMode = InteractionMode.NONE
            }
            isPinching = false
        }
    }

    fun onTouchEvent(event: MotionEvent): Boolean {
        if (!appState.isInitialized) return false

        // Let ScaleGestureDetector inspect all events.
        val scaleHandled = scaleGestureDetector.onTouchEvent(event)

        // If a scale gesture is in progress (pinching), it usually consumes the events.
        // We manage isPinching to prevent pan during a scale.
        if (scaleGestureDetector.isInProgress) {
            isPinching = true // Ensure this is set if scale is ongoing
            // When scaling ends, onScaleEnd will reset isPinching.
            return true // Scale gesture consumed the event
        }
        // If scale was in progress but just ended with this event (e.g. UP),
        // onScaleEnd would have set isPinching to false.

        val touchX = event.x

        when (event.actionMasked) {
            MotionEvent.ACTION_DOWN -> {
                // Allow pan/rotate only in AIMING mode
                if (appState.currentMode != SelectionMode.AIMING) return false

                // If not starting a scale gesture, consider it a pan start.
                if (!isPinching) { // isPinching should be false here if scale isn't in progress
                    currentInteractionMode = InteractionMode.PAN_TO_ROTATE
                    listener?.onUserInteraction()
                }
                lastTouchX = touchX
                lastTouchY = event.y // Store Y for potential future use
                // Return true if we initiated a pan, or if scale detector might handle it (though less likely on ACTION_DOWN alone if not multi-touch)
                return true // Consume ACTION_DOWN to receive subsequent MOVE/UP events
            }
            MotionEvent.ACTION_MOVE -> {
                if (currentInteractionMode == InteractionMode.PAN_TO_ROTATE && !isPinching && appState.currentMode == SelectionMode.AIMING) {
                    val dx = touchX - lastTouchX
                    if (abs(dx) > 0.1f) { // Only rotate if there's a meaningful delta
                        val angleDelta = dx * config.PAN_ROTATE_SENSITIVITY
                        onRotationChangedByGesture(appState.protractorRotationAngle + angleDelta)
                        listener?.onUserInteraction() // Notify general interaction for rotation
                    }
                    lastTouchX = touchX
                    lastTouchY = event.y
                    return true // Pan move consumed the event
                }
            }
            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                val wasInteracting = (currentInteractionMode != InteractionMode.NONE) || isPinching
                currentInteractionMode = InteractionMode.NONE
                isPinching = false // Ensure pinch flag is reset on UP/CANCEL
                // Return true if we were panning or if scale detector handled something (e.g. quick pinch then up)
                return wasInteracting || scaleHandled
            }
        }
        // If not handled by specific actions above, and scale detector didn't handle, return false.
        // However, scaleHandled might be true from inspecting the event even if our logic paths weren't hit.
        return scaleHandled
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\view\utility\ZoomSliderLogic.kt
================================================================================
package com.hereliesaz.cuedetat.view.utility

import com.hereliesaz.cuedetat.config.AppConfig
import kotlin.math.pow // For pow function

object ZoomSliderLogic {

    // Slider Progress Convention:
    // 0   => Corresponds to minZoom
    // 100 => Corresponds to maxZoom

    // An exponent > 1.0 gives more sensitivity to the lower progress values (zoomed-out).
    // An exponent < 1.0 gives more sensitivity to the higher progress values (zoomed-in).
    private const val SLIDER_EXPONENT = 2.0 // Try values like 1.5, 2.0, 2.5

    /**
     * Converts slider progress (0-100) to a camera zoom factor.
     * @param progressInt The slider's progress (0-100).
     * @param minZoom The minimum zoom ratio supported by the camera.
     * @param maxZoom The maximum zoom ratio supported by the camera.
     * @return The calculated camera zoom factor.
     */
    fun convertSliderProgressToZoomFactor(progressInt: Int, minZoom: Float, maxZoom: Float): Float {
        val effectiveZoomRange = maxZoom - minZoom
        if (effectiveZoomRange <= 0.0001f) { // Avoid issues if range is negligible (e.g., fixed zoom camera)
            return minZoom
        }
        val progressNormalized = progressInt.toFloat() / 100.0f // Normalize progress to 0.0 - 1.0

        // Apply power function: MIN + RANGE * (progress_normalized ^ exponent)
        val scaledProgress = progressNormalized.pow(SLIDER_EXPONENT.toFloat())
        val targetZoom = minZoom + (effectiveZoomRange * scaledProgress)

        return targetZoom.coerceIn(minZoom, maxZoom)
    }

    /**
     * Converts a camera zoom factor to slider progress (0-100).
     * @param zoomFactorVal The current camera zoom factor.
     * @param minZoom The minimum zoom ratio supported by the camera.
     * @param maxZoom The maximum zoom ratio supported by the camera.
     * @return The calculated slider progress (0-100).
     */
    fun convertZoomFactorToSliderProgress(zoomFactorVal: Float, minZoom: Float, maxZoom: Float): Int {
        val effectiveZoomRange = maxZoom - minZoom
        if (effectiveZoomRange <= 0.0001f) { // Avoid issues if range is negligible
            return if (zoomFactorVal <= minZoom) 0 else 100
        }
        val currentZoomFactor = zoomFactorVal.coerceIn(minZoom, maxZoom)

        // Inverse of power function: progress_normalized = ((zoomFactor - MIN) / RANGE) ^ (1 / exponent)
        val normalizedZoom = (currentZoomFactor - minZoom) / effectiveZoomRange

        // Ensure normalizedZoom is not negative before taking root (can happen due to float precision)
        val baseForPow = normalizedZoom.coerceAtLeast(0.0f)

        val progressNormalized = baseForPow.pow(1.0f / SLIDER_EXPONENT.toFloat())
        val progress = progressNormalized * 100.0f

        return progress.toInt().coerceIn(0, 100)
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\view\MainOverlayView.kt
================================================================================
// FILE: app\src\main\java\com\hereliesaz\cuedetat\view\MainOverlayView.kt
// app/src/main/java/com/hereliesaz/cuedetat/view/MainOverlayView.kt
package com.hereliesaz.cuedetat.view

import android.content.Context
import android.graphics.Canvas // Android Canvas
import android.graphics.PointF
import android.util.AttributeSet
import android.util.Log
import android.view.GestureDetector
import android.view.MotionEvent
import android.view.View
import androidx.compose.material3.ColorScheme
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.state.AppState.SelectionMode // Import SelectionMode
import com.hereliesaz.cuedetat.drawing.DrawingCoordinator
import com.hereliesaz.cuedetat.view.gesture.GestureHandler
import com.hereliesaz.cuedetat.tracking.ball_detector.Ball // Import the Ball data class
import com.hereliesaz.cuedetat.system.CameraManager // Import CameraManager
import kotlin.math.hypot
import kotlin.math.min

class MainOverlayView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {

    private val TAG = AppConfig.TAG + "_MainOverlayView"

    /**
     * Listener interface for external components (like MainActivity) to react to state changes
     * originating from user interaction with MainOverlayView.
     */
    interface AppStateListener {
        fun onZoomChanged(newZoomFactor: Float)
        fun onRotationChanged(newRotationAngle: Float)
        fun onUserInteraction() // Generic interaction event
        fun onCueBallSelected(ballId: String?) // New: Notify when a cue ball is selected or deselected
        fun onTargetBallSelected(ballId: String?) // New: Notify when a target ball is selected or deselected
        fun onSelectionModeChanged(mode: SelectionMode) // New: Notify when selection mode changes
    }

    var listener: AppStateListener? = null

    // Initialize with default AppConfig, AppState, AppPaints.
    // These will be fully setup once view dimensions are known and M3 colors applied.
    private val config = AppConfig // Direct object reference
    private val appState = AppState(config)
    private val appPaints = AppPaints(context, config)

    private lateinit var gestureHandler: GestureHandler
    private lateinit var drawingCoordinator: DrawingCoordinator
    private lateinit var gestureDetector: GestureDetector // For handling single taps
    private lateinit var cameraManagerRef: CameraManager // Reference to CameraManager for zoom control

    // Flag to ensure components are initialized only once after size is known
    private var areComponentsInitialized = false

    /**
     * Initializes core drawing and interaction components.
     * This is called once the view dimensions are available.
     * @param cameraManager A reference to the CameraManager for camera zoom control.
     */
    fun initializeComponents(cameraManager: CameraManager) {
        Log.d(TAG, "initializeComponents called. areComponentsInitialized was $areComponentsInitialized, width=$width, height=$height")
        if (areComponentsInitialized || width == 0 || height == 0) return // Already initialized or no dimensions

        cameraManagerRef = cameraManager // Store reference

        gestureHandler = GestureHandler(
            context, appState, config, listener,
            onZoomChangedByGesture = { newZoomFactor ->
                setZoomFactorInternal(newZoomFactor, true)
            },
            onRotationChangedByGesture = { newRotationAngle ->
                setProtractorRotationAngleInternal(newRotationAngle, true)
            }
        )

        drawingCoordinator = DrawingCoordinator(
            appState, appPaints, config,
            viewWidthProvider = { width }, // Provide current view width
            viewHeightProvider = { height } // Provide current view height
        )

        // Initialize GestureDetector for tap events
        gestureDetector = GestureDetector(context, object : GestureDetector.SimpleOnGestureListener() {
            override fun onSingleTapUp(e: MotionEvent): Boolean {
                handleSingleTap(e.x, e.y) // Handle tap for ball selection
                return true
            }
        })

        areComponentsInitialized = true
        Log.d(TAG, "MainOverlayView components initialized. areComponentsInitialized is now $areComponentsInitialized")
    }


    /**
     * Applies Material 3 color scheme to the custom drawing paints.
     * This should be called after `onSizeChanged` or once view dimensions are set.
     *
     * @param colorScheme The Material 3 ColorScheme from Compose.
     */
    fun applyMaterialYouColors(colorScheme: ColorScheme) {
        // Ensure components are ready before applying colors.
        // If initializeComponents has not been called externally yet,
        // it cannot proceed here.
        if (!areComponentsInitialized) {
            Log.w(TAG, "applyMaterialYouColors called before components initialized. Skipping.")
            return
        }
        appPaints.applyMaterialYouColors(colorScheme)
        invalidate() // Redraw with new colors
    }

    /**
     * Called when the size of the view changes. Initializes or re-initializes
     * components that depend on view dimensions.
     */
    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        super.onSizeChanged(w, h, oldw, oldh)
        Log.d(TAG, "onSizeChanged: w=$w, h=$h. Calling appState.initialize.")
        if (w > 0 && h > 0) {
            // NOTE: initializeComponents must be called by MainActivity AFTER CameraManager is ready
            // because it now depends on cameraManagerRef.
            // We just ensure appState is initialized/updated with new dimensions here.
            appState.initialize(w, h)
            invalidate() // Request a redraw
        }
    }

    /**
     * The main drawing dispatch method. Calls the DrawingCoordinator to render elements.
     */
    override fun onDraw(canvas: Canvas) { // android.graphics.Canvas
        super.onDraw(canvas)
        Log.d(TAG, "onDraw called. areComponentsInitialized=$areComponentsInitialized, appState.isInitialized=${appState.isInitialized}, appState.currentLogicalRadius=${appState.currentLogicalRadius}, appState.currentMode=${appState.currentMode}")
        // Guard against drawing before components are ready
        if (!areComponentsInitialized || !appState.isInitialized) {
            Log.w(TAG, "onDraw returning early: areComponentsInitialized=$areComponentsInitialized, appState.isInitialized=${appState.isInitialized}")
            // Cannot call initializeComponents here as it requires cameraManagerRef now.
            // MainActivity is responsible for calling it.
            return
        }

        drawingCoordinator.onDraw(canvas)
    }

    /**
     * Handles touch events for gestures (pan, zoom, tap).
     */
    override fun onTouchEvent(event: MotionEvent): Boolean {
        // Guard against uninitialized state
        if (!areComponentsInitialized || !appState.isInitialized) return false

        // Pass touch events to GestureDetector first for tap detection
        val gestureHandled = gestureDetector.onTouchEvent(event)
        // Then pass to custom GestureHandler for pan/zoom.
        // Only allow pan/zoom gestures if in AIMING mode.
        val panZoomHandled = if (appState.currentMode == SelectionMode.AIMING) {
            gestureHandler.onTouchEvent(event)
        } else {
            false
        }


        // Consume event if either handler processed it, or fall back to super
        return gestureHandled || panZoomHandled || super.onTouchEvent(event)
    }

    // --- New methods for ball tracking integration ---

    /**
     * Receives a list of detected balls and camera frame dimensions from the CameraManager.
     * Updates AppState.trackedBalls and attempts to manage selected balls.
     *
     * @param balls The list of detected Ball objects (with coordinates in camera frame pixels).
     * @param frameWidth The width of the camera frame in pixels.
     * @param frameHeight The height of the camera frame in pixels.
     */
    fun updateTrackedBalls(balls: List<Ball>, frameWidth: Int, frameHeight: Int) {
        Log.d(TAG, "updateTrackedBalls received: balls.size=${balls.size}, frame=${frameWidth}x${frameHeight}")
        if (!appState.isInitialized || this.width == 0 || this.height == 0 || frameWidth == 0 || frameHeight == 0) {
            Log.w(TAG, "updateTrackedBalls: view/frame dimensions not ready or zero, skipping. View: ${this.width}x${this.height}, Frame: ${frameWidth}x${frameHeight}")
            // If frame dimensions are 0, this indicates a problem with the camera or analyzer.
            // Clear tracked balls to ensure no stale data causes issues.
            appState.trackedBalls = emptyList()
            // Invalidate to clear any previous drawings if current frame data is invalid.
            invalidate()
            return
        }

        // Calculate scaling factors to map camera frame coordinates to MainOverlayView coordinates
        val scaleX = this.width.toFloat() / frameWidth.toFloat()
        val scaleY = this.height.toFloat() / frameHeight.toFloat()
        // Use the smaller scale factor to ensure the entire camera frame fits within the view,
        // preventing parts of the image from being cropped. This creates a "letterbox" effect
        // if aspect ratios differ.
        val scaleFactor = min(scaleX, scaleY)

        // Calculate offsets to center the scaled camera frame content within the MainOverlayView
        val scaledFrameWidth = frameWidth * scaleFactor
        val scaledFrameHeight = frameHeight * scaleFactor
        val offsetX = (this.width - scaledFrameWidth) / 2f
        val offsetY = (this.height - scaledFrameHeight) / 2f

        val scaledBalls = balls.map { ball ->
            Ball(
                id = ball.id,
                x = ball.x * scaleFactor + offsetX,
                y = ball.y * scaleFactor + offsetY,
                radius = ball.radius * scaleFactor
            )
        }
        appState.trackedBalls = scaledBalls // Store the scaled balls
        Log.d(TAG, "updateTrackedBalls: Scaled ${scaledBalls.size} balls.")

        // Re-evaluate current selected balls based on the scaled, currently tracked balls.
        // This ensures selected balls are always represented by the latest scaled data
        // and deselected if they disappear from tracking.
        val currentSelectedCueBall = scaledBalls.firstOrNull { it.id == appState.selectedCueBallId }
        if (currentSelectedCueBall != null) {
            appState.updateSelectedCueBall(currentSelectedCueBall)
            Log.d(TAG, "updateTrackedBalls: Selected cue ball ${appState.selectedCueBallId} updated.")
        } else if (appState.selectedCueBallId != null) {
            // If previously selected cue ball is no longer tracked, deselect it
            appState.clearSelectedCueBall()
            listener?.onCueBallSelected(null)
            Log.d(TAG, "updateTrackedBalls: Previously selected cue ball disappeared, deselected.")
        }

        val currentSelectedTargetBall = scaledBalls.firstOrNull { it.id == appState.selectedTargetBallId }
        if (currentSelectedTargetBall != null) {
            appState.updateSelectedTargetBall(currentSelectedTargetBall)
            Log.d(TAG, "updateTrackedBalls: Selected target ball ${appState.selectedTargetBallId} updated.")
        } else if (appState.selectedTargetBallId != null) {
            // If previously selected target ball is no longer tracked, deselect it
            appState.clearSelectedTargetBall()
            listener?.onTargetBallSelected(null)
            Log.d(TAG, "updateTrackedBalls: Previously selected target ball disappeared, deselected.")
        }

        // Auto-select if currently in a selection mode and no ball is selected
        when (appState.currentMode) {
            SelectionMode.SELECTING_CUE_BALL -> {
                if (appState.selectedCueBallId == null) {
                    val firstBall = scaledBalls.firstOrNull()
                    if (firstBall != null) {
                        appState.updateSelectedCueBall(firstBall)
                        listener?.onCueBallSelected(firstBall.id)
                        Log.d(TAG, "Auto-selected cue ball: ${firstBall.id}")
                    } else {
                        Log.d(TAG, "No balls detected for auto-selection of cue ball.")
                    }
                }
            }
            SelectionMode.SELECTING_TARGET_BALL -> {
                if (appState.selectedTargetBallId == null) {
                    // Try to auto-select a target ball that isn't the cue ball
                    val firstNonCueBall = scaledBalls.firstOrNull { it.id != appState.selectedCueBallId }
                    if (firstNonCueBall != null) {
                        appState.updateSelectedTargetBall(firstNonCueBall)
                        listener?.onTargetBallSelected(firstNonCueBall.id)
                        Log.d(TAG, "Auto-selected target ball: ${firstNonCueBall.id}")
                    } else {
                        Log.d(TAG, "No non-cue balls detected for auto-selection of target ball.")
                    }
                }
            }
            else -> { /* In AIMING mode, no auto-selection */ }
        }

        invalidate() // Request a redraw to show updated positions
    }

    /**
     * Sets the camera's zoom capabilities in AppState.
     */
    fun updateCameraZoomCapabilities(minZoom: Float, maxZoom: Float) {
        appState.updateCameraZoomCapabilities(minZoom, maxZoom)
    }

    /**
     * Handles a single tap event on the overlay for ball selection.
     * @param tapX The X-coordinate of the tap in MainOverlayView pixels.
     * @param tapY The Y-coordinate of the tap in MainOverlayView pixels.
     */
    private fun handleSingleTap(tapX: Float, tapY: Float) {
        var closestBall: Ball? = null
        var minDistance = Float.MAX_VALUE

        for (ball in appState.trackedBalls) {
            val dist = hypot(tapX - ball.x, tapY - ball.y)
            if (dist <= ball.radius + 20f) { // Add 20 pixels tolerance for easier tapping
                if (dist < minDistance) {
                    minDistance = dist
                    closestBall = ball
                }
            }
        }

        val previousMode = appState.currentMode
        var modeChanged = false

        when (appState.currentMode) {
            SelectionMode.SELECTING_CUE_BALL -> {
                if (closestBall != null) {
                    appState.updateSelectedCueBall(closestBall)
                    appState.currentMode = SelectionMode.SELECTING_TARGET_BALL
                    listener?.onCueBallSelected(closestBall.id)
                    Log.d(TAG, "User selected cue ball: ${closestBall.id}. Mode changed to ${appState.currentMode}")
                    modeChanged = true
                } else {
                    Log.d(TAG, "Tap ignored: No ball found, expecting cue ball selection.")
                }
            }
            SelectionMode.SELECTING_TARGET_BALL -> {
                if (closestBall != null) {
                    if (closestBall.id == appState.selectedCueBallId) {
                        // Tapped on cue ball again while selecting target, reset everything
                        appState.clearSelectedCueBall()
                        appState.clearSelectedTargetBall()
                        appState.currentMode = SelectionMode.SELECTING_CUE_BALL
                        listener?.onCueBallSelected(null)
                        listener?.onTargetBallSelected(null)
                        Log.d(TAG, "User tapped cue ball again, resetting selection. Mode changed to ${appState.currentMode}")
                        modeChanged = true
                    } else {
                        // Tapped a different ball, select as target
                        appState.updateSelectedTargetBall(closestBall)
                        appState.currentMode = SelectionMode.AIMING
                        listener?.onTargetBallSelected(closestBall.id)
                        Log.d(TAG, "User selected target ball: ${closestBall.id}. Mode changed to ${appState.currentMode}")
                        modeChanged = true
                    }
                } else {
                    // Tapped empty space, deselect target (if any) and go back to selecting cue
                    if (appState.selectedTargetBallId != null) {
                        appState.clearSelectedTargetBall()
                        listener?.onTargetBallSelected(null)
                        Log.d(TAG, "User deselected target ball. Still expecting target selection.")
                        modeChanged = true // Mode changed back to selecting target.
                    } else {
                        Log.d(TAG, "Tap ignored: No ball found, expecting target ball selection.")
                    }
                }
            }
            SelectionMode.AIMING -> {
                if (closestBall != null) {
                    if (closestBall.id == appState.selectedCueBallId) {
                        // Tapped on cue ball, reset entire selection flow
                        appState.clearSelectedCueBall()
                        appState.clearSelectedTargetBall()
                        appState.currentMode = SelectionMode.SELECTING_CUE_BALL
                        listener?.onCueBallSelected(null)
                        listener?.onTargetBallSelected(null)
                        Log.d(TAG, "User tapped cue ball during aiming, resetting selection. Mode changed to ${appState.currentMode}")
                        modeChanged = true
                    } else if (closestBall.id == appState.selectedTargetBallId) {
                        // Tapped on current target ball, deselect it and go back to selecting target
                        appState.clearSelectedTargetBall()
                        appState.currentMode = SelectionMode.SELECTING_TARGET_BALL
                        listener?.onTargetBallSelected(null)
                        Log.d(TAG, "User deselected target ball. Mode changed to ${appState.currentMode}")
                        modeChanged = true
                    } else {
                        // Tapped a new ball, select as new target
                        appState.updateSelectedTargetBall(closestBall)
                        listener?.onTargetBallSelected(closestBall.id)
                        Log.d(TAG, "User selected new target ball: ${closestBall.id}.")
                        // Mode doesn't change from AIMING to AIMING
                    }
                } else {
                    // Tapped empty space, deselect target and go back to selecting target
                    if (appState.selectedTargetBallId != null) {
                        appState.clearSelectedTargetBall()
                        appState.currentMode = SelectionMode.SELECTING_TARGET_BALL
                        listener?.onTargetBallSelected(null)
                        Log.d(TAG, "User tapped empty space, deselected target ball. Mode changed to ${appState.currentMode}")
                        modeChanged = true
                    } else {
                        Log.d(TAG, "Tap ignored: No ball found, already in AIMING mode with no target selected.")
                    }
                }
            }
        }
        if (modeChanged) {
            listener?.onSelectionModeChanged(appState.currentMode)
        }
        listener?.onUserInteraction() // Always notify of user interaction
        invalidate() // Redraw after selection change
    }

    // --- Public API for controlling the view's state (now proxying to CameraManager for zoom) ---

    /**
     * Sets the camera zoom factor. This will be clamped by camera capabilities.
     * @param factor The desired zoom factor (e.g., 1.0f for no optical zoom).
     */
    fun setZoomFactor(factor: Float) {
        setZoomFactorInternal(factor, false)
    }

    /**
     * Internal method to set the camera zoom factor, with a flag for user-initiated changes.
     */
    private fun setZoomFactorInternal(factor: Float, isUserInitiatedInView: Boolean) {
        if (!areComponentsInitialized || !appState.isInitialized) return

        // Update AppState's zoomFactor (which now represents camera zoom ratio)
        if (appState.updateZoomFactor(factor)) {
            // Apply the new zoom ratio to the CameraX camera
            if (::cameraManagerRef.isInitialized) {
                cameraManagerRef.setCameraZoomRatio(appState.zoomFactor)
            }
            if (isUserInitiatedInView) {
                listener?.onZoomChanged(appState.zoomFactor)
                listener?.onUserInteraction()
            } else {
                listener?.onZoomChanged(appState.zoomFactor)
            }
            invalidate() // Request a redraw
        }
    }

    /**
     * Gets the current camera zoom factor.
     * @return The current camera zoom factor.
     */
    fun getZoomFactor(): Float = if (appState.isInitialized) appState.zoomFactor else 1.0f

    /**
     * Gets the minimum supported camera zoom factor.
     */
    fun getMinCameraZoomFactor(): Float = if (appState.isInitialized) appState.minCameraZoomRatio else 1.0f

    /**
     * Gets the maximum supported camera zoom factor.
     */
    fun getMaxCameraZoomFactor(): Float = if (appState.isInitialized) appState.maxCameraZoomRatio else 1.0f


    /**
     * Sets the rotation angle of the protractor overlay.
     * @param angle The desired rotation angle in degrees.
     */
    fun setProtractorRotationAngle(angle: Float) {
        setProtractorRotationAngleInternal(angle, false)
    }

    /**
     * Internal method to set the rotation angle, with a flag for user-initiated changes.
     */
    private fun setProtractorRotationAngleInternal(angle: Float, isUserInitiatedInView: Boolean) {
        if (!areComponentsInitialized || !appState.isInitialized) return

        if (appState.updateProtractorRotationAngle(angle)) {
            if (isUserInitiatedInView) {
                listener?.onRotationChanged(appState.protractorRotationAngle)
                listener?.onUserInteraction()
            } else {
                listener?.onRotationChanged(appState.protractorRotationAngle)
            }
            invalidate()
        }
    }

    /**
     * Gets the current rotation angle of the protractor overlay.
     * @return The current rotation angle in degrees.
     */
    fun getProtractorRotationAngle(): Float = if (appState.isInitialized) appState.protractorRotationAngle else config.DEFAULT_ROTATION_ANGLE

    /**
     * Sets the device pitch angle. This influences the 3D projection of the protractor.
     * @param rawPitchAngle The raw pitch angle from the device sensor.
     */
    fun setDevicePitchAngle(rawPitchAngle: Float) {
        if (!areComponentsInitialized || !appState.isInitialized) return

        if (appState.updateDevicePitchAngle(rawPitchAngle)) {
            invalidate() // Request redraw if pitch changed significantly
        }
    }

    /**
     * Gets the current effective pitch angle.
     * @return The current pitch angle in degrees.
     */
    fun getCurrentPitchAngle(): Float = if (appState.isInitialized) appState.currentPitchAngle else 0.0f

    /**
     * Gets the current center point of the protractor's target circle in view coordinates.
     * @return A PointF representing the target circle's center.
     */
    fun getPlaneTargetCenter(): PointF = if (appState.isInitialized) PointF(appState.targetCircleCenter.x, appState.targetCircleCenter.y) else PointF()

    /**
     * Resets all user interactions (zoom, rotation) and ball selections to defaults.
     */
    fun resetInteractionsToDefaults() {
        if (!areComponentsInitialized || !appState.isInitialized) {
            // If not initialized, try to initialize it now (e.g., if reset is pressed very early)
            if (width > 0 && height > 0 && ::cameraManagerRef.isInitialized) {
                initializeComponents(cameraManagerRef) // Re-initialize with known cameraManagerRef
                appState.initialize(width, height)
            } else {
                return // Cannot reset if not sized and CameraManager not ready
            }
        }

        appState.resetInteractions() // Reset AppState's interaction properties
        appPaints.resetDynamicPaintProperties() // Reset any dynamic paint states (e.g., error colors, glows)

        // Ensure camera zoom is reset to default (1.0f)
        if (::cameraManagerRef.isInitialized) {
            cameraManagerRef.setCameraZoomRatio(1.0f)
        }

        // Notify listeners of the reset state
        listener?.onZoomChanged(appState.zoomFactor)
        listener?.onRotationChanged(appState.protractorRotationAngle)
        listener?.onCueBallSelected(appState.selectedCueBallId)
        listener?.onTargetBallSelected(appState.selectedTargetBallId) // Notify about deselection
        listener?.onSelectionModeChanged(appState.currentMode)
        listener?.onUserInteraction()
        invalidate()
    }

    /**
     * Toggles the visibility of helper text labels on the overlay.
     */
    fun toggleHelperTextVisibility() {
        if (!areComponentsInitialized || !appState.isInitialized) return

        appState.toggleHelperTextVisibility()
        listener?.onUserInteraction() // Mark as user interaction for UI updates
        invalidate()
    }

    /**
     * Gets the current visibility state of helper texts.
     * @return True if helper texts are visible, false otherwise.
     */
    fun getAreHelperTextsVisible(): Boolean = if (appState.isInitialized) appState.areHelperTextsVisible else true

    /**
     * Gets the current selection mode.
     */
    fun getSelectionMode(): SelectionMode = if (appState.isInitialized) appState.currentMode else SelectionMode.SELECTING_CUE_BALL
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\geometry\models\ProjectedCoords.kt
================================================================================
package com.hereliesaz.cuedetat.geometry.models

import android.graphics.PointF

data class ProjectedCoords(
    val targetProjected: PointF,
    val cueProjected: PointF,
    val targetScreenRadius: Float,
    val cueScreenRadius: Float
)


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\geometry\models\AimingLineLogicalCoords.kt
================================================================================
package com.hereliesaz.cuedetat.geometry.models

import android.graphics.PointF // Not strictly needed here but good for consistency

data class AimingLineLogicalCoords(
    val startX: Float, val startY: Float, // This is the *actual* cue ball's projected screen position
    val cueX: Float, val cueY: Float,     // This is the *ghost* cue ball's logical position
    val endX: Float, val endY: Float,     // Extended end of the line
    val normDirX: Float, val normDirY: Float
)


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\geometry\models\DeflectionLineParams.kt
================================================================================
package com.hereliesaz.cuedetat.geometry.models

data class DeflectionLineParams(
    val cueToTargetDistance: Float,
    val unitPerpendicularX: Float, // Unit vector component
    val unitPerpendicularY: Float, // Unit vector component
    val visualDrawLength: Float
)


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\geometry\GeometryCalculator.kt
================================================================================


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\plane\elements\CueCircleDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.plane.elements

import android.graphics.Canvas
import androidx.compose.ui.graphics.toArgb
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.ui.theme.AppBlack
import com.hereliesaz.cuedetat.ui.theme.AppWhite

class CueCircleDrawer {
    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints,
        useErrorColor: Boolean
    ) {
        // Draw the *logical* cue ball (ghost ball on the plane)
        if (!appState.isInitialized || appState.currentLogicalRadius <= 0.01f) return

        val centerX = appState.cueCircleCenter.x
        val centerY = appState.cueCircleCenter.y
        val radius = appState.currentLogicalRadius
        val centerMarkRadius = radius / 5f

        appPaints.cueCirclePaint.color = if (useErrorColor) {
            appPaints.M3_COLOR_ERROR
        } else {
            AppWhite.toArgb()
        }
        canvas.drawCircle(centerX, centerY, radius, appPaints.cueCirclePaint)

        val originalCenterMarkPaintColor = appPaints.centerMarkPaint.color
        appPaints.centerMarkPaint.color = if (useErrorColor) {
            AppWhite.toArgb()
        } else {
            AppBlack.toArgb()
        }
        canvas.drawCircle(centerX, centerY, centerMarkRadius, appPaints.centerMarkPaint)
        appPaints.centerMarkPaint.color = originalCenterMarkPaintColor
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\plane\elements\TargetCircleDrawer.kt
================================================================================
// app/src/main/java/com/hereliesaz/cuedetat/drawing/plane/elements/TargetCircleDrawer.kt
package com.hereliesaz.cuedetat.drawing.plane.elements

import android.graphics.Canvas
import androidx.compose.ui.graphics.toArgb
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.ui.theme.AppBlack
import com.hereliesaz.cuedetat.ui.theme.AppYellow

class TargetCircleDrawer {
    /**
     * Draws the main target circle on the protractor plane.
     * The position and radius are sourced from `AppState`, which reflects the tracked ball.
     *
     * @param canvas The canvas to draw on.
     * @param appState The current state of the application.
     * @param appPaints The collection of paints used for drawing.
     */
    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints
    ) {
        // Only draw if initialized and radius is meaningful
        if (!appState.isInitialized || appState.currentLogicalRadius <= 0.01f) return

        val centerX = appState.targetCircleCenter.x
        val centerY = appState.targetCircleCenter.y
        val radius = appState.currentLogicalRadius // Use the dynamically calculated currentLogicalRadius
        val centerMarkRadius = radius / 5f // Center mark is 1/5th of the main circle radius

        // Draw the target circle outline (typically yellow)
        appPaints.targetCirclePaint.color = AppYellow.toArgb()
        canvas.drawCircle(centerX, centerY, radius, appPaints.targetCirclePaint)

        // Draw the center mark for the target circle (typically black)
        val originalCenterMarkPaintColor = appPaints.centerMarkPaint.color // Save original color
        appPaints.centerMarkPaint.color = AppBlack.toArgb() // Set to black for target's center mark
        canvas.drawCircle(centerX, centerY, centerMarkRadius, appPaints.centerMarkPaint)
        appPaints.centerMarkPaint.color = originalCenterMarkPaintColor // Restore original color
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\plane\elements\ProtractorAnglesDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.plane.elements

import android.graphics.Canvas
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import kotlin.math.cos
import kotlin.math.max
import kotlin.math.sin

class ProtractorAnglesDrawer(
    private val viewWidthProvider: () -> Int,
    private val viewHeightProvider: () -> Int
) {
    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints,
        config: AppConfig
    ) {
        if (!appState.isInitialized) return

        canvas.save()
        canvas.translate(appState.targetCircleCenter.x, appState.targetCircleCenter.y)
        canvas.rotate(appState.protractorRotationAngle)

        val lineLength = max(viewWidthProvider(), viewHeightProvider()) * 2f

        config.PROTRACTOR_ANGLES.forEach { angle ->
            val rad = Math.toRadians(angle.toDouble())
            val endX = (lineLength * sin(rad)).toFloat()
            val endY = -(lineLength * cos(rad)).toFloat()

            if (angle == 0f) {
                // This draws the main axis line of the protractor, now using targetLineGuidePaint
                canvas.drawLine(0f, 0f, endX, endY, appPaints.targetLineGuidePaint) // Main axis line (yellow)
                canvas.drawLine(0f, 0f, -endX, -endY, appPaints.protractorAngleLinePaint) // Opposite side
            } else {
                canvas.drawLine(0f, 0f, endX, endY, appPaints.protractorAngleLinePaint)
                canvas.drawLine(0f, 0f, -endX, -endY, appPaints.protractorAngleLinePaint)

                val negRad = Math.toRadians(-angle.toDouble())
                val negEndX = (lineLength * sin(negRad)).toFloat()
                val negEndY = -(lineLength * cos(negRad)).toFloat()
                canvas.drawLine(0f, 0f, negEndX, negEndY, appPaints.protractorAngleLinePaint)
                canvas.drawLine(0f, 0f, -negEndX, -negEndY, appPaints.protractorAngleLinePaint)
            }
        }
        canvas.restore()
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\plane\elements\DeflectionLinesDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.plane.elements

import android.graphics.Canvas
import androidx.compose.ui.graphics.toArgb
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.geometry.models.DeflectionLineParams
import com.hereliesaz.cuedetat.ui.theme.AppWhite

class DeflectionLinesDrawer {
    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints,
        deflectionParams: DeflectionLineParams,
        useErrorColor: Boolean
    ) {
        if (!appState.isInitialized || deflectionParams.cueToTargetDistance <= 0.001f) {
            return
        }

        val cueCenterX = appState.cueCircleCenter.x
        val cueCenterY = appState.cueCircleCenter.y
        // deflectionParams.unitPerpendicularX/Y is the "positive" direction (e.g., right of cue-to-target)
        val unitVecXPositive = deflectionParams.unitPerpendicularX
        val unitVecYPositive = deflectionParams.unitPerpendicularY
        val drawLength = deflectionParams.visualDrawLength

        // Ensure base color is white and solid paint has no glow before applying logic
        appPaints.deflectionDottedPaint.color = AppWhite.toArgb()
        appPaints.deflectionSolidPaint.color = AppWhite.toArgb()
        appPaints.deflectionSolidPaint.clearShadowLayer()

        var paintForPositiveDir = appPaints.deflectionDottedPaint
        var paintForNegativeDir = appPaints.deflectionDottedPaint

        if (useErrorColor) {
            val errorColor = appPaints.M3_COLOR_ERROR
            appPaints.deflectionDottedPaint.color = errorColor // Use this for both if error
            paintForPositiveDir = appPaints.deflectionDottedPaint
            paintForNegativeDir = appPaints.deflectionDottedPaint
            // Ensure solid paint is also error colored, though not directly used for line style
            appPaints.deflectionSolidPaint.color = errorColor
        } else {
            // Apply glow to solid paint for non-error state
            appPaints.deflectionSolidPaint.setShadowLayer(
                appState.config.GLOW_RADIUS_FIXED, 0f, 0f, appPaints.M3_GLOW_COLOR
            )
            // Ensure colors are white after potential error state in previous frame
            appPaints.deflectionDottedPaint.color = AppWhite.toArgb()
            appPaints.deflectionSolidPaint.color = AppWhite.toArgb()

            val alphaDeg = appState.protractorRotationAngle
            val epsilon = 0.5f

            // This logic determines if the "positive" deflection vector (unitVecXPositive, unitVecYPositive)
            // should get the solid line treatment.
            // Original logic was:
            // if (alphaDeg > epsilon && alphaDeg < (180f - epsilon)) -> paintForDir2 (negative vector) was solid.
            // else if (alphaDeg > (180f + epsilon) && alphaDeg < (360f - epsilon)) -> paintForDir1 (positive vector) was solid.

            if (alphaDeg > epsilon && alphaDeg < (180f - epsilon)) {
                // Protractor points "left-ish" on unit circle; negative deflection vector is "more aligned" / solid
                paintForNegativeDir = appPaints.deflectionSolidPaint
                paintForPositiveDir = appPaints.deflectionDottedPaint
            } else if (alphaDeg > (180f + epsilon) && alphaDeg < (360f - epsilon)) {
                // Protractor points "right-ish" on unit circle; positive deflection vector is "more aligned" / solid
                paintForPositiveDir = appPaints.deflectionSolidPaint
                paintForNegativeDir = appPaints.deflectionDottedPaint
            } else {
                // Default (near 0, 180, 360): make the positive deflection vector solid.
                paintForPositiveDir = appPaints.deflectionSolidPaint
                paintForNegativeDir = appPaints.deflectionDottedPaint
            }
        }

        // Line along positive deflection vector: (+unitVecXPositive, +unitVecYPositive)
        canvas.drawLine(
            cueCenterX, cueCenterY,
            cueCenterX + unitVecXPositive * drawLength,
            cueCenterY + unitVecYPositive * drawLength,
            paintForPositiveDir
        )
        // Line along negative deflection vector: (-unitVecXPositive, -unitVecYPositive)
        canvas.drawLine(
            cueCenterX, cueCenterY,
            cueCenterX - unitVecXPositive * drawLength,
            cueCenterY - unitVecYPositive * drawLength,
            paintForNegativeDir
        )
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\plane\elements\ShotGuideLineDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.plane.elements

import android.graphics.Canvas
import android.graphics.PointF // Import PointF
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.geometry.models.AimingLineLogicalCoords

class ShotGuideLineDrawer {
    fun draw(
        canvas: Canvas,
        appPaints: AppPaints,
        aimingLineCoords: AimingLineLogicalCoords,
        actualCueBallScreenCenter: PointF? // New parameter for actual cue ball screen position
    ) {
        val startX: Float
        val startY: Float

        if (actualCueBallScreenCenter != null) {
            // If actual cue ball is selected, the line starts from its screen position.
            startX = actualCueBallScreenCenter.x
            startY = actualCueBallScreenCenter.y
        } else {
            // Fallback: If no actual cue ball selected, start from the logical starting point
            // from the calculator (which used to be screen bottom, now still that if no actual cue selected)
            startX = aimingLineCoords.startX
            startY = aimingLineCoords.startY
        }

        val cueX = aimingLineCoords.cueX
        val cueY = aimingLineCoords.cueY
        val endX = aimingLineCoords.endX
        val endY = aimingLineCoords.endY

        val hasNearSegment = (startX != cueX || startY != cueY)

        if (!hasNearSegment && aimingLineCoords.normDirX == 0f && aimingLineCoords.normDirY == 0f) {
            return
        }

        // Draw the near segment of the shot guide (from actual cue ball to ghost cue ball)
        if (hasNearSegment || (aimingLineCoords.normDirX == 0f && aimingLineCoords.normDirY == 0f)) {
            canvas.drawLine(startX, startY, cueX, cueY, appPaints.shotGuideNearPaint)
        }

        // Draw the far segment of the shot guide (from ghost cue ball extended)
        if (aimingLineCoords.normDirX != 0f || aimingLineCoords.normDirY != 0f) {
            canvas.drawLine(cueX, cueY, endX, endY, appPaints.shotGuideFarPaint)
        }
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\plane\elements\FollowDrawPathsDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.plane.elements

import android.graphics.Canvas
import android.graphics.Path
import android.graphics.Paint
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.state.AppPaints
import kotlin.math.cos
import kotlin.math.sin

class FollowDrawPathsDrawer {

    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints,
        config: AppConfig,
        basePathLength: Float,          // Base length for these paths
        tangentLineAngleRad: Double    // Angle of the Tangent Line (solid deflection line)
    ) {
        if (!appState.isInitialized || basePathLength <= 0.01f) {
            return
        }

        val cueCenterX = appState.cueCircleCenter.x
        val cueCenterY = appState.cueCircleCenter.y

        val pathDrawActualLength = basePathLength * config.PATH_DRAW_LENGTH_FACTOR

        // --- Follow Path ---
        // Endpoint deviates from tangent by FOLLOW_EFFECT_DEVIATION_DEGREES
        val followDeviationRad = Math.toRadians(config.FOLLOW_EFFECT_DEVIATION_DEGREES.toDouble())
        val followEndAngle = tangentLineAngleRad + followDeviationRad // Apply deviation
        drawSingleCurve(
            canvas, cueCenterX, cueCenterY, pathDrawActualLength,
            tangentLineAngleRad,    // Starts tangent to this
            followEndAngle,         // Curves towards this end angle
            config.CURVE_CONTROL_POINT_FACTOR, // Use correct config constant
            appPaints.followPathPaint          // Use correct paint name
        )

        // --- Draw Path ---
        // Endpoint deviates from tangent by DRAW_EFFECT_DEVIATION_DEGREES
        val drawDeviationRad = Math.toRadians(config.DRAW_EFFECT_DEVIATION_DEGREES.toDouble())
        val drawEndAngle = tangentLineAngleRad + drawDeviationRad // Apply deviation
        drawSingleCurve(
            canvas, cueCenterX, cueCenterY, pathDrawActualLength,
            tangentLineAngleRad,    // Starts tangent to this
            drawEndAngle,           // Curves towards this end angle
            config.CURVE_CONTROL_POINT_FACTOR, // Use correct config constant
            appPaints.drawPathPaint            // Use correct paint name
        )
    }

    private fun drawSingleCurve(
        canvas: Canvas,
        startX: Float, startY: Float,           // P0
        pathLength: Float,
        startTangentAngleRad: Double,           // Initial tangent at P0
        endTargetAngleRad: Double,              // Angle the curve should be pointing at P2
        controlPointFactor: Float,              // Received from config
        paint: Paint
    ) {
        val path = Path()
        path.moveTo(startX, startY) // P0

        val endX = startX + (pathLength * cos(endTargetAngleRad)).toFloat() // P2.x
        val endY = startY + (pathLength * sin(endTargetAngleRad)).toFloat() // P2.y

        // P1: Control Point. Placed along the startTangentAngleRad.
        val controlDist = pathLength * controlPointFactor
        val controlX = startX + (controlDist * cos(startTangentAngleRad)).toFloat()
        val controlY = startY + (controlDist * sin(startTangentAngleRad)).toFloat()

        path.quadTo(controlX, controlY, endX, endY)
        canvas.drawPath(path, paint)
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\plane\labels\ProjectedShotTextDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.plane.labels

import android.graphics.Canvas
import android.graphics.PointF
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.drawing.utility.TextLayoutHelper
import com.hereliesaz.cuedetat.geometry.models.AimingLineLogicalCoords
import kotlin.math.atan2
import kotlin.math.cos
import kotlin.math.sin

class ProjectedShotTextDrawer(private val textLayoutHelper: TextLayoutHelper) {

    private val TEXT_STRING = "Projected Shot Line"

    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints,
        config: AppConfig,
        aimingLineCoords: AimingLineLogicalCoords
    ) {
        // Only draw if in AIMING mode and helper texts are visible
        if (!appState.isInitialized || !appState.areHelperTextsVisible || appState.currentMode != AppState.SelectionMode.AIMING) return
        if (aimingLineCoords.normDirX == 0f && aimingLineCoords.normDirY == 0f) return // No direction

        val paint = appPaints.projectedShotTextPaint
        paint.textSize = getPlaneSpaceTextSize( // Using a local/adapted version for plane labels
            config.PLANE_LABEL_BASE_SIZE,
            appState.zoomFactor,
            config,
            true, // isHelperLineLabel
            config.PROJECTED_SHOT_TEXT_SIZE_FACTOR
        )

        // The angle of the line segment from logical ghost cue to line end
        val angleRad = atan2(aimingLineCoords.normDirY, aimingLineCoords.normDirX)
        val rotationDegrees = Math.toDegrees(angleRad.toDouble()).toFloat()

        // Position text along the line, starting from the logical ghost cue ball
        val distanceFromGhostCueCenter = appState.currentLogicalRadius * 1.5f // Adjusted distance from ghost cue
        val preferredX = aimingLineCoords.cueX + aimingLineCoords.normDirX * distanceFromGhostCueCenter
        val preferredY = aimingLineCoords.cueY + aimingLineCoords.normDirY * distanceFromGhostCueCenter

        // Add a small perpendicular offset to tuck it alongside the line
        val perpendicularOffsetAmount = 20f / appState.zoomFactor.coerceAtLeast(0.5f)
        val perpOffsetX = sin(angleRad) * perpendicularOffsetAmount
        val perpOffsetY = -cos(angleRad) * perpendicularOffsetAmount

        val finalX = preferredX + perpOffsetX
        val finalY = preferredY + perpOffsetY

        // Nudge reference: center of the logical cue ball (ghost ball on plane)
        textLayoutHelper.layoutAndDrawText(
            canvas, TEXT_STRING, finalX, finalY, paint, rotationDegrees, appState.cueCircleCenter
        )
    }

    // Helper function for dynamic text sizing, adapted from old ProtractorPlaneTextDrawer
    private fun getPlaneSpaceTextSize(
        baseSize: Float, zoomFactor: Float, config: AppConfig,
        isHelperLineLabel: Boolean = false, sizeMultiplier: Float = 1f
    ): Float {
        val effectiveZoom = if (isHelperLineLabel) zoomFactor.coerceIn(0.7f, 1.3f) else zoomFactor
        return (baseSize * sizeMultiplier * effectiveZoom.coerceIn(config.TEXT_MIN_SCALE_FACTOR, config.TEXT_MAX_SCALE_FACTOR))
            .coerceAtLeast(baseSize * sizeMultiplier * config.TEXT_MIN_SCALE_FACTOR * 0.7f)
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\plane\labels\TangentLineTextDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.plane.labels

import android.graphics.Canvas
import android.graphics.PointF
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.drawing.utility.TextLayoutHelper
import com.hereliesaz.cuedetat.geometry.models.DeflectionLineParams
import kotlin.math.atan2
import kotlin.math.cos
import kotlin.math.sin

class TangentLineTextDrawer(private val textLayoutHelper: TextLayoutHelper) {

    private val TEXT_STRING = "Tangent Line"

    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints,
        config: AppConfig,
        deflectionParams: DeflectionLineParams
    ) {
        // Only draw if in AIMING mode and helper texts are visible
        if (!appState.isInitialized || !appState.areHelperTextsVisible || appState.currentMode != AppState.SelectionMode.AIMING) return
        if (deflectionParams.unitPerpendicularX == 0f && deflectionParams.unitPerpendicularY == 0f) return

        val paint = appPaints.tangentLineTextPaint // This is the AppPurple paint
        paint.textSize = getDynamicTextSizePPD(
            config.PLANE_LABEL_BASE_SIZE,
            appState.zoomFactor,
            config,
            true,
            config.TANGENT_LINE_TEXT_SIZE_FACTOR
        )

        val alphaDeg = appState.protractorRotationAngle
        val epsilon = 0.5f
        // isPositiveDeflectionVectorSolid means the line along (+unitPerpendicularX,Y) is drawn solid
        val isPositiveDeflectionVectorSolid = (alphaDeg > epsilon && alphaDeg < (180f - epsilon)) ||
                (alphaDeg <= epsilon || alphaDeg >= 360f - epsilon)

        val chosenVectorX: Float
        val chosenVectorY: Float

        if (isPositiveDeflectionVectorSolid) {
            chosenVectorX = deflectionParams.unitPerpendicularX
            chosenVectorY = deflectionParams.unitPerpendicularY
        } else {
            chosenVectorX = -deflectionParams.unitPerpendicularX
            chosenVectorY = -deflectionParams.unitPerpendicularY
        }

        val angleRad = atan2(chosenVectorY, chosenVectorX)
        val rotationDegrees = getReadableRotation(Math.toDegrees(angleRad.toDouble()).toFloat())
        val distance = appState.currentLogicalRadius * 3.4f // Keep consistent distance

        val preferredX = appState.cueCircleCenter.x + cos(angleRad) * distance
        val preferredY = appState.cueCircleCenter.y + sin(angleRad) * distance

        textLayoutHelper.layoutAndDrawText(
            canvas, TEXT_STRING, preferredX, preferredY, paint, rotationDegrees, appState.cueCircleCenter
        )
    }

    private fun getReadableRotation(degrees: Float): Float {
        var normalizedAngle = degrees % 360f
        if (normalizedAngle < 0) normalizedAngle += 360f
        return if (normalizedAngle > 90f && normalizedAngle < 270f) degrees + 180f else degrees
    }

    private fun getDynamicTextSizePPD(
        baseSize: Float, zoomFactor: Float, config: AppConfig,
        isHelperLineLabel: Boolean = false, sizeMultiplier: Float = 1f
    ): Float {
        val effectiveZoom = if (isHelperLineLabel) zoomFactor.coerceIn(0.7f, 1.3f) else zoomFactor
        return (baseSize * sizeMultiplier * effectiveZoom.coerceIn(config.TEXT_MIN_SCALE_FACTOR, config.TEXT_MAX_SCALE_FACTOR))
            .coerceAtLeast(baseSize * sizeMultiplier * config.TEXT_MIN_SCALE_FACTOR * 0.7f)
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\plane\labels\CueBallPathTextDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.plane.labels

import android.graphics.Canvas
import android.graphics.PointF
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.drawing.utility.TextLayoutHelper
import com.hereliesaz.cuedetat.geometry.models.DeflectionLineParams
import kotlin.math.atan2
import kotlin.math.cos
import kotlin.math.sin

class CueBallPathTextDrawer(private val textLayoutHelper: TextLayoutHelper) {

    private val TEXT_STRING = "Cue Ball Path"

    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints,
        config: AppConfig,
        deflectionParams: DeflectionLineParams
    ) {
        // Only draw if in AIMING mode and helper texts are visible
        if (!appState.isInitialized || !appState.areHelperTextsVisible || appState.currentMode != AppState.SelectionMode.AIMING) return
        if (deflectionParams.unitPerpendicularX == 0f && deflectionParams.unitPerpendicularY == 0f) return

        val paint = appPaints.cueBallPathTextPaint // This is the purple_200 paint
        paint.textSize = getDynamicTextSizePPD(
            config.PLANE_LABEL_BASE_SIZE,
            appState.zoomFactor,
            config,
            true,
            config.CUE_BALL_PATH_TEXT_SIZE_FACTOR
        )

        val alphaDeg = appState.protractorRotationAngle
        val epsilon = 0.5f
        val isPositiveDeflectionVectorSolid = (alphaDeg > epsilon && alphaDeg < (180f - epsilon)) ||
                (alphaDeg <= epsilon || alphaDeg >= 360f - epsilon)

        val chosenVectorX: Float
        val chosenVectorY: Float

        if (!isPositiveDeflectionVectorSolid) { // If positive is NOT solid, then it's dotted
            chosenVectorX = deflectionParams.unitPerpendicularX
            chosenVectorY = deflectionParams.unitPerpendicularY
        } else { // Positive is solid, so negative is dotted
            chosenVectorX = -deflectionParams.unitPerpendicularX
            chosenVectorY = -deflectionParams.unitPerpendicularY
        }

        val angleRad = atan2(chosenVectorY, chosenVectorX)
        // Cue Ball Path is intrinsically flipped, then made readable
        val rotationDegrees = getReadableRotation(Math.toDegrees(angleRad.toDouble()).toFloat() + 180f)
        val distance = appState.currentLogicalRadius * 3.4f

        val preferredX = appState.cueCircleCenter.x + cos(angleRad) * distance
        val preferredY = appState.cueCircleCenter.y + sin(angleRad) * distance

        textLayoutHelper.layoutAndDrawText(
            canvas, TEXT_STRING, preferredX, preferredY, paint, rotationDegrees, appState.cueCircleCenter
        )
    }

    private fun getReadableRotation(degrees: Float): Float {
        var normalizedAngle = degrees % 360f
        if (normalizedAngle < 0) normalizedAngle += 360f
        return if (normalizedAngle > 90f && normalizedAngle < 270f) degrees + 180f else degrees
    }

    private fun getDynamicTextSizePPD(
        baseSize: Float, zoomFactor: Float, config: AppConfig,
        isHelperLineLabel: Boolean = false, sizeMultiplier: Float = 1f
    ): Float {
        val effectiveZoom = if (isHelperLineLabel) zoomFactor.coerceIn(0.7f, 1.3f) else zoomFactor
        return (baseSize * sizeMultiplier * effectiveZoom.coerceIn(config.TEXT_MIN_SCALE_FACTOR, config.TEXT_MAX_SCALE_FACTOR))
            .coerceAtLeast(baseSize * sizeMultiplier * config.TEXT_MIN_SCALE_FACTOR * 0.7f)
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\plane\labels\PocketAimTextDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.plane.labels

import android.graphics.Canvas
import android.graphics.Paint
import android.graphics.PointF
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.drawing.utility.TextLayoutHelper

class PocketAimTextDrawer(private val textLayoutHelper: TextLayoutHelper) {

    private val TEXT_STRING = "Aim this at the pocket."

    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints,
        config: AppConfig
        // No need to pass canvas transforms here, PlaneRenderer handles the main one
    ) {
        // Only draw if in AIMING mode and helper texts are visible
        if (!appState.isInitialized || !appState.areHelperTextsVisible || appState.currentMode != AppState.SelectionMode.AIMING) return

        val paint = appPaints.pocketAimTextPaint // textAlign is CENTER
        paint.textSize = getDynamicTextSizePPD(
            config.PLANE_LABEL_BASE_SIZE,
            appState.zoomFactor,
            config,
            true,
            config.POCKET_AIM_TEXT_SIZE_FACTOR
        )

        // This drawing happens AFTER PlaneRenderer has done:
        // canvas.save()
        // canvas.translate(appState.targetCircleCenter.x, appState.targetCircleCenter.y)
        // canvas.rotate(appState.protractorRotationAngle)
        // ... and the Y-lift for plane texts

        // So, coordinates are relative to the targetCircleCenter, along the protractor's current 0-degree axis.
        val preferredX = 0f // Center of the text block should be on the protractor's 0-degree line
        val preferredY = -(appState.currentLogicalRadius + (35f / appState.zoomFactor.coerceAtLeast(0.5f))) // Slightly increased offset
        val rotationDegrees = 90f // Text itself is rotated 90 degrees to be perpendicular to the line

        // The nudge reference is (0,0) in this *local, already transformed* canvas space,
        // which corresponds to the targetCircleCenter in the original plane space.
        textLayoutHelper.layoutAndDrawText(
            canvas, TEXT_STRING, preferredX, preferredY, paint, rotationDegrees, PointF(0f, 0f)
        )
        // The restore for the main canvas transform is handled by PlaneRenderer
    }

    private fun getDynamicTextSizePPD(
        baseSize: Float, zoomFactor: Float, config: AppConfig,
        isHelperLineLabel: Boolean = false, sizeMultiplier: Float = 1f
    ): Float {
        val effectiveZoom = if (isHelperLineLabel) zoomFactor.coerceIn(0.7f, 1.3f) else zoomFactor
        return (baseSize * sizeMultiplier * effectiveZoom.coerceIn(config.TEXT_MIN_SCALE_FACTOR, config.TEXT_MAX_SCALE_FACTOR))
            .coerceAtLeast(baseSize * sizeMultiplier * config.TEXT_MIN_SCALE_FACTOR * 0.7f)
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\plane\PlaneRenderer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.plane

import android.graphics.Canvas
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.state.AppState.SelectionMode // Import SelectionMode
import com.hereliesaz.cuedetat.geometry.models.AimingLineLogicalCoords
import com.hereliesaz.cuedetat.geometry.models.DeflectionLineParams
import com.hereliesaz.cuedetat.drawing.plane.elements.* // Imports all element drawers
import com.hereliesaz.cuedetat.drawing.plane.labels.*   // Imports all label drawers
import com.hereliesaz.cuedetat.drawing.utility.TextLayoutHelper
import kotlin.math.atan2
import kotlin.math.abs
import android.graphics.PointF // Import PointF

class PlaneRenderer(
    private val textLayoutHelper: TextLayoutHelper,
    private val viewWidthProvider: () -> Int,
    private val viewHeightProvider: () -> Int
) {
    private val cueCircleDrawer = CueCircleDrawer()
    private val targetCircleDrawer = TargetCircleDrawer()
    private val protractorAnglesDrawer = ProtractorAnglesDrawer(viewWidthProvider, viewHeightProvider)
    private val deflectionLinesDrawer = DeflectionLinesDrawer()
    private val shotGuideLineDrawer = ShotGuideLineDrawer()
    private val followDrawPathsDrawer = FollowDrawPathsDrawer() // Using the correct drawer name

    private val projectedShotTextDrawer = ProjectedShotTextDrawer(textLayoutHelper)
    private val tangentLineTextDrawer = TangentLineTextDrawer(textLayoutHelper) // Label for the Tangent Line itself
    private val cueBallPathTextDrawer = CueBallPathTextDrawer(textLayoutHelper) // Label for the other (dotted) deflection line
    private val pocketAimTextDrawer = PocketAimTextDrawer(textLayoutHelper)


    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints,
        config: AppConfig,
        aimingLineCoords: AimingLineLogicalCoords,
        deflectionParams: DeflectionLineParams,
        useErrorColor: Boolean,
        actualCueBallScreenCenter: PointF? // New parameter
    ) {
        // Only draw protractor plane visuals if in AIMING mode
        if (appState.currentMode != SelectionMode.AIMING) return

        targetCircleDrawer.draw(canvas, appState, appPaints)
        cueCircleDrawer.draw(canvas, appState, appPaints, useErrorColor)
        protractorAnglesDrawer.draw(canvas, appState, appPaints, config)
        shotGuideLineDrawer.draw(canvas, appPaints, aimingLineCoords, actualCueBallScreenCenter) // Pass actual cue ball position

        val protractorAngle = appState.protractorRotationAngle
        val dxCueToTarget = appState.targetCircleCenter.x - appState.cueCircleCenter.x
        val dyCueToTarget = appState.targetCircleCenter.y - appState.cueCircleCenter.y
        val angleCueToTargetRad = atan2(dyCueToTarget.toDouble(), dxCueToTarget.toDouble())

        var angleToTargetDeg = Math.toDegrees(angleCueToTargetRad).toFloat()
        if (angleToTargetDeg < 0) angleToTargetDeg += 360f
        var effectiveProtractorAimDeg = (protractorAngle + 180f) % 360f
        if (effectiveProtractorAimDeg < 0) effectiveProtractorAimDeg += 360f
        var angleDiff = abs(effectiveProtractorAimDeg - angleToTargetDeg)
        if (angleDiff > 180) angleDiff = 360 - angleDiff
        val isStraightShot = angleDiff < 1.5f

        val showDeflectionAndFollowDrawLines = !isStraightShot &&
                deflectionParams.cueToTargetDistance > 0.1f &&
                !useErrorColor

        if (showDeflectionAndFollowDrawLines) {
            // This draws the main solid/dotted TANGENT lines
            deflectionLinesDrawer.draw(canvas, appState, appPaints, deflectionParams, false)

            // Determine the angle of the VISUALLY SOLID deflection line (this is the Tangent Line)
            val alphaDeg = appState.protractorRotationAngle
            val epsilon = 0.5f
            val isPositiveDeflectionVectorSolid = (alphaDeg > epsilon && alphaDeg < (180f - epsilon)) ||
                    (alphaDeg <= epsilon || alphaDeg >= 360f - epsilon)

            val tangentLineAngleRad: Double = if (isPositiveDeflectionVectorSolid) {
                atan2(deflectionParams.unitPerpendicularY.toDouble(), deflectionParams.unitPerpendicularX.toDouble())
            } else {
                atan2(-deflectionParams.unitPerpendicularY.toDouble(), -deflectionParams.unitPerpendicularX.toDouble())
            }

            val basePathLength = deflectionParams.visualDrawLength // Use this as base for scaling path length

            followDrawPathsDrawer.draw(
                canvas, appState, appPaints, config,
                basePathLength,
                tangentLineAngleRad
                // The FollowDrawPathsDrawer itself will use config values for specific deflection angles
            )
        }

        // Draw plane-specific helper texts only if in AIMING mode and helper texts are visible
        if (appState.areHelperTextsVisible) {
            canvas.save()
            val textPlaneYLift = -appState.currentLogicalRadius * 0.15f / appState.zoomFactor.coerceAtLeast(0.3f)
            canvas.translate(0f, textPlaneYLift)
            projectedShotTextDrawer.draw(canvas, appState, appPaints, config, aimingLineCoords)
            if (showDeflectionAndFollowDrawLines) { // Only show these labels if lines are visible
                tangentLineTextDrawer.draw(canvas, appState, appPaints, config, deflectionParams)
                cueBallPathTextDrawer.draw(canvas, appState, appPaints, config, deflectionParams)
            }
            pocketAimTextDrawer.draw(canvas, appState, appPaints, config)
            canvas.restore()
        }
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\screen\elements\GhostCueBallDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.screen.elements

import android.graphics.Canvas
import androidx.compose.ui.graphics.toArgb
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.ui.theme.AppWhite // Default color

class GhostCueBallDrawer {
    fun draw(
        canvas: Canvas,
        appPaints: AppPaints,
        centerX: Float,
        centerY: Float,
        radius: Float,
        showErrorStyle: Boolean
    ) {
        if (radius <= 0.01f) return

        // Ghost Cue Ball Outline
        appPaints.ghostCueOutlinePaint.color = if (showErrorStyle) {
            appPaints.M3_COLOR_ERROR
        } else {
            AppWhite.toArgb()
        }
        canvas.drawCircle(centerX, centerY, radius, appPaints.ghostCueOutlinePaint)

        // Aiming Sight (Yellow) on Ghost Cue Ball
        // Sight color is usually fixed (e.g., yellow), not affected by error state of cue ball outline
        appPaints.ghostCueAimingSightPaint.color = appPaints.targetCirclePaint.color // Match target circle color (AppYellow)
        val sightArmLength = radius * 0.6f
        canvas.drawLine(centerX - sightArmLength, centerY, centerX + sightArmLength, centerY, appPaints.ghostCueAimingSightPaint)
        canvas.drawLine(centerX, centerY - sightArmLength, centerX, centerY + sightArmLength, appPaints.ghostCueAimingSightPaint)
        canvas.drawCircle(centerX, centerY, sightArmLength * 0.15f, appPaints.ghostCueAimingSightPaint)
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\screen\elements\GhostTargetBallDrawer.kt
================================================================================
// app/src/main/java/com/hereliesaz/cuedetat/drawing/screen/elements/GhostTargetBallDrawer.kt
package com.hereliesaz.cuedetat.drawing.screen.elements

import android.graphics.Canvas
import androidx.compose.ui.graphics.toArgb
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.ui.theme.AppYellow // Target is always yellow

class GhostTargetBallDrawer {
    /**
     * Draws the "ghost" (projected) target ball. This is drawn in screen space
     * and represents the visual projection of the tracked target ball.
     *
     * @param canvas The canvas to draw on.
     * @param appPaints The collection of paints used for drawing.
     * @param centerX The X-coordinate of the ghost ball's center in screen pixels.
     * @param centerY The Y-coordinate of the ghost ball's center in screen pixels.
     * @param radius The radius of the ghost ball in screen pixels.
     */
    fun draw(
        canvas: Canvas,
        appPaints: AppPaints,
        centerX: Float,
        centerY: Float,
        radius: Float // This `radius` is already the projected screen radius, suitable for drawing.
    ) {
        if (radius <= 0.01f) return // Only draw if radius is meaningful

        // Ghost Target Ball Outline (Always yellow as per 8-ball aesthetic)
        appPaints.ghostTargetOutlinePaint.color = AppYellow.toArgb()
        canvas.drawCircle(centerX, centerY, radius, appPaints.ghostTargetOutlinePaint)

        // No aiming sight needed on the target ghost ball itself typically
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\screen\labels\InvalidShotWarningDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.screen.labels

import android.graphics.Canvas
import android.text.Layout
import android.text.StaticLayout
import android.text.TextPaint
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.drawing.utility.TextLayoutHelper // Received, but not used for drawing this specific text

class InvalidShotWarningDrawer(
    private val textLayoutHelper: TextLayoutHelper, // Kept for signature consistency, not used for drawing
    private val viewWidthProvider: () -> Int,
    private val viewHeightProvider: () -> Int
) {
    private val WARNING_TEXT_AREA_START_X_PADDING_LOCAL = 32f
    private val WARNING_TEXT_AREA_RIGHT_MARGIN_LOCAL = 190f
    private val WARNING_TEXT_VERTICAL_CENTER_TARGET_PERCENT = 0.45f

    fun draw(
        canvas: Canvas,
        appState: AppState, // For config access if needed, though font size is direct from AppConfig
        appPaints: AppPaints,
        config: AppConfig, // Pass AppConfig explicitly
        warningStringToDisplay: String?
    ) {
        // Only draw if in AIMING mode and a warning string is present
        if (appState.currentMode != AppState.SelectionMode.AIMING || warningStringToDisplay == null) return

        val screenWidth = viewWidthProvider()
        val screenHeight = viewHeightProvider()

        val warningPaint = TextPaint(appPaints.invalidShotWarningPaint)
        warningPaint.textSize = config.INVALID_SHOT_WARNING_BASE_SIZE // Directly from AppConfig
        // textAlign for StaticLayout internal alignment: ALIGN_OPPOSITE will make lines right-align in the block
        // The paint's textAlign (set to CENTER in AppPaints) is less relevant here.

        val staticLayoutMaxWidth = (screenWidth - WARNING_TEXT_AREA_START_X_PADDING_LOCAL - WARNING_TEXT_AREA_RIGHT_MARGIN_LOCAL).toInt().coerceAtLeast(1)

        val staticLayout = StaticLayout.Builder.obtain(
            warningStringToDisplay, 0, warningStringToDisplay.length,
            warningPaint, staticLayoutMaxWidth
        )
            .setAlignment(Layout.Alignment.ALIGN_OPPOSITE)
            .setLineSpacing(0f, 1.0f)
            .setIncludePad(false)
            .build()

        val textBlockActualWidth = staticLayout.width
        val textBlockHeight = staticLayout.height

        val textBlockX = screenWidth - textBlockActualWidth - WARNING_TEXT_AREA_RIGHT_MARGIN_LOCAL
        val verticalCenterTarget = screenHeight * WARNING_TEXT_VERTICAL_CENTER_TARGET_PERCENT
        val textBlockY = verticalCenterTarget - (textBlockHeight / 2f)

        canvas.save()
        canvas.translate(textBlockX.coerceAtLeast(0f), textBlockY.coerceAtLeast(0f))
        staticLayout.draw(canvas)
        canvas.restore()
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\screen\labels\GhostTargetNameDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.screen.labels

import android.graphics.Canvas
import android.graphics.PointF
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.drawing.utility.TextLayoutHelper

class GhostTargetNameDrawer(private val textLayoutHelper: TextLayoutHelper) {

    private val TEXT_STRING = "Target Ball"
    private val LABEL_OFFSET_FROM_BALL_TOP_DP = 2f
    private val LABEL_MIN_OFFSET_PIXELS = 1f

    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints,
        config: AppConfig,
        ghostCenter: PointF,
        ghostRadius: Float,
        verticalOffsetAdjustment: Float = 0f
    ) {
        // Only draw if in AIMING mode and helper texts are visible
        if (!appState.isInitialized || !appState.areHelperTextsVisible || appState.currentMode != AppState.SelectionMode.AIMING) return
        if (ghostRadius <= 0.01f) return

        val paint = appPaints.ghostTargetNamePaint // textAlign is CENTER
        paint.textSize = getScreenSpaceTextSize(
            config.GHOST_BALL_NAME_BASE_SIZE,
            appState.zoomFactor,
            config
        )

        val labelOffsetPixels = (LABEL_OFFSET_FROM_BALL_TOP_DP / appState.zoomFactor.coerceAtLeast(0.2f))
            .coerceAtLeast(LABEL_MIN_OFFSET_PIXELS)

        val fm = paint.fontMetrics
        val textBlockHeight = fm.descent - fm.ascent

        val topOfBallY = ghostCenter.y - ghostRadius

        // Calculate Y for the center of the text block.
        // The text block's bottom should be 'labelOffsetPixels' above the top of the ball,
        // then add the verticalOffsetAdjustment.
        val textVisualBottom = topOfBallY - labelOffsetPixels + verticalOffsetAdjustment
        val textVisualTop = textVisualBottom - textBlockHeight
        val preferredY_center = textVisualTop + textBlockHeight / 2f

        val preferredX = ghostCenter.x

        textLayoutHelper.layoutAndDrawText(
            canvas, TEXT_STRING, preferredX, preferredY_center, paint, 0f, ghostCenter
        )
    }

    private fun getScreenSpaceTextSize(
        baseSize: Float, zoomFactor: Float, config: AppConfig, sizeMultiplier: Float = 1f
    ): Float {
        val effectiveZoom = zoomFactor.coerceIn(0.7f, 1.3f)
        return (baseSize * sizeMultiplier * effectiveZoom.coerceIn(config.TEXT_MIN_SCALE_FACTOR, config.TEXT_MAX_SCALE_FACTOR))
            .coerceAtLeast(baseSize * sizeMultiplier * config.TEXT_MIN_SCALE_FACTOR * 0.8f)
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\screen\labels\GhostCueNameDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.screen.labels

import android.graphics.Canvas
import android.graphics.PointF
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.drawing.utility.TextLayoutHelper

class GhostCueNameDrawer(private val textLayoutHelper: TextLayoutHelper) {

    private val TEXT_STRING = "Ghost Ball"
    // This offset is from the TOP EDGE of the ball to the very BOTTOM of the text characters (descent).
    private val LABEL_OFFSET_FROM_BALL_TOP_DP = 0.5f // Extremely small offset
    private val LABEL_MIN_OFFSET_PIXELS = 0f       // Allow touching

    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints,
        config: AppConfig,
        ghostCenter: PointF,
        ghostRadius: Float,
        verticalOffsetAdjustment: Float = 0f // This will be ADDED to the calculated Y. Negative pushes up.
    ) {
        // Only draw if in AIMING mode and helper texts are visible
        if (!appState.isInitialized || !appState.areHelperTextsVisible || appState.currentMode != AppState.SelectionMode.AIMING) return
        if (ghostRadius <= 0.01f) return

        val paint = appPaints.ghostCueNamePaint // textAlign is CENTER
        paint.textSize = getScreenSpaceTextSize(
            config.GHOST_BALL_NAME_BASE_SIZE,
            appState.zoomFactor,
            config
        )

        val labelOffsetPixels = (LABEL_OFFSET_FROM_BALL_TOP_DP / appState.zoomFactor.coerceAtLeast(0.2f))
            .coerceAtLeast(LABEL_MIN_OFFSET_PIXELS)

        val fm = paint.fontMetrics
        val textBlockHeight = fm.descent - fm.ascent

        val topOfBallY = ghostCenter.y - ghostRadius

        // The text block's bottom should be 'labelOffsetPixels' above the top of the ball.
        // Then apply the verticalOffsetAdjustment.
        // The text block's bottom is at topOfBallY - labelOffsetPixels + verticalOffsetAdjustment
        val textVisualBottom = topOfBallY - labelOffsetPixels + verticalOffsetAdjustment
        val textVisualTop = textVisualBottom - textBlockHeight
        val preferredY_center = textVisualTop + textBlockHeight / 2f // Y for the center of the text block

        val preferredX = ghostCenter.x // For Align.CENTER, X is the center

        textLayoutHelper.layoutAndDrawText(
            canvas, TEXT_STRING, preferredX, preferredY_center, paint, 0f, ghostCenter
        )
    }

    private fun getScreenSpaceTextSize(
        baseSize: Float, zoomFactor: Float, config: AppConfig, sizeMultiplier: Float = 1f
    ): Float {
        val effectiveZoom = zoomFactor.coerceIn(0.7f, 1.3f)
        return (baseSize * sizeMultiplier * effectiveZoom.coerceIn(config.TEXT_MIN_SCALE_FACTOR, config.TEXT_MAX_SCALE_FACTOR))
            .coerceAtLeast(baseSize * sizeMultiplier * config.TEXT_MIN_SCALE_FACTOR * 0.8f)
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\screen\labels\FitTargetInstructionDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.screen.labels

import android.graphics.Canvas
import android.graphics.Paint
import android.graphics.PointF
import android.text.TextPaint
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.drawing.utility.TextLayoutHelper
import kotlin.math.max

class FitTargetInstructionDrawer(
    private val textLayoutHelper: TextLayoutHelper,
    private val viewWidthProvider: () -> Int
) {
    private val TEXT_LINE_1 = "Fit this to your"
    private val TEXT_LINE_2 = "target ball, IRL."
    private val COMBINED_TEXT by lazy { "$TEXT_LINE_1\n$TEXT_LINE_2" }

    // Constants for this specific drawer's layout needs
    private val FIT_TARGET_TEXT_RIGHT_CLEARANCE_MARGIN_DP = 190f // To clear slider
    private val MIN_FIT_TARGET_FONT_SIZE_SP = 20f // Min font size
    private val FIT_TARGET_TEXT_X_PADDING_FROM_CIRCLE_DP = 2f // Padding from circle


    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints,
        config: AppConfig,
        targetGhostCenter: PointF,
        targetGhostRadius: Float
    ) {
        // Only draw if in AIMING mode and helper texts are visible
        if (!appState.isInitialized || !appState.areHelperTextsVisible || appState.currentMode != AppState.SelectionMode.AIMING) return
        if (targetGhostRadius <= 0.01f) return

        val paint = TextPaint(appPaints.fitTargetInstructionPaint)
        val baseSize = config.GHOST_BALL_NAME_BASE_SIZE * config.FIT_TARGET_INSTRUCTION_BASE_SIZE_FACTOR
        var currentFontSize = getScreenSpaceTextSize(baseSize, appState.zoomFactor, config)
        paint.textSize = currentFontSize
        // paint.textAlign is LEFT from AppPaints

        val screenWidth = viewWidthProvider()
        val xPos = targetGhostCenter.x + targetGhostRadius +
                (FIT_TARGET_TEXT_X_PADDING_FROM_CIRCLE_DP / appState.zoomFactor.coerceAtLeast(0.5f))
        val maxTextWidth = screenWidth - xPos - FIT_TARGET_TEXT_RIGHT_CLEARANCE_MARGIN_DP

        if (maxTextWidth <= 0) return

        val widthLine1 = paint.measureText(TEXT_LINE_1)
        val widthLine2 = paint.measureText(TEXT_LINE_2)
        val longerPredefinedLineWidth = max(widthLine1, widthLine2)

        if (longerPredefinedLineWidth > maxTextWidth) {
            val scaleFactor = maxTextWidth / longerPredefinedLineWidth
            currentFontSize *= (scaleFactor * 0.98f)
            currentFontSize = currentFontSize.coerceIn(MIN_FIT_TARGET_FONT_SIZE_SP, baseSize * 1.1f)
            paint.textSize = currentFontSize
        }

        val fm = paint.fontMetrics
        val lineHeight = paint.fontSpacing
        val numLines = 2
        val blockHeight = (fm.descent - fm.ascent) * numLines + lineHeight * (numLines - 1)
        // For TextAlign.LEFT, the Y given to drawText is the baseline of the first line.
        // We want the whole block centered vertically on targetGhostCenter.y.
        // So, vertical center of block = targetGhostCenter.y
        // Top of block = targetGhostCenter.y - (blockHeight / 2f)
        // Baseline of first line = Top of block - fm.ascent
        val preferredY = targetGhostCenter.y - (blockHeight / 2f) - fm.ascent

        textLayoutHelper.layoutAndDrawText(
            canvas, COMBINED_TEXT, xPos, preferredY, paint, 0f, targetGhostCenter
        )
    }

    private fun getScreenSpaceTextSize(
        baseSize: Float, zoomFactor: Float, config: AppConfig, sizeMultiplier: Float = 1f
    ): Float {
        val effectiveZoom = zoomFactor.coerceIn(0.7f, 1.3f)
        return (baseSize * sizeMultiplier * effectiveZoom.coerceIn(config.TEXT_MIN_SCALE_FACTOR, config.TEXT_MAX_SCALE_FACTOR))
            .coerceAtLeast(baseSize * sizeMultiplier * config.TEXT_MIN_SCALE_FACTOR * 0.8f)
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\screen\labels\PlaceCueInstructionDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.screen.labels

import android.graphics.Canvas
import android.graphics.PointF
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.drawing.utility.TextLayoutHelper

class PlaceCueInstructionDrawer(
    private val textLayoutHelper: TextLayoutHelper,
    private val viewWidthProvider: () -> Int,
    private val viewHeightProvider: () -> Int
) {
    private val TEXT_STRING = "Center actual cue ball here,\nunder your phone."

    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints,
        config: AppConfig
    ) {
        // Only draw if in AIMING mode and helper texts are visible
        if (!appState.isInitialized || !appState.areHelperTextsVisible || appState.currentMode != AppState.SelectionMode.AIMING) return

        val paint = appPaints.placeCueInstructionPaint
        // This text is static size, not affected by appState.zoomFactor for its base size
        paint.textSize = config.GHOST_BALL_NAME_BASE_SIZE * config.PLACE_CUE_INSTRUCTION_BASE_SIZE_FACTOR
        // paint.textAlign is CENTER from AppPaints

        val preferredX = viewWidthProvider() / 2f
        // Positioned near bottom, moved up from old logic: e.g., 85% of screen height
        val preferredY = viewHeightProvider() * 0.85f // Y is the center of the text block

        // Nudge reference can be screen center or its own center
        val nudgeRef = PointF(preferredX, preferredY)

        textLayoutHelper.layoutAndDrawText(
            canvas, TEXT_STRING, preferredX, preferredY, paint, 0f, nudgeRef
        )
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\screen\labels\PanHintDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.screen.labels

import android.graphics.Canvas
import android.graphics.PointF
import com.hereliesaz.cuedetat.config.AppConfig

import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.drawing.utility.TextLayoutHelper

class PanHintDrawer(
    private val textLayoutHelper: TextLayoutHelper,
    private val viewWidthProvider: () -> Int,
    private val viewHeightProvider: () -> Int
) {
    private val TEXT_STRING = "Pan: Rotate"
    private val X_OFFSET_DP = 20f

    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints,
        config: AppConfig
    ) {
        // Only draw if in AIMING mode and helper texts are visible
        if (!appState.isInitialized || !appState.areHelperTextsVisible || appState.currentMode != AppState.SelectionMode.AIMING) return

        val paint = appPaints.panHintPaint
        paint.textSize = config.HINT_TEXT_BASE_SIZE * config.HINT_TEXT_SIZE_MULTIPLIER
        // paint.textAlign is LEFT from AppPaints

        val yBase = viewHeightProvider() - 20f // Bottom reference
        val preferredY = yBase - paint.fontSpacing // Y for baseline, above pinch hint

        // Nudge reference: a point near its typical location to keep nudging local
        val nudgeRef = PointF(X_OFFSET_DP + (paint.measureText(TEXT_STRING) / 2f), preferredY)

        textLayoutHelper.layoutAndDrawText(
            canvas, TEXT_STRING, X_OFFSET_DP, preferredY, paint, 0f, nudgeRef
        )
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\screen\labels\PinchHintDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.screen.labels

import android.graphics.Canvas
import android.graphics.PointF
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.drawing.utility.TextLayoutHelper

class PinchHintDrawer(
    private val textLayoutHelper: TextLayoutHelper,
    private val viewWidthProvider: () -> Int,
    private val viewHeightProvider: () -> Int
) {
    private val TEXT_STRING = "Pinch: Zoom"
    private val X_OFFSET_DP = 20f

    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints,
        config: AppConfig
    ) {
        // Only draw if in AIMING mode and helper texts are visible
        if (!appState.isInitialized || !appState.areHelperTextsVisible || appState.currentMode != AppState.SelectionMode.AIMING) return

        val paint = appPaints.pinchHintPaint
        paint.textSize = config.HINT_TEXT_BASE_SIZE * config.HINT_TEXT_SIZE_MULTIPLIER
        // paint.textAlign is LEFT from AppPaints

        val preferredY = viewHeightProvider() - 20f // Baseline near bottom

        val nudgeRef = PointF(X_OFFSET_DP + (paint.measureText(TEXT_STRING) / 2f), preferredY)
        textLayoutHelper.layoutAndDrawText(
            canvas, TEXT_STRING, X_OFFSET_DP, preferredY, paint, 0f, nudgeRef
        )
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\screen\labels\SelectionInstructionDrawer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.screen.labels

import android.graphics.Canvas
import android.graphics.Paint
import android.graphics.PointF
import android.text.Layout
import android.text.StaticLayout
import android.text.TextPaint
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.state.AppState.SelectionMode

class SelectionInstructionDrawer(
    private val viewWidthProvider: () -> Int,
    private val viewHeightProvider: () -> Int
) {
    private val PADDING_HORIZONTAL = 32f
    private val TEXT_AREA_TOP_PERCENT = 0.2f
    private val TEXT_AREA_BOTTOM_PERCENT = 0.8f

    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints,
        config: AppConfig
    ) {
        // Only draw if not in AIMING mode and helper texts are visible
        if (appState.currentMode == SelectionMode.AIMING || !appState.areHelperTextsVisible) return

        val instructionText = when (appState.currentMode) {
            SelectionMode.SELECTING_CUE_BALL -> "Tap the cue ball to select it."
            SelectionMode.SELECTING_TARGET_BALL -> "Now tap the target ball."
            else -> "" // Should not happen given the initial check
        }

        if (instructionText.isEmpty()) return

        val paint = TextPaint(appPaints.selectionInstructionPaint)
        paint.textSize = config.GHOST_BALL_NAME_BASE_SIZE * 1.1f // Slightly larger than ghost ball names
        paint.textAlign = Paint.Align.CENTER // Ensure text is centered by StaticLayout

        val screenWidth = viewWidthProvider()
        val screenHeight = viewHeightProvider()

        val horizontalPadding = PADDING_HORIZONTAL
        val maxWidth = (screenWidth - 2 * horizontalPadding).toInt().coerceAtLeast(1)

        val staticLayout = StaticLayout.Builder.obtain(
            instructionText, 0, instructionText.length,
            paint, maxWidth
        )
            .setAlignment(Layout.Alignment.ALIGN_CENTER)
            .setLineSpacing(0f, 1.0f)
            .setIncludePad(false)
            .build()

        val textBlockHeight = staticLayout.height

        // Calculate Y position to center the block vertically within a defined area
        val availableHeight = screenHeight * (TEXT_AREA_BOTTOM_PERCENT - TEXT_AREA_TOP_PERCENT)
        val areaTopY = screenHeight * TEXT_AREA_TOP_PERCENT
        val preferredY = areaTopY + (availableHeight / 2f) - (textBlockHeight / 2f)

        val drawX = (screenWidth / 2f) - (staticLayout.width / 2f) // Center horizontally

        canvas.save()
        canvas.translate(drawX.coerceAtLeast(0f), preferredY.coerceAtLeast(0f))
        staticLayout.draw(canvas)
        canvas.restore()
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\screen\ScreenRenderer.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.screen

import android.graphics.Canvas
import android.graphics.PointF
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.state.AppState.SelectionMode
import com.hereliesaz.cuedetat.drawing.utility.TextLayoutHelper
import com.hereliesaz.cuedetat.drawing.screen.elements.*
import com.hereliesaz.cuedetat.drawing.screen.labels.*
import kotlin.math.abs // For horizontal distance check

class ScreenRenderer(
    private val textLayoutHelper: TextLayoutHelper,
    private val viewWidthProvider: () -> Int,
    private val viewHeightProvider: () -> Int
) {
    private val ghostCueBallDrawer = GhostCueBallDrawer()
    private val ghostTargetBallDrawer = GhostTargetBallDrawer()

    private val invalidShotWarningDrawer = InvalidShotWarningDrawer(textLayoutHelper, viewWidthProvider, viewHeightProvider)
    private val ghostTargetNameDrawer = GhostTargetNameDrawer(textLayoutHelper)
    private val ghostCueNameDrawer = GhostCueNameDrawer(textLayoutHelper)
    private val fitTargetInstructionDrawer = FitTargetInstructionDrawer(textLayoutHelper, viewWidthProvider)
    private val placeCueInstructionDrawer = PlaceCueInstructionDrawer(textLayoutHelper, viewWidthProvider, viewHeightProvider)
    private val panHintDrawer = PanHintDrawer(textLayoutHelper, viewWidthProvider, viewHeightProvider)
    private val pinchHintDrawer = PinchHintDrawer(textLayoutHelper, viewWidthProvider, viewHeightProvider)

    private val selectionInstructionDrawer = SelectionInstructionDrawer(viewWidthProvider, viewHeightProvider) // New drawer

    // Threshold for horizontal proximity to trigger vertical offset adjustment
    private val GHOST_LABEL_HORIZONTAL_PROXIMITY_THRESHOLD_FACTOR = 1.5f // e.g., 1.5 * (sum of radii)
    private val GHOST_LABEL_VERTICAL_ADJUSTMENT_AMOUNT_DP = 10f // DP to adjust by

    fun draw(
        canvas: Canvas,
        appState: AppState,
        appPaints: AppPaints,
        config: AppConfig,
        projectedTargetGhostCenter: PointF,
        targetGhostRadius: Float,
        projectedCueGhostCenter: PointF,
        cueGhostRadius: Float,
        showErrorStyleForGhostBalls: Boolean,
        invalidShotWarningString: String?
    ) {
        if (!appState.isInitialized) return

        // 1. Draw Screen Space Visual Elements (Ghost Balls)
        // These are drawn regardless of mode, as they represent the projection of tracked balls.
        ghostTargetBallDrawer.draw(
            canvas, appPaints,
            projectedTargetGhostCenter.x, projectedTargetGhostCenter.y, targetGhostRadius
        )
        ghostCueBallDrawer.draw(
            canvas, appPaints,
            projectedCueGhostCenter.x, projectedCueGhostCenter.y, cueGhostRadius,
            showErrorStyleForGhostBalls
        )

        // 2. Draw Screen Space Text Labels
        // Warning text for invalid shots (only in AIMING mode)
        invalidShotWarningDrawer.draw(
            canvas, appState, appPaints, config, invalidShotWarningString
        )

        // Conditional drawing of instructions based on selection mode
        if (appState.areHelperTextsVisible) {
            selectionInstructionDrawer.draw(canvas, appState, appPaints, config)

            when (appState.currentMode) {
                SelectionMode.AIMING -> {
                    // Only draw aiming-related labels in AIMING mode
                    var targetLabelVerticalOffset = 0f
                    var cueLabelVerticalOffset = 0f

                    // Simple overlap avoidance for ghost ball labels
                    if (targetGhostRadius > 0 && cueGhostRadius > 0) {
                        val horizontalDistance = abs(projectedTargetGhostCenter.x - projectedCueGhostCenter.x)
                        val proximityThreshold = (targetGhostRadius + cueGhostRadius) * GHOST_LABEL_HORIZONTAL_PROXIMITY_THRESHOLD_FACTOR

                        if (horizontalDistance < proximityThreshold) {
                            val adjustmentPixels = (GHOST_LABEL_VERTICAL_ADJUSTMENT_AMOUNT_DP / appState.zoomFactor.coerceAtLeast(0.3f))
                            cueLabelVerticalOffset = -adjustmentPixels
                            targetLabelVerticalOffset = adjustmentPixels / 2f
                        }
                    }

                    ghostTargetNameDrawer.draw(
                        canvas, appState, appPaints, config,
                        projectedTargetGhostCenter, targetGhostRadius,
                        targetLabelVerticalOffset
                    )
                    ghostCueNameDrawer.draw(
                        canvas, appState, appPaints, config,
                        projectedCueGhostCenter, cueGhostRadius,
                        cueLabelVerticalOffset
                    )
                    fitTargetInstructionDrawer.draw(
                        canvas, appState, appPaints, config,
                        projectedTargetGhostCenter, targetGhostRadius
                    )
                    placeCueInstructionDrawer.draw(canvas, appState, appPaints, config)
                    panHintDrawer.draw(canvas, appState, appPaints, config)
                    pinchHintDrawer.draw(canvas, appState, appPaints, config)
                }
                SelectionMode.SELECTING_CUE_BALL, SelectionMode.SELECTING_TARGET_BALL -> {
                    // No other labels are drawn during selection modes, only the instruction text
                }
            }
        }
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\utility\TextLayoutHelper.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.utility

import android.graphics.Canvas
import android.graphics.Paint
import android.graphics.PointF
import android.graphics.RectF
import kotlin.math.max
import kotlin.math.sqrt

class TextLayoutHelper(
    private val viewWidthProvider: () -> Int,
    private val viewHeightProvider: () -> Int
) {
    private val drawnTextBoundsThisFrame = mutableListOf<RectF>()
    private val MAX_NUDGE_ATTEMPTS = 5
    private val NUDGE_DISTANCE_STEP = 20.0f

    fun prepareForNewFrame() {
        drawnTextBoundsThisFrame.clear()
    }

    private fun calculateTextBounds(
        text: String,
        currentX: Float,
        currentY: Float,
        paint: Paint,
        rotationDegrees: Float
    ): RectF {
        val lines = text.split('\n')
        val textMetrics = paint.fontMetrics
        val singleLineHeight = textMetrics.descent - textMetrics.ascent
        val totalTextHeight = if (lines.size > 1) {
            (singleLineHeight * lines.size) + (paint.fontSpacing - singleLineHeight) * (lines.size - 1)
        } else {
            singleLineHeight
        }
        val maxLineWidth = lines.maxOfOrNull { paint.measureText(it) } ?: 0f

        if (rotationDegrees == 0f) {
            var top: Float
            var bottom: Float
            var left: Float
            var right: Float

            when (paint.textAlign) {
                Paint.Align.CENTER -> {
                    val blockTopY = currentY - totalTextHeight / 2f
                    top = blockTopY
                    bottom = blockTopY + totalTextHeight
                    left = currentX - maxLineWidth / 2f
                    right = currentX + maxLineWidth / 2f
                }
                Paint.Align.LEFT -> {
                    top = currentY + textMetrics.ascent
                    bottom = currentY + (totalTextHeight - singleLineHeight) + textMetrics.descent
                    left = currentX
                    right = currentX + maxLineWidth
                }
                Paint.Align.RIGHT -> {
                    top = currentY + textMetrics.ascent
                    bottom = currentY + (totalTextHeight - singleLineHeight) + textMetrics.descent
                    left = currentX - maxLineWidth
                    right = currentX
                }
                else -> {
                    top = currentY; bottom = currentY; left = currentX; right = currentX
                }
            }
            return RectF(left, top, right, bottom)
        } else {
            val maxDim = max(maxLineWidth, totalTextHeight) * 1.5f
            return RectF(currentX - maxDim / 2, currentY - maxDim / 2, currentX + maxDim / 2, currentY + maxDim / 2)
        }
    }

    private fun drawTextAtPosition(
        canvas: Canvas,
        text: String,
        x: Float,
        y: Float,
        paint: Paint,
        rotationDegrees: Float
    ) {
        val lines = text.split('\n')
        val textMetrics = paint.fontMetrics
        val singleLineHeight = textMetrics.descent - textMetrics.ascent
        val totalTextHeight = if (lines.size > 1) {
            (singleLineHeight * lines.size) + (paint.fontSpacing - singleLineHeight) * (lines.size - 1)
        } else {
            singleLineHeight
        }

        if (rotationDegrees != 0f) {
            canvas.save()
            canvas.translate(x, y)
            canvas.rotate(rotationDegrees)
            var lineOffsetY = -(totalTextHeight / 2f) - textMetrics.ascent
            lines.forEach { line ->
                val drawX = when (paint.textAlign) {
                    Paint.Align.CENTER -> -paint.measureText(line) / 2f
                    Paint.Align.LEFT -> 0f
                    Paint.Align.RIGHT -> -paint.measureText(line)
                    else -> 0f
                }
                canvas.drawText(line, drawX, lineOffsetY, paint)
                lineOffsetY += paint.fontSpacing
            }
            canvas.restore()
        } else {
            var currentYBaseline = y
            if (paint.textAlign == Paint.Align.CENTER && lines.size > 1) {
                currentYBaseline = y - (totalTextHeight / 2f) - textMetrics.ascent
            } else if (paint.textAlign == Paint.Align.CENTER && lines.size == 1) {
                currentYBaseline = y - (textMetrics.ascent + textMetrics.descent) / 2f
            }
            lines.forEachIndexed { index, line ->
                val actualDrawY = if (index == 0) currentYBaseline else currentYBaseline + (index * paint.fontSpacing)
                canvas.drawText(line, x, actualDrawY, paint)
            }
        }
    }

    fun layoutAndDrawText(
        canvas: Canvas,
        text: String,
        preferredX: Float,
        preferredY: Float,
        paint: Paint,
        rotationDegrees: Float,
        radialNudgeCenter: PointF
    ): Boolean {
        var currentX = preferredX
        var currentY = preferredY
        var currentBounds: RectF

        for (attempt in 0..MAX_NUDGE_ATTEMPTS) {
            currentBounds = calculateTextBounds(text, currentX, currentY, paint, rotationDegrees)
            var collisionDetected = false
            for (existingBound in drawnTextBoundsThisFrame) {
                if (RectF.intersects(currentBounds, existingBound)) {
                    collisionDetected = true
                    break
                }
            }

            if (!collisionDetected) {
                drawTextAtPosition(canvas, text, currentX, currentY, paint, rotationDegrees)
                drawnTextBoundsThisFrame.add(currentBounds)
                return true
            }

            if (attempt < MAX_NUDGE_ATTEMPTS) {
                val dx = currentX - radialNudgeCenter.x
                val dy = currentY - radialNudgeCenter.y
                val distFromNudgeCenter = sqrt(dx * dx + dy * dy)
                if (distFromNudgeCenter > 0.01f) {
                    currentX += (dx / distFromNudgeCenter) * NUDGE_DISTANCE_STEP
                    currentY += (dy / distFromNudgeCenter) * NUDGE_DISTANCE_STEP
                } else {
                    currentY -= NUDGE_DISTANCE_STEP
                }
            }
        }
        currentBounds = calculateTextBounds(text, currentX, currentY, paint, rotationDegrees)
        drawTextAtPosition(canvas, text, currentX, currentY, paint, rotationDegrees)
        drawnTextBoundsThisFrame.add(currentBounds)
        return true
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\utility\VisualStateLogic.kt
================================================================================
package com.hereliesaz.cuedetat.drawing.utility

import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.geometry.GeometryCalculator
import com.hereliesaz.cuedetat.geometry.models.AimingLineLogicalCoords

/**
 * Evaluates various visual states based on the application and geometry state.
 */
object VisualStateLogic {

    data class EvaluatedVisualStates(
        val isCurrentlyInvalidShotSetup: Boolean,
        val showWarningStyleForGhostBalls: Boolean
    )

    fun evaluate(
        appState: AppState,
        geometryCalculator: GeometryCalculator,
        aimingLineCoords: AimingLineLogicalCoords?,
        logicalCueCenter: android.graphics.PointF,
        logicalTargetCenter: android.graphics.PointF
    ): EvaluatedVisualStates {

        // Check for physical overlap of logical cue and logical target circles on the plane
        val logicalDistanceBetweenCenters = geometryCalculator.distance(logicalCueCenter, logicalTargetCenter)
        val isPhysicalOverlap = logicalDistanceBetweenCenters < (appState.currentLogicalRadius * 2 - 0.1f)

        // Check if logical target ball is on the "far side" relative to the aiming line's origin (actual cue ball)
        val isCueOnFarSide = if (aimingLineCoords != null) {
            geometryCalculator.isGhostCueOnFarSide(appState, aimingLineCoords)
        } else {
            false
        }

        // Check if protractor angle is in the deflection-dominant range (between 90.5 and 269.5 degrees)
        // This indicates a cut shot that ML Kit is not designed for, or an extreme angle.
        val isDeflectionDominantAngle = (appState.protractorRotationAngle > 90.5f && appState.protractorRotationAngle < 269.5f)

        // The shot is considered invalid if the logical target is on the far side or the angle is deflection-dominant
        val isInvalidShot = isCueOnFarSide || isDeflectionDominantAngle

        // Warning style for ghost balls and yellow target line is applied if there's physical overlap or if the logical target is on the far side.
        val showGhostWarning = isPhysicalOverlap || isCueOnFarSide

        return EvaluatedVisualStates(
            isCurrentlyInvalidShotSetup = isInvalidShot,
            showWarningStyleForGhostBalls = showGhostWarning
        )
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\drawing\DrawingCoordinator.kt
================================================================================
// app/src/main/java/com/hereliesaz/cuedetat/drawing/DrawingCoordinator.kt
package com.hereliesaz.cuedetat.drawing

import android.graphics.Canvas
import android.graphics.PointF
import androidx.compose.ui.graphics.toArgb
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppPaints
import com.hereliesaz.cuedetat.state.AppState
import com.hereliesaz.cuedetat.state.AppState.SelectionMode
import com.hereliesaz.cuedetat.geometry.GeometryCalculator
import com.hereliesaz.cuedetat.geometry.models.AimingLineLogicalCoords
import com.hereliesaz.cuedetat.geometry.models.ProjectedCoords
import com.hereliesaz.cuedetat.drawing.plane.PlaneRenderer
import com.hereliesaz.cuedetat.drawing.screen.ScreenRenderer
import com.hereliesaz.cuedetat.drawing.utility.TextLayoutHelper
import com.hereliesaz.cuedetat.drawing.utility.VisualStateLogic
import com.hereliesaz.cuedetat.ui.theme.AppPurple
import com.hereliesaz.cuedetat.ui.theme.AppWhite
import kotlin.math.abs
import kotlin.math.pow
import kotlin.math.sin
import kotlin.random.Random

class DrawingCoordinator(
    private val appState: AppState,
    private val appPaints: AppPaints,
    private val config: AppConfig, // AppConfig instance is correctly passed
    private val viewWidthProvider: () -> Int,
    private val viewHeightProvider: () -> Int
) {
    private val pitchOffsetPower = 2.0f // Controls the intensity of the pitch-based Y-offset for ghost balls

    private val geometryCalculator = GeometryCalculator(viewWidthProvider, viewHeightProvider)
    private val textLayoutHelper = TextLayoutHelper(viewWidthProvider, viewHeightProvider)
    private val planeRenderer = PlaneRenderer(textLayoutHelper, viewWidthProvider, viewHeightProvider)
    private val screenRenderer = ScreenRenderer(textLayoutHelper, viewWidthProvider, viewHeightProvider)

    private var currentWarningTextToDisplay: String? = null
    private var wasPreviouslyInvalidSetup: Boolean = false // Tracks if the previous frame was invalid
    private var lastRandomWarningIndex: Int = -1 // Stores index of last displayed random warning

    // Exposed for MainOverlayView to use for tap detection
    private var lastProjectedScreenData: ProjectedCoords? = null

    /**
     * Provides the last calculated projected screen coordinates and radii.
     * This is useful for hit testing in MainOverlayView (e.g., ball selection).
     */
    fun getProjectedScreenData(): ProjectedCoords? {
        return lastProjectedScreenData
    }

    /**
     * Main drawing function called by MainOverlayView on each frame.
     * Orchestrates all drawing operations for the protractor plane and screen-space elements.
     *
     * @param canvas The Android Canvas to draw on.
     */
    fun onDraw(canvas: Canvas) {
        // Do not draw if AppState is not initialized or if logical radius is negligible
        if (!appState.isInitialized || appState.currentLogicalRadius <= 0.01f) {
            return
        }

        // Clear text bounds for the new frame to allow for fresh collision detection
        textLayoutHelper.prepareForNewFrame()

        // --- Apply 3D Pitch Transformation to the Canvas ---
        appState.graphicsCamera.save()
        appState.graphicsCamera.rotateX(appState.currentPitchAngle) // Rotate around X-axis based on device pitch
        appState.graphicsCamera.getMatrix(appState.pitchMatrix) // Get the transformation matrix
        appState.graphicsCamera.restore()
        // Pre-translate to pivot around the targetCircleCenter, then post-translate back
        appState.pitchMatrix.preTranslate(-appState.targetCircleCenter.x, -appState.targetCircleCenter.y)
        appState.pitchMatrix.postTranslate(appState.targetCircleCenter.x, appState.targetCircleCenter.y)
        // Attempt to invert the matrix; useful for mapping screen points back to logical plane
        val hasInversePitchMatrix = appState.pitchMatrix.invert(appState.inversePitchMatrix)


        // --- Calculate Geometrical Data for Drawing ---
        val projectedScreenData = geometryCalculator.calculateProjectedScreenData(appState)
        lastProjectedScreenData = projectedScreenData // Store for external access (e.g., tap detection)
        val aimingLineLogicalCoords = geometryCalculator.calculateAimingLineLogicalCoords(appState, hasInversePitchMatrix)
        val deflectionParams = geometryCalculator.calculateDeflectionLineParams(appState)

        // --- Evaluate Current Visual States (e.g., valid shot, warnings) ---
        // Only evaluate complex shot states if in AIMING mode
        val visualStates = if (appState.currentMode == SelectionMode.AIMING) {
            VisualStateLogic.evaluate(
                appState, geometryCalculator, aimingLineLogicalCoords,
                appState.cueCircleCenter, appState.targetCircleCenter
            )
        } else {
            VisualStateLogic.EvaluatedVisualStates(isCurrentlyInvalidShotSetup = false, showWarningStyleForGhostBalls = false)
        }


        // --- Manage Warning Text Display (only in AIMING mode) ---
        if (appState.currentMode == SelectionMode.AIMING) {
            if (visualStates.isCurrentlyInvalidShotSetup) {
                if (!wasPreviouslyInvalidSetup) {
                    if (config.INSULTING_WARNING_STRINGS.isNotEmpty()) {
                        var randomIndex = Random.nextInt(config.INSULTING_WARNING_STRINGS.size)
                        if (config.INSULTING_WARNING_STRINGS.size > 1) {
                            while (randomIndex == lastRandomWarningIndex) {
                                randomIndex = Random.nextInt(config.INSULTING_WARNING_STRINGS.size)
                            }
                        }
                        currentWarningTextToDisplay = config.INSULTING_WARNING_STRINGS[randomIndex]
                        lastRandomWarningIndex = randomIndex
                    } else {
                        currentWarningTextToDisplay = "Invalid Shot Setup" // Fallback warning
                    }
                }
            } else {
                currentWarningTextToDisplay = null // Clear warning when state is valid
            }
        } else {
            currentWarningTextToDisplay = null // No warnings outside AIMING mode
        }
        wasPreviouslyInvalidSetup = visualStates.isCurrentlyInvalidShotSetup // Update state for next frame


        // --- Adjust Paint Properties based on Visual State ---
        // Adjust the yellow target line (main aiming line) based on warning style
        if (visualStates.showWarningStyleForGhostBalls) {
            appPaints.targetLineGuidePaint.apply {
                strokeWidth = config.STROKE_TARGET_LINE_GUIDE + config.STROKE_DEFLECTION_LINE_BOLD_INCREASE
                setShadowLayer(config.GLOW_RADIUS_FIXED, 0f, 0f, appPaints.M3_GLOW_COLOR)
            }
        } else {
            appPaints.targetLineGuidePaint.apply {
                strokeWidth = config.STROKE_TARGET_LINE_GUIDE // Use normal stroke
                clearShadowLayer() // Remove any glow
            }
        }

        // Adjust the aiming assist line colors based on validity
        // Only modify if in AIMING mode
        if (appState.currentMode == SelectionMode.AIMING) {
            val isPhysicalOverlap = geometryCalculator.distance(appState.cueCircleCenter, appState.targetCircleCenter) < (appState.currentLogicalRadius * 2 - 0.1f)
            if (visualStates.isCurrentlyInvalidShotSetup) {
                appPaints.shotGuideNearPaint.apply { color = appPaints.M3_COLOR_ERROR; clearShadowLayer(); strokeWidth = config.STROKE_AIM_LINE_FAR }
                appPaints.shotGuideFarPaint.apply { color = appPaints.M3_COLOR_ERROR; clearShadowLayer(); strokeWidth = config.STROKE_AIM_LINE_FAR }
            } else {
                appPaints.shotGuideNearPaint.apply { color = AppWhite.toArgb(); strokeWidth = config.STROKE_AIM_LINE_NEAR }
                appPaints.shotGuideFarPaint.apply { color = AppPurple.toArgb(); strokeWidth = if (!isPhysicalOverlap) config.STROKE_AIM_LINE_NEAR else config.STROKE_AIM_LINE_FAR}
            }
        } else {
            // If not in AIMING mode, lines are either not drawn or drawn with a neutral style
            // Ensure they are not drawn with error color when not in AIMING mode.
            appPaints.shotGuideNearPaint.apply { color = AppWhite.toArgb(); clearShadowLayer(); strokeWidth = config.STROKE_AIM_LINE_NEAR }
            appPaints.shotGuideFarPaint.apply { color = AppPurple.toArgb(); clearShadowLayer(); strokeWidth = config.STROKE_AIM_LINE_FAR }
        }


        // --- Draw Protractor Plane Elements ---
        canvas.save()
        canvas.concat(appState.pitchMatrix) // Apply the 3D pitch transformation
        planeRenderer.draw(
            canvas, appState, appPaints, config,
            aimingLineCoords = aimingLineLogicalCoords ?: AimingLineLogicalCoords(0f,0f,0f,0f,0f,0f,0f,0f),
            deflectionParams = deflectionParams,
            useErrorColor = visualStates.isCurrentlyInvalidShotSetup,
            actualCueBallScreenCenter = appState.selectedCueBallScreenCenter // Pass actual cue ball screen position
        )
        canvas.restore() // Restore canvas to original (non-pitched) state for screen-space drawing

        // --- Calculate Y-offset for Ghost Balls for Pseudo-3D Effect ---
        // This makes ghost balls appear to "float" above the plane based on pitch.
        val pitchRadians = Math.toRadians(appState.currentPitchAngle.toDouble())
        val basePitchFactor = abs(sin(pitchRadians)).toFloat()
        val pitchScaleFactor = basePitchFactor.pow(pitchOffsetPower)
        val targetGhostDrawnCenterY = projectedScreenData.targetProjected.y - (pitchScaleFactor * projectedScreenData.targetScreenRadius)
        val cueGhostDrawnCenterY = projectedScreenData.cueProjected.y - (pitchScaleFactor * projectedScreenData.cueScreenRadius)

        // --- Draw Screen Space Elements (Ghost Balls and Labels) ---
        screenRenderer.draw(
            canvas, appState, appPaints, config,
            projectedTargetGhostCenter = PointF(projectedScreenData.targetProjected.x, targetGhostDrawnCenterY),
            targetGhostRadius = projectedScreenData.targetScreenRadius,
            projectedCueGhostCenter = PointF(projectedScreenData.cueProjected.x, cueGhostDrawnCenterY),
            cueGhostRadius = projectedScreenData.cueScreenRadius,
            showErrorStyleForGhostBalls = visualStates.showWarningStyleForGhostBalls,
            invalidShotWarningString = currentWarningTextToDisplay
        )
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\tracking\ball_detector\Ball.kt
================================================================================
// app/src/main/java/com/hereliesaz/cuedetat/tracking/ball_detector/Ball.kt
package com.hereliesaz.cuedetat.tracking.ball_detector

/**
 * Represents a detected ball.
 * @param id A unique identifier for the ball, ideally from a tracking ID.
 * @param x The X coordinate of the ball's center in pixels (in the MainOverlayView's coordinate system).
 * @param y The Y coordinate of the ball's center in pixels (in the MainOverlayView's coordinate system).
 * @param radius The radius of the ball in pixels (in the MainOverlayView's coordinate system).
 */
data class Ball(
    val id: String,
    val x: Float,
    val y: Float,
    val radius: Float
)


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\tracking\ball_detector\BallDetector.kt
================================================================================
// FILE: app\src\main\java\com\hereliesaz\cuedetat\tracking\ball_detector\BallDetector.kt
// app/src/main/java/com/hereliesaz/cuedetat/tracking/ball_detector/BallDetector.kt
package com.hereliesaz.cuedetat.tracking.ball_detector

import android.graphics.Rect
import android.util.Log
import androidx.camera.core.ImageProxy
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.objects.ObjectDetection
import com.google.mlkit.vision.objects.ObjectDetector
import com.google.mlkit.vision.objects.defaults.ObjectDetectorOptions
import kotlin.math.max
import kotlin.math.min

class BallDetector {

    private val TAG = "MLKitBallDetector"
    private var objectDetector: ObjectDetector

    init {
        // Configure ML Kit Object Detector
        // MULTIPLE_OBJECTS_MODE: Detects multiple objects in an image.
        // STREAM_MODE: Optimized for real-time video streams.
        // enableClassification: Classify objects (optional, could help differentiate balls later).
        val options = ObjectDetectorOptions.Builder()
            .setDetectorMode(ObjectDetectorOptions.STREAM_MODE)
            .enableMultipleObjects()
            .enableClassification() // Enable classification to try and identify types of objects
            .build()

        objectDetector = ObjectDetection.getClient(options)
    }

    /**
     * Processes an ImageProxy frame from CameraX to detect balls using ML Kit.
     * @param imageProxy The ImageProxy from CameraX.
     * @param onDetectionSuccess Callback with a list of detected Balls (ML Kit specific data).
     * @param onDetectionFailure Callback for when detection fails.
     */
    fun detectBalls(imageProxy: ImageProxy, onDetectionSuccess: (List<Ball>) -> Unit, onDetectionFailure: (Exception) -> Unit) {
        val mediaImage = imageProxy.image
        if (mediaImage == null) {
            Log.d(TAG, "detectBalls: mediaImage is null, closing imageProxy.")
            imageProxy.close()
            return
        }

        // Create InputImage from ImageProxy for ML Kit
        val inputImage = InputImage.fromMediaImage(mediaImage, imageProxy.imageInfo.rotationDegrees)

        objectDetector.process(inputImage)
            .addOnSuccessListener { detectedObjects ->
                val detectedBalls = mutableListOf<Ball>()
                for (detectedObject in detectedObjects) {
                    val boundingBox = detectedObject.boundingBox
                    val trackingId = detectedObject.trackingId
                    val confidence = detectedObject.labels.firstOrNull()?.confidence ?: 0f

                    // Filter based on shape (aspect ratio close to 1:1) and confidence if needed
                    // A simple heuristic for a ball is a bounding box that is roughly square.
                    val aspectRatio = boundingBox.width().toFloat() / boundingBox.height().toFloat()
                    val isRoughlySquare = aspectRatio > 0.7 && aspectRatio < 1.3 // Allow some leeway

                    // You might want to filter by classification label if available and relevant (e.g., "ball")
                    // For general objects, classification might not be specific enough for pool balls.
                    val isBall = detectedObject.labels.any { label ->
                        label.text.equals("ball", ignoreCase = true) || // Common label for round objects
                                label.text.equals("sphere", ignoreCase = true) ||
                                label.text.equals("sport", ignoreCase = true) // General sports object
                        // Add more specific labels if ML Kit provides them for pool balls
                    }

                    if (isRoughlySquare && confidence > 0.5) { // Confidence threshold
                        // Map ML Kit bounding box to our simplified Ball model
                        val centerX = boundingBox.centerX().toFloat()
                        val centerY = boundingBox.centerY().toFloat()
                        // Use average of half width and half height as radius for a circular representation
                        val radius = (boundingBox.width() + boundingBox.height()) / 4f

                        // Ensure radius is positive to avoid issues with drawing/logic
                        if (radius > 0) {
                            // Use trackingId for unique identification if available, otherwise fallback to object hash
                            val id = trackingId?.toString() ?: detectedObject.hashCode().toString()
                            detectedBalls.add(Ball(id, centerX, centerY, radius))
                        }
                    }
                }
                Log.d(TAG, "ML Kit Object detection successful, detectedObjects.size=${detectedObjects.size}, filteredBalls.size=${detectedBalls.size}")
                onDetectionSuccess(detectedBalls)
            }
            .addOnFailureListener { e ->
                Log.e(TAG, "ML Kit Object detection failed", e)
                onDetectionFailure(e)
            }
            .addOnCompleteListener {
                // Ensure ImageProxy is closed after processing, regardless of success or failure.
                imageProxy.close()
            }
    }

    /**
     * Releases ML Kit detector resources.
     */
    fun shutdown() {
        objectDetector.close()
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\updater\GithubUpdater.kt
================================================================================
// FILE: app\src\main\java\com\hereliesaz\cuedetat\updater\GithubUpdater.kt
package com.hereliesaz.cuedetat.updater

import android.annotation.SuppressLint
import android.app.DownloadManager
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.net.Uri
import android.os.Environment
import android.util.Log
import androidx.core.content.ContextCompat
import androidx.core.content.FileProvider
import com.hereliesaz.cuedetat.config.AppConfig
import okhttp3.*
import org.json.JSONObject
import java.io.File
import java.io.IOException
import java.util.concurrent.TimeUnit
import androidx.core.net.toUri

class GitHubUpdater(
    private val context: Context,
    private val repoOwner: String,
    private val repoName: String,
    private val currentVersionCode: Int,
    private val callback: Callback
) {
    private val TAG = "${AppConfig.TAG}_GitHubUpdater"
    private val API_BASE_URL = "https://api.github.com/repos/$repoOwner/$repoName"
    private val RELEASE_URL = "$API_BASE_URL/releases/latest"

    private val client = OkHttpClient.Builder()
        .connectTimeout(10, TimeUnit.SECONDS)
        .readTimeout(10, TimeUnit.SECONDS)
        .writeTimeout(10, TimeUnit.SECONDS)
        .build()

    interface Callback {
        fun onUpdateCheckComplete(latestRelease: ReleaseInfo?, isNewer: Boolean)
        fun onUpdateDownloadComplete(downloadId: Long)
        fun onUpdateDownloadFailed(reason: String)
        fun onError(message: String)
    }

    data class ReleaseInfo(
        val tagName: String,
        val versionCode: Int, // The version code extracted from the release, or 0 if not found
        val downloadUrl: String,
        val releaseName: String
    )

    private var downloadReceiver: BroadcastReceiver? = null
    private var downloadId: Long = -1L
    private var downloadedApkFileName: String? = null // Store the expected file name

    /**
     * Checks for a new release on GitHub.
     */
    fun checkForUpdate() {
        Log.d(TAG, "Checking for updates at $RELEASE_URL")
        val request = Request.Builder().url(RELEASE_URL).build()

        client.newCall(request).enqueue(object : okhttp3.Callback {
            override fun onFailure(call: Call, e: IOException) {
                Log.e(TAG, "Failed to check for updates: ${e.message}")
                callback.onError("Failed to check for updates: ${e.message}")
            }

            override fun onResponse(call: Call, response: Response) {
                response.use {
                    if (!response.isSuccessful) {
                        Log.e(TAG, "GitHub API request failed: ${response.code} - ${response.message}")
                        callback.onError("Failed to check for updates: HTTP ${response.code}")
                        return
                    }

                    val responseBody = response.body?.string()
                    if (responseBody.isNullOrEmpty()) {
                        callback.onError("Empty response from GitHub API.")
                        return
                    }

                    try {
                        val json = JSONObject(responseBody)
                        val tagName = json.getString("tag_name")
                        val releaseName = json.getString("name")

                        // Try to extract version code from tag name or release name
                        val extractedVersionCode = extractVersionCodeFromTag(tagName)

                        if (extractedVersionCode == 0) {
                            Log.w(TAG, "Could not extract version code from tag: $tagName. Skipping update check.")
                            callback.onError("Could not parse version from latest release tag: $tagName")
                            callback.onUpdateCheckComplete(null, false) // Indicate no valid update found
                            return
                        }

                        Log.d(TAG, "Latest release tag: $tagName (Version Code: $extractedVersionCode), Current: $currentVersionCode")

                        val assets = json.getJSONArray("assets")
                        var apkDownloadUrl: String? = null
                        for (i in 0 until assets.length()) {
                            val asset = assets.getJSONObject(i)
                            val assetName = asset.getString("name")
                            if (assetName.matches(Regex(AppConfig.GITHUB_RELEASE_ASSET_NAME_REGEX))) {
                                apkDownloadUrl = asset.getString("browser_download_url")
                                break
                            }
                        }

                        if (apkDownloadUrl != null) {
                            val latestReleaseInfo = ReleaseInfo(tagName, extractedVersionCode, apkDownloadUrl, releaseName)
                            val isNewer = extractedVersionCode > currentVersionCode
                            callback.onUpdateCheckComplete(latestReleaseInfo, isNewer)
                        } else {
                            callback.onError("No APK asset found in latest release for $tagName.")
                            callback.onUpdateCheckComplete(null, false) // Indicate no valid update found
                        }

                    } catch (e: Exception) {
                        Log.e(TAG, "Error parsing GitHub API response: ${e.message}", e)
                        callback.onError("Error parsing GitHub API response: ${e.message}")
                        callback.onUpdateCheckComplete(null, false) // Indicate no valid update found
                    }
                }
            }
        })
    }

    /**
     * Attempts to extract a numeric version code from a tag name (e.g., "v1.2.3" -> 123).
     * This needs to be adapted to your actual release tagging scheme.
     */
    private fun extractVersionCodeFromTag(tagName: String): Int {
        // Example: If tag is "v1.0.0" and versionCode is 100, "v1.1.0" is 110 etc.
        // This regex takes numbers separated by dots and joins them.
        val numericParts = Regex("\\d+").findAll(tagName).map { it.value }.joinToString("")
        return numericParts.toIntOrNull() ?: 0 // Convert to Int, return 0 if conversion fails
    }


    /**
     * Downloads the APK file.
     */
    @SuppressLint("Range")
    fun downloadUpdate(apkDownloadUrl: String, releaseName: String) {
        val fileName = "${repoName}_${releaseName}.apk"
        downloadedApkFileName = fileName // Store the expected filename for later use

        // Use context.getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS) for app-specific external storage
        // This is the correct way to get a path that FileProvider's <external-files-path> will recognize
        val destinationDir = File(context.getExternalFilesDir(null), "updates")
        if (!destinationDir.exists()) {
            destinationDir.mkdirs() // Create the directory if it doesn't exist
        }
        val destinationFile = File(destinationDir, fileName)

        // Clear previous download if it exists and wasn't completed
        val downloadManager = context.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
        val query = DownloadManager.Query().setFilterByStatus(
            DownloadManager.STATUS_PAUSED or DownloadManager.STATUS_PENDING or DownloadManager.STATUS_RUNNING
        )
        val cursor = downloadManager.query(query)
        if (cursor.moveToFirst()) {
            do {
                val existingDownloadId = cursor.getLong(cursor.getColumnIndex(DownloadManager.COLUMN_ID))
                val existingUriString = cursor.getString(cursor.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI))
                if (existingUriString != null && existingUriString.contains(destinationFile.name)) {
                    downloadManager.remove(existingDownloadId)
                    Log.d(TAG, "Removed incomplete previous download for ${destinationFile.name}")
                    break
                }
            } while (cursor.moveToNext())
        }
        cursor.close()

        if (destinationFile.exists()) {
            destinationFile.delete() // Delete existing completed file if it exists
            Log.d(TAG, "Deleted existing old APK: ${destinationFile.absolutePath}")
        }


        val request = DownloadManager.Request(apkDownloadUrl.toUri())
            .setTitle("Downloading $repoName Update")
            .setDescription("Version: $releaseName")
            .setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED)
            // Use setDestinationUri with a Uri from a File object that matches FileProvider config
            .setDestinationUri(Uri.fromFile(destinationFile))
            .setAllowedOverMetered(true)
            .setAllowedOverRoaming(true)

        downloadId = downloadManager.enqueue(request)
        Log.d(TAG, "Download started: $downloadId for $apkDownloadUrl to ${destinationFile.absolutePath}")

        // Register receiver for download completion
        downloadReceiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context?, intent: Intent?) {
                val id = intent?.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1L)
                if (id == downloadId) {
                    val query = DownloadManager.Query().setFilterById(downloadId)
                    val cursor = downloadManager.query(query)
                    if (cursor.moveToFirst()) {
                        val statusIndex = cursor.getColumnIndex(DownloadManager.COLUMN_STATUS)
                        val status = cursor.getInt(statusIndex)
                        if (status == DownloadManager.STATUS_SUCCESSFUL) {
                            Log.d(TAG, "Download successful for ID: $downloadId")
                            callback.onUpdateDownloadComplete(downloadId)
                        } else {
                            val reasonIndex = cursor.getColumnIndex(DownloadManager.COLUMN_REASON)
                            val reason = cursor.getInt(reasonIndex)
                            Log.e(TAG, "Download failed: $status, reason: $reason")
                            callback.onUpdateDownloadFailed("Download failed (status: $status, reason: $reason)")
                        }
                    } else {
                        callback.onUpdateDownloadFailed("Download failed: Cursor empty")
                    }
                    cursor.close()
                    unregisterDownloadReceiver() // Unregister immediately after handling
                }
            }
        }
        val filter = IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE)
        ContextCompat.registerReceiver(
            context,
            downloadReceiver,
            filter,
            ContextCompat.RECEIVER_NOT_EXPORTED
        )
    }

    /**
     * Initiates the installation of the downloaded APK.
     */
    @SuppressLint("Range")
    fun installUpdate(downloadId: Long) {
        val downloadManager = context.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
        val query = DownloadManager.Query().setFilterById(downloadId)
        val cursor = downloadManager.query(query)

        if (cursor.moveToFirst()) {
            val uriIndex = cursor.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI)
            val downloadedUriString = cursor.getString(uriIndex)
            cursor.close()

            if (downloadedUriString == null) {
                callback.onError("Downloaded file URI is null. Download might not be complete or failed.")
                return
            }

            val downloadedUri = downloadedUriString.toUri()
            // Reconstruct the File object using the original destination path.
            // This is safer than relying on `downloadedUri.path` which might be a content URI.
            val destinationDir = File(context.getExternalFilesDir(null), "updates")
            val apkFile = File(destinationDir, downloadedApkFileName) // Use the stored file name

            if (!apkFile.exists()) {
                Log.e(TAG, "Downloaded APK file not found at expected path: ${apkFile.absolutePath}. URI from DM: $downloadedUri")
                callback.onError("Downloaded APK file not found. Please try updating again.")
                return
            }

            val contentUri: Uri = FileProvider.getUriForFile(
                context,
                "${context.applicationContext.packageName}.fileprovider",
                apkFile // Pass the File object that is within the FileProvider's configured paths
            )

            val installIntent = Intent(Intent.ACTION_INSTALL_PACKAGE).apply {
                setData(contentUri)
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            }

            try {
                context.startActivity(installIntent)
                Log.d(TAG, "Installation intent sent for: ${apkFile.absolutePath}.")
            } catch (e: Exception) {
                Log.e(TAG, "Failed to start installation: ${e.message}", e)
                callback.onError("Failed to start installation: ${e.message}")
            }
        } else {
            cursor.close()
            callback.onError("Download information not found for ID: $downloadId")
        }
    }

    /**
     * Unregisters the BroadcastReceiver if it's currently registered.
     */
    private fun unregisterDownloadReceiver() {
        if (downloadReceiver != null) {
            try {
                context.unregisterReceiver(downloadReceiver)
                downloadReceiver = null
                Log.d(TAG, "Download receiver unregistered.")
            } catch (e: IllegalArgumentException) {
                // Receiver was already unregistered or never registered
                Log.w(TAG, "Attempted to unregister receiver that was not registered: ${e.message}")
            }
        }
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\MainActivity.kt
================================================================================
// FILE: app\src\main\java\com\hereliesaz\cuedetat\MainActivity.kt
// app/src/main/java/com/hereliesaz/cuedetat/MainActivity.kt
package com.hereliesaz.cuedetat

/**
 * **DEVELOPER NOTE (MANDATORY - READ AND ADHERE):**
 *
 * ALL DISTINCT PIECES OF LOGIC, ALGORITHMS, OR SIGNIFICANT HELPER FUNCTIONALITIES
 * MUST BE EXTRACTED INTO THEIR OWN DEDICATED FILES. THESE FILES SHOULD RESIDE
 * WITHIN APPROPRIATELY NAMED DIRECTORIES/PACKAGES THAT REFLECT THEIR PURPOSE.
 *
 * DO NOT ADD COMPLEX, REUSABLE, OR SUBSTANTIAL LOGIC BLOCKS AS PRIVATE METHODS
 * WITHIN THIS ACTIVITY OR OTHER LARGE CLASSES (e.g., MainOverlayView) IF THEY
 * CAN BE PROPERLY MODULARIZED.
 *
 * THE GOAL IS SINGLE RESPONSIBILITY AND HIGH COHESION AT THE FILE LEVEL.
 * THIS PRINCIPLE APPLIES RETROACTIVELY TO ANY EXISTING LOGIC THAT HAS NOT YET
 * BEEN MODULARIZED AND IS A STRICT REQUIREMENT FOR ALL FUTURE DEVELOPMENT.
 *
 * MAKE LOGIC:
 * 1. OBVIOUS IN ITS LOCATION.
 * 2. EASILY FINDABLE.
 * 3. MODULAR AND INDEPENDENT WHERE POSSIBLE.
 *
 * THE ZoomSliderLogic.kt FILE IS AN EXAMPLE OF THIS PRINCIPLE IN ACTION.
 * ALL SIMILARLY COMPLEX OR DISTINCT LOGIC SETS MUST FOLLOW THIS PATTERN.
 * FAILURE TO DO SO WILL RESULT IN CODE REJECTION/REWORK.
 */

import android.content.DialogInterface
import android.content.pm.PackageManager
import android.content.res.Resources
import android.os.Bundle
import android.util.Log
import android.view.Gravity
import android.view.View
import android.view.WindowManager
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.PopupMenu
import android.widget.SeekBar
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.view.ContextThemeWrapper
import androidx.camera.view.PreviewView
import androidx.compose.material3.MaterialTheme
import androidx.compose.runtime.SideEffect
import androidx.compose.ui.platform.ComposeView
import androidx.constraintlayout.widget.ConstraintLayout
import androidx.core.content.res.ResourcesCompat
import androidx.core.view.ViewCompat
import androidx.core.view.WindowCompat
import androidx.core.view.WindowInsetsCompat
import androidx.core.view.WindowInsetsControllerCompat
import androidx.core.view.updatePadding
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.hereliesaz.cuedetat.config.AppConfig
import com.hereliesaz.cuedetat.state.AppState.SelectionMode
import com.hereliesaz.cuedetat.system.CameraManager
import com.hereliesaz.cuedetat.system.PitchSensor
import com.hereliesaz.cuedetat.ui.theme.PoolProtractorTheme // Added import
import com.hereliesaz.cuedetat.updater.GitHubUpdater
import com.hereliesaz.cuedetat.view.MainOverlayView
import com.hereliesaz.cuedetat.view.MainOverlayView.AppStateListener
import com.hereliesaz.cuedetat.view.utility.ZoomSliderLogic
import kotlin.math.abs

class MainActivity : AppCompatActivity(), AppStateListener, GitHubUpdater.Callback {

    private companion object {
        private val TAG = AppConfig.TAG + "_MainActivity"
    }

    private lateinit var cameraPreviewView: PreviewView
    private lateinit var mainOverlayView: MainOverlayView
    private lateinit var zoomSlider: SeekBar
    private lateinit var resetButton: FloatingActionButton
    private lateinit var zoomCycleButton: FloatingActionButton
    // Removed helpButton from declaration
    private lateinit var controlsLayout: ConstraintLayout
    private lateinit var appTitleContainer: FrameLayout // Reference to the FrameLayout wrapping title/logo

    private lateinit var appTitleTextView: TextView
    private lateinit var appTitleLogoImageView: ImageView

    private lateinit var cameraManager: CameraManager
    private lateinit var pitchSensor: PitchSensor
    private lateinit var gitHubUpdater: GitHubUpdater // GitHubUpdater instance

    private var valuesChangedSinceLastReset = false
    private var helpTextCurrentlyVisible = false // Default to false
    private var currentSelectionMode: SelectionMode = SelectionMode.SELECTING_CUE_BALL // Track mode in Activity

    private enum class ZoomCycleState { MIN_ZOOM, MAX_ZOOM }
    private var nextZoomCycleState: ZoomCycleState = ZoomCycleState.MIN_ZOOM


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Log.d(TAG, "MainActivity onCreate started.")

        // Configure window for full-screen immersive mode
        WindowCompat.setDecorFitsSystemWindows(window, false)
        val windowInsetsController = WindowInsetsControllerCompat(window, window.decorView)
        windowInsetsController.hide(WindowInsetsCompat.Type.statusBars())
        windowInsetsController.systemBarsBehavior = WindowInsetsControllerCompat.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE
        window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON) // Keep screen on

        setContentView(R.layout.activity_main)
        controlsLayout = findViewById(R.id.controls_layout)

        // Apply system bar insets as padding to the controls layout to avoid overlap
        ViewCompat.setOnApplyWindowInsetsListener(controlsLayout) { view, windowInsets ->
            val insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars())
            view.updatePadding(
                left = insets.left,
                top = insets.top, // Fixed typo: 'inets' to 'insets'
                right = insets.right,
                bottom = insets.bottom
            )
            WindowInsetsCompat.CONSUMED
        }

        // Initialize UI components
        cameraPreviewView = findViewById(R.id.cameraPreviewView)
        mainOverlayView = findViewById(R.id.protractorOverlayView)
        zoomSlider = findViewById(R.id.zoomSlider)
        resetButton = findViewById(R.id.resetButton)
        zoomCycleButton = findViewById(R.id.zoomCycleButton)
        // Removed helpButton from findViewById
        appTitleContainer = findViewById(R.id.appTitleContainer) // Get reference to the FrameLayout
        appTitleTextView = findViewById(R.id.appTitleTextView)
        appTitleLogoImageView = findViewById(R.id.appTitleLogoImageView)

        Log.d(TAG, "mainOverlayView found: ${::mainOverlayView.isInitialized}")
        Log.d(TAG, "appTitleTextView visibility (XML default): ${appTitleTextView.visibility}")


        // Set custom font for the app title
        try {
            val archivoBlackTypeface = ResourcesCompat.getFont(this, R.font.archivo_black_regular)
            appTitleTextView.typeface = archivoBlackTypeface
        } catch (e: Resources.NotFoundException) {
            Log.e(TAG, "Archivo Black font not found for title, using default.", e)
        }

        mainOverlayView.listener = this // Set MainActivity as the listener for MainOverlayView events
        helpTextCurrentlyVisible = mainOverlayView.getAreHelperTextsVisible() // Get initial visibility state (will be false from AppState default)
        currentSelectionMode = mainOverlayView.getSelectionMode() // Get initial selection mode
        updateUiVisibilityForSelectionMode() // Update UI based on initial mode
        updateTitleVisibility() // Update title/logo based on initial visibility

        // Initialize CameraManager and PitchSensor
        cameraManager = CameraManager(this, this, cameraPreviewView, mainOverlayView) // Pass mainOverlayView for camera frames
        pitchSensor = PitchSensor(
            this,
            AppConfig.FORWARD_TILT_AS_FLAT_OFFSET_DEGREES, // Use offset from AppConfig
            { pitchAngle ->
                mainOverlayView.setDevicePitchAngle(pitchAngle) // Update overlay with pitch angle
            }
        )

        // Initialize MainOverlayView's components here, passing CameraManager
        // This must be called after the view has been measured (in onSizeChanged)
        // For Compose theme application, ensure this call is made when view is ready.
        // It's safe to call here, but MainOverlayView itself might defer internal setup if w/h are 0.
        mainOverlayView.initializeComponents(cameraManager)


        // Initialize GitHubUpdater
        val currentAppVersionCode = try {
            packageManager.getPackageInfo(packageName, 0).versionCode
        } catch (e: PackageManager.NameNotFoundException) {
            Log.e(TAG, "Package name not found for version code lookup: ${e.message}")
            0 // Default to 0 if not found
        }
        gitHubUpdater = GitHubUpdater(
            this,
            AppConfig.GITHUB_REPO_OWNER,
            AppConfig.GITHUB_REPO_NAME,
            currentAppVersionCode,
            this // MainActivity implements GitHubUpdater.Callback
        )


        // Setup ComposeView for Material 3 theming (colors applied to legacy View system)
        val composeViewForTheme = findViewById<ComposeView>(R.id.composeThemeView)
        composeViewForTheme.setContent {
            // Fix: PoolProtractorTheme is a @Composable function, it must be called inside a @Composable scope.
            // The setContent block itself is a @Composable scope.
            PoolProtractorTheme {
                val currentColorScheme = MaterialTheme.colorScheme
                SideEffect {
                    // Pass the current Material 3 color scheme to the custom view for its paints
                    mainOverlayView.applyMaterialYouColors(currentColorScheme)
                }
            }
        }

        cameraManager.checkPermissionsAndSetupCamera() // Request camera permissions and start camera
        setupControls() // Set up UI control listeners
    }

    /**
     * Configures listeners for UI controls (zoom slider, buttons).
     */
    private fun setupControls() {
        // Use CameraManager's current zoom to initialize slider
        updateZoomSliderFromFactor(mainOverlayView.getZoomFactor())

        zoomSlider.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {
            override fun onProgressChanged(seekBar: SeekBar, progress: Int, fromUser: Boolean) {
                if (fromUser) {
                    val minZoom = mainOverlayView.getMinCameraZoomFactor()
                    val maxZoom = mainOverlayView.getMaxCameraZoomFactor()
                    val zoomValue = ZoomSliderLogic.convertSliderProgressToZoomFactor(progress, minZoom, maxZoom)
                    mainOverlayView.setZoomFactor(zoomValue)
                    nextZoomCycleState = ZoomCycleState.MIN_ZOOM // Reset cycle state when slider is used
                }
            }
            override fun onStartTrackingTouch(seekBar: SeekBar) {
                this@MainActivity.onUserInteraction() // Notify of user interaction
            }
            override fun onStopTrackingTouch(seekBar: SeekBar) {}
        })

        resetButton.setOnClickListener { handleResetAction() }
        // Removed helpButton.setOnClickListener {}
        zoomCycleButton.setOnClickListener { handleZoomCycleAction() }

        // Set up click listener for the app title/logo to show popup menu
        appTitleContainer.setOnClickListener { view ->
            showAppMenu(view)
        }
    }

    /**
     * Displays a popup menu when the app title/logo is tapped.
     */
    private fun showAppMenu(view: View) {
        // Create a ContextThemeWrapper to apply the custom PopupMenu style
        val wrapper = ContextThemeWrapper(this, R.style.AppTheme_PopupMenu)
        // Use ContextThemeWrapper for PopupMenu constructor
        val popup = PopupMenu(wrapper, view, Gravity.END) // Anchor to the right of the view
        popup.menuInflater.inflate(R.menu.main_menu, popup.menu)
        popup.setOnMenuItemClickListener { item ->
            when (item.itemId) {
                R.id.action_check_for_updates -> {
                    Toast.makeText(this, "Checking for updates...", Toast.LENGTH_SHORT).show()
                    gitHubUpdater.checkForUpdate()
                    true
                }
                R.id.action_toggle_help -> { // Handle the new help toggle menu item
                    mainOverlayView.toggleHelperTextVisibility()
                    true
                }
                else -> false
            }
        }
        popup.show()
    }


    /**
     * Updates the visibility of the app title text or logo based on helper text visibility.
     */
    private fun updateTitleVisibility() {
        if (helpTextCurrentlyVisible) {
            appTitleTextView.visibility = View.VISIBLE
            appTitleLogoImageView.visibility = View.GONE
            Log.d(TAG, "Title visibility: Text Visible, Logo Gone (Help Text On)")
        } else {
            appTitleTextView.visibility = View.GONE
            appTitleLogoImageView.visibility = View.VISIBLE
            Log.d(TAG, "Title visibility: Text Gone, Logo Visible (Help Text Off)")
        }
    }

    /**
     * Updates the visibility of UI controls based on the current selection mode.
     * Only zoom and rotate interactions are enabled in AIMING mode.
     */
    private fun updateUiVisibilityForSelectionMode() {
        val controlsVisibleInAiming = currentSelectionMode == SelectionMode.AIMING
        zoomSlider.visibility = if (controlsVisibleInAiming) View.VISIBLE else View.INVISIBLE
        zoomCycleButton.visibility = if (controlsVisibleInAiming) View.VISIBLE else View.INVISIBLE
        Log.d(TAG, "UI visibility updated for mode: $currentSelectionMode. Zoom controls visible: $controlsVisibleInAiming")
        // Help and Reset buttons are always visible, but their actions might be restricted by MainOverlayView
        // Their visibility logic is separate.
    }

    /**
     * Handles cycling through predefined zoom levels (min/max).
     */
    private fun handleZoomCycleAction() {
        // Only allow zoom cycling if in AIMING mode
        if (currentSelectionMode != SelectionMode.AIMING) return

        val currentZoom = mainOverlayView.getZoomFactor()
        val minZoom = mainOverlayView.getMinCameraZoomFactor()
        val maxZoom = mainOverlayView.getMaxCameraZoomFactor()

        val targetZoom = when (nextZoomCycleState) {
            ZoomCycleState.MIN_ZOOM -> {
                nextZoomCycleState = ZoomCycleState.MAX_ZOOM
                minZoom
            }
            ZoomCycleState.MAX_ZOOM -> {
                nextZoomCycleState = ZoomCycleState.MIN_ZOOM
                maxZoom
            }
        }
        mainOverlayView.setZoomFactor(targetZoom) // Set zoom via overlay view
    }

    /**
     * Resets the overlay view to its default interaction state.
     */
    private fun handleResetAction() {
        mainOverlayView.resetInteractionsToDefaults() // Reset view state
        nextZoomCycleState = ZoomCycleState.MIN_ZOOM // Reset zoom cycle state
        Toast.makeText(this, "View reset to defaults", Toast.LENGTH_SHORT).show()
    }

    // --- MainOverlayView.AppStateListener implementations ---

    override fun onZoomChanged(newZoomFactor: Float) {
        // Update the slider to reflect the actual camera zoom ratio, which might be slightly different from requested
        updateZoomSliderFromFactor(newZoomFactor)
        // Update zoom cycle state based on current zoom factor
        val minZoom = mainOverlayView.getMinCameraZoomFactor()
        val maxZoom = mainOverlayView.getMaxCameraZoomFactor()
        if (abs(newZoomFactor - minZoom) < 0.01f) {
            nextZoomCycleState = ZoomCycleState.MAX_ZOOM
        } else if (abs(newZoomFactor - maxZoom) < 0.01f) {
            nextZoomCycleState = ZoomCycleState.MIN_ZOOM
        }
        valuesChangedSinceLastReset = true // Mark that user interaction occurred
    }

    override fun onRotationChanged(newRotationAngle: Float) {
        valuesChangedSinceLastReset = true // Mark that user interaction occurred
    }

    override fun onUserInteraction() {
        valuesChangedSinceLastReset = true // Mark that user interaction occurred
        // Check if helper text visibility changed and update title
        val currentOverlayVisibility = mainOverlayView.getAreHelperTextsVisible()
        if (helpTextCurrentlyVisible != currentOverlayVisibility) {
            helpTextCurrentlyVisible = currentOverlayVisibility
            updateTitleVisibility()
        }
    }

    override fun onCueBallSelected(ballId: String?) {
        val message = if (ballId != null) "Cue ball selected: $ballId" else "Cue ball deselected."
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
    }

    override fun onTargetBallSelected(ballId: String?) {
        val message = if (ballId != null) "Target ball selected: $ballId" else "Target ball deselected."
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
    }

    override fun onSelectionModeChanged(mode: SelectionMode) {
        currentSelectionMode = mode
        updateUiVisibilityForSelectionMode() // Update UI based on new mode
        val message = when (mode) {
            SelectionMode.SELECTING_CUE_BALL -> "Please tap the cue ball."
            SelectionMode.SELECTING_TARGET_BALL -> "Now tap the target ball."
            SelectionMode.AIMING -> "Aiming mode activated."
        }
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
        Log.d(TAG, "Selection Mode changed to: $mode")
    }

    /**
     * Updates the zoom slider's progress based on a given zoom factor.
     * @param factor The zoom factor to convert to slider progress.
     */
    private fun updateZoomSliderFromFactor(factor: Float) {
        val minZoom = mainOverlayView.getMinCameraZoomFactor()
        val maxZoom = mainOverlayView.getMaxCameraZoomFactor()
        val progress = ZoomSliderLogic.convertZoomFactorToSliderProgress(factor, minZoom, maxZoom)
        // Only update if different to avoid infinite loops with onProgressChanged
        if (zoomSlider.progress != progress) {
            zoomSlider.progress = progress
        }
    }

    // --- GitHubUpdater.Callback implementations ---
    override fun onUpdateCheckComplete(latestRelease: GitHubUpdater.ReleaseInfo?, isNewer: Boolean) {
        if (latestRelease == null) {
            // Error already handled by onError from updater
            return
        }

        val dialogTitle: String
        val dialogMessage: String
        val positiveButtonText: String

        if (isNewer) {
            dialogTitle = "New Update Available!"
            dialogMessage = "Version ${latestRelease.releaseName} is available.\n\n" +
                    "Would you like to download and install it?"
            positiveButtonText = "Update"
        } else {
            dialogTitle = "You are on the Latest Version"
            dialogMessage = "Version ${latestRelease.releaseName} is the latest.\n\n" +
                    "Do you want to reinstall this version?"
            positiveButtonText = "Reinstall"
        }

        runOnUiThread {
            AlertDialog.Builder(this)
                .setTitle(dialogTitle)
                .setMessage(dialogMessage)
                .setPositiveButton(positiveButtonText) { dialog: DialogInterface, _: Int ->
                    gitHubUpdater.downloadUpdate(latestRelease.downloadUrl, latestRelease.releaseName)
                    Toast.makeText(this, "Downloading update...", Toast.LENGTH_SHORT).show()
                    dialog.dismiss()
                }
                .setNegativeButton("Cancel") { dialog: DialogInterface, _: Int ->
                    dialog.dismiss()
                }
                .show()
        }
    }

    override fun onUpdateDownloadComplete(downloadId: Long) {
        runOnUiThread {
            Toast.makeText(this, "Download complete. Installing...", Toast.LENGTH_LONG).show()
            gitHubUpdater.installUpdate(downloadId) // Pass the downloadId to installUpdate
        }
    }

    override fun onUpdateDownloadFailed(reason: String) {
        runOnUiThread {
            Toast.makeText(this, "Update download failed: $reason", Toast.LENGTH_LONG).show()
        }
    }

    fun onNoUpdateAvailable() {
        // This callback is now redundant if onUpdateCheckComplete handles `isNewer` flag.
        // If `latestRelease` is null, onError already handles it.
        // If `latestRelease` is not null and `isNewer` is false, `onUpdateCheckComplete` shows reinstall dialog.
        Log.d(TAG, "No newer update found (handled by onUpdateCheckComplete).")
    }

    override fun onError(message: String) {
        runOnUiThread {
            Toast.makeText(this, "Update error: $message", Toast.LENGTH_LONG).show()
        }
    }


    override fun onResume() {
        super.onResume()
        pitchSensor.register() // Register pitch sensor listener
        Log.d(TAG, "MainActivity onResume, PitchSensor registered.")
    }

    override fun onPause() {
        super.onPause()
        pitchSensor.unregister() // Unregister pitch sensor listener
        Log.d(TAG, "MainActivity onPause, PitchSensor unregistered.")
    }

    override fun onDestroy() {
        super.onDestroy()
        cameraManager.shutdown() // Ensure camera resources are released
        Log.d(TAG, "MainActivity onDestroy, CameraManager shutdown.")
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\MyApplication.kt
================================================================================
package com.hereliesaz.cuedetat

import android.app.Application
import androidx.appcompat.app.AppCompatDelegate
import android.util.Log
import com.hereliesaz.cuedetat.config.AppConfig // For TAG
// REMOVE THIS LINE: import org.opencv.android.OpenCVLoader // Remove OpenCVLoader import

class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        Log.i(AppConfig.TAG, "MyApplication onCreate: Forcing Light Theme (MODE_NIGHT_NO).")
        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO)

        // REMOVED BLOCK - No longer needed for OpenCV initialization
        /*
        if (!OpenCVLoader.initDebug()) { // initDebug is for development, initAsync is better for production
            Log.e(AppConfig.TAG, "Failed to initialize OpenCV!")
            // Consider showing a user-friendly message or disabling features if OpenCV is crucial
        } else {
            Log.i(AppConfig.TAG, "OpenCV initialized successfully.")
        }
        */
    }
}


================================================================================
FILE: app\src\main\res\drawable\ic_launcher_foreground.xml
================================================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path
        android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
        <aapt:attr name="android:fillColor">
            <gradient
                android:startY="49.59793"
                android:startX="42.9492"
                android:endY="92.4963"
                android:endX="85.84757"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
        android:fillColor="#00000000"
        android:fillType="nonZero"
        android:strokeWidth="1"
        android:strokeColor="#00000000"/>
</vector>


================================================================================
FILE: app\src\main\res\drawable\ic_undo_24.xml
================================================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12.5,8c-2.65,0 -5.05,0.99 -6.9,2.6L2,7v9h9l-3.62,-3.62c1.39,-1.16 3.16,-1.88 5.12,-1.88 3.54,0 6.55,2.31 7.6,5.5l2.37,-0.78C21.08,11.96 17.15,8 12.5,8z"/>
</vector>


================================================================================
FILE: app\src\main\res\drawable\ic_zoom_in_24.xml
================================================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M15.5,14h-0.79l-0.28,-0.27C15.41,12.59 16,11.11 16,9.5 16,5.91 13.09,3 9.5,3S3,5.91 3,9.5 5.91,16 9.5,16c1.61,0 3.09,-0.59 4.23,-1.57l0.27,0.28v0.79l5,4.99L20.49,19l-4.99,-5zM9.5,14C7.01,14 5,11.99 5,9.5S7.01,5 9.5,5 14,7.01 14,9.5 11.99,14 9.5,14zM10,7H9v2H7v1h2v2h1v-2h2V9h-2z"/>
</vector>


================================================================================
FILE: app\src\main\res\drawable\ic_help_outline_24.xml
================================================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M11,18h2v-2h-2v2zM12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8zM12,6c-2.21,0 -4,1.79 -4,4h2c0,-1.1 0.9,-2 2,-2s2,0.9 2,2c0,2 -3,1.75 -3,5h2c0,-2.25 3,-2.5 3,-5 0,-2.21 -1.79,-4 -4,-4z"/>
    
</vector>



================================================================================
FILE: app\src\main\res\drawable\seekbar_custom_track.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- Background track -->
    <item android:id="@android:id/background">
        <shape android:shape="rectangle">
            <corners android:radius="4dp" /> <!-- Adjust for desired roundness -->
            <solid android:color="?attr/colorSurfaceVariant" />
            <size android:height="8dp" /> <!-- This is the THICKNESS of the track drawable -->
        </shape>
    </item>

    <!-- Progress track -->
    <item android:id="@android:id/progress">
        <scale android:scaleWidth="100%">
            <shape android:shape="rectangle">
                <corners android:radius="4dp" />
                <solid android:color="?attr/colorPrimary" />
                <size android:height="8dp" /> <!-- Must match background thickness -->
            </shape>
        </scale>
    </item>

    <!-- Secondary progress (optional, remove if not needed) -->
    <item android:id="@android:id/secondaryProgress">
        <scale android:scaleWidth="100%">
            <shape android:shape="rectangle">
                <corners android:radius="4dp"/>
                <solid android:color="@android:color/transparent"/> <!-- Or a muted color -->
                <size android:height="8dp"/>
            </shape>
        </scale>
    </item>
</layer-list>


================================================================================
FILE: app\src\main\res\drawable\popup_menu_background.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item>
        <shape android:shape="rectangle">
            <!-- This drawable is now primarily for the overall popup's shape, but its color is transparent -->
            <solid android:color="@android:color/transparent" /> <!-- Set to transparent -->
            <corners android:radius="12dp" />
            <!-- No stroke for the overall background -->
        </shape>
    </item>
</layer-list>


================================================================================
FILE: app\src\main\res\drawable\menu_item_background_transparent_dark.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_pressed="true">
        <shape android:shape="rectangle">
            <corners android:radius="8dp"/> <!-- Slightly rounded corners for items -->
            <solid android:color="@color/app_dark_gray"/> <!-- Solid dark gray when pressed/focused -->
        </shape>
    </item>
    <item android:state_focused="true">
        <shape android:shape="rectangle">
            <corners android:radius="8dp"/>
            <solid android:color="@color/app_dark_gray"/>
        </shape>
    </item>
    <item>
        <shape android:shape="rectangle">
            <corners android:radius="8dp"/>
            <solid android:color="@color/app_menu_item_background_semi_transparent"/> <!-- Semi-transparent dark for default state -->
        </shape>
    </item>
</selector>


================================================================================
FILE: app\src\main\res\values\strings.xml
================================================================================
<resources>
    <string name="app_name">Cue Dtat</string> <!-- Changed this for launcher -->
    <string name="app_display_title">Cue Dtat</string> <!-- New for in-app title -->
    <string name="zoom_icon">Zoom Icon</string>
    <string name="reset_view">Reset View</string>
    <!-- Removed toggle_help_lines as it's now in menu -->
    <string name="toggle_theme">Toggle Theme</string>
    <string name="zoom_cycle">Cycle Zoom</string>
    <string name="cue_d_tat">Cue Dtat</string>
    <string name="wtf_is_all_this">WTF is all this?</string>
    <string name="check_for_updates">Check for Updates</string> <!-- New string for the menu item -->
</resources>


================================================================================
FILE: app\src\main\res\values\colors.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme Colors -->
    <color name="app_yellow">#FCC506</color>
    <color name="app_black">#FF000000</color>
    <color name="app_white">#FFFFFFFF</color>
    <color name="app_dark_gray">#FF333333</color> <!-- A general dark gray for containers -->
    <color name="app_medium_gray">#725F5F</color> <!-- User's gray, can be tertiary -->
    <color name="app_light_gray_for_text_on_dark">#FFCCCCCC</color> <!-- For text on dark containers -->
    <color name="app_dark_yellow">#E5B205</color> <!-- A darker variant of the main yellow -->
    <color name="app_purple">#FF6200EE</color>

    <!-- Functional Colors -->
    <color name="app_error_red">#FF5252</color>

    <!-- Popup Menu Specific Colors -->
    <!-- This color is for the *overall* popup background if a drawable is used directly,
         but we'll set it to transparent in styles.xml for the outer popup. -->
    <color name="app_popup_background_dark_transparent">#D0000000</color> <!-- 80% translucent black -->
    <color name="app_popup_border_color">#40FFFFFF</color> <!-- Subtle white border for depth (removed from drawable but kept in case needed) -->
    <color name="app_popup_item_selected_light_yellow">#FFFAE0</color> <!-- Slightly lighter yellow for selected state -->
    <color name="app_popup_menu_text_default">@color/app_yellow</color> <!-- Default text color for menu items - set to yellow -->

    <!-- New color for semi-transparent menu item backgrounds -->
    <color name="app_menu_item_background_semi_transparent">#40000000</color> <!-- 25% opaque black -->

    <!-- Launcher Background Color -->
    <color name="ic_launcher_background">#070604</color>

    <!-- Original colors (can be removed if not referenced elsewhere) -->
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
</resources>


================================================================================
FILE: app\src\main\res\values\themes.xml
================================================================================
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Animation style for PopupMenu - MOVED HERE, ONLY DEFINED ONCE -->
    <style name="PopupMenuAnimation">
        <item name="android:windowEnterAnimation">@anim/popup_menu_enter</item>
        <item name="android:windowExitAnimation">@anim/popup_menu_exit</item>
    </style>

    <!-- Base application theme. - MOVED HERE, ONLY DEFINED ONCE -->
    <style name="Theme.PoolProtractor" parent="Theme.Material3.DayNight.NoActionBar">
        <!-- Primary brand color. These will be overridden by the Compose theme's colorScheme in MainActivity -->
        <item name="colorPrimary">@color/app_black</item>
        <item name="colorOnPrimary">@color/app_yellow</item>

        <!-- Secondary brand color. -->
        <item name="colorSecondary">@color/app_black</item>
        <item name="colorOnSecondary">@color/app_yellow</item>

        <!-- Tertiary color -->
        <item name="colorTertiary">@color/app_medium_gray</item>
        <item name="colorOnTertiary">@color/app_white</item>

        <!-- Container colors for FABs etc. -->
        <item name="colorPrimaryContainer">@color/app_dark_gray</item>
        <item name="colorOnPrimaryContainer">@color/app_yellow</item>
        <item name="colorSecondaryContainer">@color/app_dark_gray</item>
        <item name="colorOnSecondaryContainer">@color/app_yellow</item>
        <item name="colorTertiaryContainer">@color/app_medium_gray</item>
        <item name="colorOnTertiaryContainer">@color/app_white</item>

        <!-- Background/Surface colors -->
        <item name="android:colorBackground">@color/app_yellow</item>
        <item name="colorSurface">@color/app_yellow</item>
        <item name="colorOnSurface">@color/app_black</item>
        <item name="colorSurfaceVariant">@color/app_dark_yellow</item>
        <item name="colorOnSurfaceVariant">@color/app_black</item>

        <!-- Error colors -->
        <item name="colorError">@color/app_error_red</item>
        <item name="colorOnError">@color/app_black</item>
        <item name="colorErrorContainer">@color/app_error_red</item>
        <item name="colorOnErrorContainer">@color/app_black</item>

        <!-- Outline color -->
        <item name="colorOutline">@color/app_black</item>

        <!-- Status bar color. -->
        <item name="android:statusBarColor">@color/app_yellow</item>

        <!-- Custom PopupMenu style -->
        <item name="popupMenuStyle">@style/AppTheme.PopupMenu</item>
        <!-- Custom animation for the PopupMenu -->
        <item name="android:popupAnimationStyle">@style/PopupMenuAnimation</item>
    </style>
</resources>


================================================================================
FILE: app\src\main\res\values\styles.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Base application styles go here, if not in themes.xml -->

    <!-- Style for the custom PopupMenu -->
    <style name="AppTheme.PopupMenu" parent="Widget.Material3.PopupMenu">
        <!-- Overall popup background: set to transparent directly -->
        <item name="android:background">@android:color/transparent</item>
        <item name="android:popupBackground">@android:color/transparent</item>

        <!-- Item background: use the new semi-transparent drawable -->
        <item name="android:itemBackground">@drawable/menu_item_background_transparent_dark</item>

        <!-- Style for the individual menu items' text appearance -->
        <item name="android:itemTextAppearance">@style/AppTheme.TextAppearance.PopupMenu.Item</item>

        <!-- Optional: set elevation for a floating effect if needed, but background will handle visual depth -->
        <item name="android:elevation">8dp</item>

        <!-- No dividers -->
        <item name="android:dividerHeight">0dp</item>
        <item name="android:divider">@null</item>

        <!-- Ensure text color on surface is yellow, as defined in parent theme context -->
        <item name="colorOnSurface">@color/app_yellow</item>
    </style>

    <!-- Text appearance for PopupMenu items -->
    <style name="AppTheme.TextAppearance.PopupMenu.Item" parent="TextAppearance.AppCompat.Medium">
        <!-- Set the custom font -->
        <item name="android:fontFamily">@font/archivo_black_regular</item>
        <!-- Set the text color using a selector for different states -->
        <item name="android:textColor">@color/app_popup_menu_text_color_selector</item>
    </style>

</resources>


================================================================================
FILE: app\src\main\res\xml\backup_rules.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older than API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
<!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>


================================================================================
FILE: app\src\main\res\xml\data_extraction_rules.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>


================================================================================
FILE: app\src\main\res\xml\file_paths.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- Define external-files-path for downloading APKs to app-specific external storage -->
    <external-files-path name="updates" path="updates/" />
    <!-- Using "files-path" if you prefer internal storage:
    <files-path name="updates" path="updates/" />
    -->
</paths>


================================================================================
FILE: app\src\main\res\layout\activity_main.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/activity_main_root"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <androidx.camera.view.PreviewView
        android:id="@+id/cameraPreviewView"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

    <com.hereliesaz.cuedetat.view.MainOverlayView
        android:id="@+id/protractorOverlayView"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/controls_layout"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <FrameLayout
            android:id="@+id/appTitleContainer"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            android:layout_marginTop="16dp"
            android:layout_marginStart="16dp">

            <TextView
                android:id="@+id/appTitleTextView"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/cue_d_tat"
                android:textSize="48sp"
                android:textColor="@color/app_yellow"
                android:visibility="visible" />

            <ImageView
                android:id="@+id/appTitleLogoImageView"
                android:layout_width="wrap_content"
                android:layout_height="60dp"
                android:src="@drawable/logo_cue_detat"
                android:contentDescription="@string/app_name"
                android:visibility="gone"
                android:adjustViewBounds="true"
                android:scaleType="fitStart" />
        </FrameLayout>


        <androidx.constraintlayout.widget.ConstraintLayout
            android:id="@+id/zoomControlsLayout"
            android:layout_width="55dp"
            android:layout_height="486dp"
            android:layout_marginEnd="8dp"
            android:gravity="center_vertical"
            android:layoutMode="opticalBounds"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintHorizontal_bias="0.974"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintVertical_bias="0.497">

            <com.google.android.material.floatingactionbutton.FloatingActionButton
                android:id="@+id/zoomCycleButton"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:contentDescription="@string/zoom_cycle"
                android:src="@drawable/ic_zoom_in_24"
                app:backgroundTint="?attr/colorSecondaryContainer"
                app:fabSize="mini"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toTopOf="parent"
                app:tint="?attr/colorOnSecondaryContainer" />

            <SeekBar
                android:id="@+id/zoomSlider"
                android:layout_width="400dp"
                android:layout_height="25dp"
                android:layout_marginBottom="200dp"
                android:max="100"
                android:progress="50"
                android:progressDrawable="@drawable/seekbar_custom_track"
                android:rotation="90"
                android:thumbTint="?attr/colorPrimary"
                android:visibility="visible"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintHorizontal_bias="0.5"
                app:layout_constraintStart_toStartOf="parent" />

        </androidx.constraintlayout.widget.ConstraintLayout>

        <com.google.android.material.floatingactionbutton.FloatingActionButton
            android:id="@+id/resetButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginEnd="24dp"
            android:layout_marginBottom="24dp"
            android:contentDescription="@string/reset_view"
            android:src="@drawable/ic_undo_24"
            app:backgroundTint="?attr/colorPrimaryContainer"
            app:fabSize="mini"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:tint="?attr/colorOnPrimaryContainer" />

        <!-- helpButton removed -->

    </androidx.constraintlayout.widget.ConstraintLayout>

    <androidx.compose.ui.platform.ComposeView
        android:id="@+id/composeThemeView"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:visibility="gone" />

</FrameLayout>


================================================================================
FILE: app\src\main\res\mipmap-anydpi-v26\ic_launcher.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>


================================================================================
FILE: app\src\main\res\mipmap-anydpi-v26\ic_launcher_round.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>


================================================================================
FILE: app\src\main\res\menu\main_menu.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item
        android:id="@+id/action_check_for_updates"
        android:title="@string/check_for_updates" />
    <item
        android:id="@+id/action_toggle_help"
        android:title="@string/wtf_is_all_this" />
</menu>


================================================================================
FILE: app\src\main\res\anim\popup_menu_exit.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="150">
    <!-- Fade out -->
    <alpha
        android:fromAlpha="1.0"
        android:toAlpha="0.0" />
    <!-- Slide out to top (or to the direction of Gravity.END which is right in this case) -->
    <translate
        android:fromXDelta="0%"
        android:toXDelta="100%" />
    <scale
        android:fromXScale="1.0"
        android:toXScale="0.8"
        android:fromYScale="1.0"
        android:toYScale="0.8"
        android:pivotX="100%"
        android:pivotY="0%" />
</set>


================================================================================
FILE: app\src\main\res\anim\popup_menu_enter.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="200">
    <!-- Fade in -->
    <alpha
        android:fromAlpha="0.0"
        android:toAlpha="1.0" />
    <!-- Slide in from top (or from the direction of Gravity.END which is right in this case) -->
    <translate
        android:fromXDelta="100%"
        android:toXDelta="0%" />
    <scale
        android:fromXScale="0.8"
        android:toXScale="1.0"
        android:fromYScale="0.8"
        android:toYScale="1.0"
        android:pivotX="100%"
        android:pivotY="0%" />
</set>


================================================================================
FILE: app\src\main\res\color\app_popup_menu_text_color_selector.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- State when an item is pressed or focused -->
    <item android:state_pressed="true" android:color="@color/app_dark_gray"/>
    <item android:state_focused="true" android:color="@color/app_dark_gray"/>
    <!-- Default color for non-selected/unfocused items -->
    <item android:color="@color/app_popup_menu_text_default"/>
</selector>


================================================================================
FILE: app\src\main\AndroidManifest.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.hereliesaz.cuedetat">

    <!-- Permissions required for camera and sensors -->
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-feature android:name="android.hardware.camera.any" />
    <uses-feature android:name="android.hardware.sensor.gyroscope" android:required="false" />
    <uses-feature android:name="android.hardware.sensor.accelerometer" android:required="false" />
    <uses-feature android:name="android.hardware.sensor.compass" android:required="false" />
    <!-- Required for update checking and downloading from GitHub -->
    <uses-permission android:name="android.permission.INTERNET" />
    <!-- Required for installing APKs downloaded by the app (API 26+) -->
    <uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES" />

    <application
        android:name=".MyApplication"
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.PoolProtractor">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:screenOrientation="portrait"
            android:configChanges="uiMode|screenSize|smallestScreenSize|orientation" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <!-- FileProvider for sharing downloaded APK for installation -->
        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.fileprovider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths" />
        </provider>

    </application>

</manifest>


================================================================================
FILE: readme.md
================================================================================
# Cue Dtat - Pool Protractor & Aiming Assistant

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

## _"They'll never see it coming."_

**Cue Dtat** is an Android application designed to (ostensibly) help pool players visualize shot angles, make cut shots, understand the cue ball tangent, improve their geometric understanding of the game. Maybe get called a cheater, even though using this app is entirely legal. At the very least, get yourself a high-tech understanding of how bad you are at pool.

It uses your phone's camera and orientation sensors to overlay a dynamic protractor and aiming guide onto the real-world view of a pool table.

**(Warning: May induce an inflated sense of skill, followed by the crushing reality of physics. Use with a healthy dose of self-deprecating humor.)**

## Features

*   **Live Camera Overlay:** See the guides directly on your table view.
*   **Dynamic Protractor:**
    *   Visualizes common cut angles.
    *   Rotates with on-screen gestures (pan to rotate).
*   **Cue & Target Ball Representation:**
    *   Simulated "ghost balls" on a projected plane.
    *   Visual feedback for aiming path and potential collisions.
*   **Pitch-Adjusted Perspective:** The protractor plane tilts based on your phone's orientation, giving a pseudo-3D effect.
*   **Zoom Functionality:** Pinch to zoom in/out for a closer look or a wider view. Slider control with a stretched "zoomed-out" range for finer adjustments.
*   **Deflection / Sidespin Axis Lines:** Visualizes the tangent line and the resulting cue ball path if English (sidespin) were applied.
*   **Pocket Aiming Line:** A guide extending from the target ball to help line up with pockets.
*   **Informative (and sometimes Sarcastic) Text Helpers:**
    *   Labels for key lines and aiming points.
    *   Toggleable visibility for a cleaner view.
    *   Delightfully condescending warnings for invalid shot setups.
*   **Themed UI:** A sleek 8-ball aesthetic (Yellow, Black, White).

## Screenshots Placeholder

*   Pretend this is a screenshot.
*   This, too.
*   Imagine looking at a photo of the app in use.
*   Note the craft.
*   The flippant attitude towards detail.
*   I'm a genieaouxess.
*   And this is a photo from a vacation two years ago that I accidentally pretend included.



## How It Works: The Gore. The Details.

1.  **Camera Preview:** Uses CameraX to display a live feed from the device camera.
2.  **Sensor Input:** Leverages the `TYPE_ROTATION_VECTOR` sensor to determine the phone's pitch, roll, and yaw. The pitch is primarily used to tilt the 2D protractor plane. An offset is applied to account for natural phone holding angles.
3.  **Custom View (`ProtractorOverlayView`):** All guides and visual elements are drawn on a custom `View` that overlays the camera preview.
4.  **Drawing Logic:**
    *   **Protractor Plane:** A logical 2D plane is defined. Circles representing the cue and target ball positions, protractor angle lines, and deflection lines are drawn on this plane.
    *   **3D Projection (Simplified):** An `android.graphics.Camera` object is used to apply an X-axis rotation (based on phone pitch) to this logical plane, creating a 3D perspective effect. This transformed matrix is then applied to the canvas.
    *   **Ghost Balls:** Screen-space circles are drawn to represent the "3D" position of the cue and target balls. Their Y-offset from the projected plane centers is scaled by the sine of the pitch angle (raised to a power for a more pronounced effect) to simulate them floating above the plane.
    *   **Helper Text:** Text labels are drawn either on the (lifted) protractor plane or directly in screen space, with basic collision avoidance and dynamic sizing.
5.  **Gesture Handling:**
    *   `ScaleGestureDetector` for pinch-to-zoom.
    *   `MotionEvent` tracking for single-finger pan-to-rotate.
6.  **Theming:** Uses Jetpack Compose for Material 3 theming, with color values then passed to the custom view's `Paint` objects.

## Tech Stack & Libraries

*   **Kotlin**
*   **Android SDK**
*   **CameraX:** For camera preview.
*   **Android Sensors:** For device orientation.
*   **Custom View Drawing:** `Canvas` and `Paint` for all visual overlays.
*   **Jetpack Compose:** For Material 3 theming (colors applied to legacy View system).
*   **Google ML Kit:** For object detection (pool balls).
*   **Material Components for Android:** For UI elements like FABs and Seekbar.
*   **ConstraintLayout:** For UI layout.

## Setup & Build

1.  Clone the repository: `git clone https://github.com/hereliesaz/CueDetat.git`
2.  Open the project in Android Studio (latest stable version recommended).
3.  Ensure you have the necessary Android SDK Platforms and Build Tools installed.
4.  The project uses Gradle. Sync the project with Gradle files.
5.  Build and run on an Android device or emulator (API 26+).
    *   A device with a camera and rotation vector sensor is required for full functionality.

## Known Quirks & Future Delusions

*   **Text Collision Avoidance:** Current implementation is basic (first-drawn wins space).
*   **A Virtual Table for Virtually Useful Bank Shot Projection:** Using more sophisticated dynamic layout involving a line drawing of a billiards table will come someday.
*   **True 3D Rendering:** This app fakes 3D with 2D canvas tricks. Moving to OpenGL ES or a 3D engine like Filament would allow for actual 3D models and lighting, but would also drastically increase complexity. And probably anxiety. But probably not usefulness.
*   **Ball, Table and Pocket Detection:** The ultimate fantasy. Using ML Kit to detect the balls automatically. Table and pocket detection are future delusions.
*   **Insulting Warnings:** The pool of sarcastic remarks is finite. Contributions welcome if they tickle me the required level of pink.
*   **Performance:** Drawing many complex paths and text elements on every frame can be demanding. Optimizations are an ongoing battle. And yet, somehow, it feels more like a you-problem.

## Contributing

Found a bug? Have a suggestion for an even more cutting remark? Feel free to open an issue or submit a pull request. Please adhere to the existing coding style (or lack thereof, depending on the file you're looking at).

1.  Fork the Project
2.  Create your Feature Branch (`git checkout -b feature/AmazingFeature`)
3.  Commit your Changes (`git commit -m 'Add some AmazingFeature'`)
4.  Push to the Branch (`git push origin feature/AmazingFeature`)
5.  Open a Pull Request

## License

Distributed under the MIT License. Basically, completely free to use however you'd like, just gimme a shoutout. I make money making art. So, like this:
Cue Dtat by HereLiesAz (https://instagram.com/hereliesaz)

## Acknowledgments (Or Who to Blame)

*   The ghosts of pool players past whose missed shots inspired this.
*   The people I've tried to teach all these things.
*   Physics. And geometry. Where my hoes at?!

---

**_May your aim be truer than your excuses._**


================================================================================
FILE: build.gradle.kts
================================================================================
// PoolProtractor/build.gradle.kts
plugins {
    id("com.android.application") version "8.10.1" apply false
    id("org.jetbrains.kotlin.android") version "2.1.21" apply false
    // Do NOT add an 'android { ... }' block here.
    // This file is for global plugins and configuration, not Android-specific settings.
}

// These blocks are typically at the root level for all subprojects
// and should only contain repository declarations for dependencies
// and plugins that are NOT defined in settings.gradle.kts's pluginManagement.
// For modern Gradle, these are often empty or minimal if settings.gradle.kts is comprehensive.
/*allprojects {
    repositories {
        google()
        mavenCentral()
        // other repositories...
    }
}*/

// Correct way to define a clean task in Kotlin DSL at the root level
tasks.register("clean", Delete::class) {
    delete(layout.buildDirectory) // Use layout.buildDirectory
}


================================================================================
FILE: app/build.gradle.kts
================================================================================
// PoolProtractor/app/build.gradle.kts
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    alias(libs.plugins.kotlin.compose)
}

android {
    compileSdk = 36

    namespace = "com.hereliesaz.cuedetat" // Correct position
    buildToolsVersion = "36.0.0" // Correct position

    defaultConfig {
        applicationId = "com.hereliesaz.cuedetat"
        minSdk = 26
        targetSdk = 36
        versionCode = 3 // THIS IS YOUR APP'S CURRENT VERSION CODE
        versionName = "0.3.1" // THIS IS YOUR APP'S CURRENT VERSION NAME

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    // These blocks should be direct children of the 'android' block
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = "17"
    }

    buildFeatures {
        compose = true
        viewBinding = true
    }

    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.3"
    }

    // sourceSets block also belongs here, directly under 'android'
    sourceSets {
        getByName("main") {
            // Your custom source set configurations go here if any.
            // It should be empty if there are no custom source set configurations.
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = true
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
        }
    }
}

// The dependencies block *must* be outside the 'android' block,
// and directly within the 'app' module's build.gradle.kts file.
dependencies {
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.appcompat)
    implementation(libs.material)
    implementation(libs.androidx.constraintlayout)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.compose.ui.graphics)
    // CameraX dependencies (ensure these are up-to-date and compatible)
    implementation(libs.androidx.camera.core)
    implementation(libs.androidx.camera.camera2)
    implementation(libs.androidx.camera.lifecycle)
    implementation(libs.androidx.camera.view)

    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)

    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.kotlin.stdlib)

    implementation(libs.kotlinx.coroutines.guava)
    implementation(libs.androidx.foundation)
    implementation(libs.androidx.material3)
    implementation(platform(libs.androidx.compose.bom)) // Should only appear once for the BOM
    implementation(libs.androidx.ui)
    implementation(libs.androidx.activity.compose)

    implementation(libs.object1.detection) // ML Kit Object Detection Dependency

    // For GitHubUpdater - OkHttp for network requests, and JSON parsing
    implementation(libs.okhttp) // Using a recent stable version
    implementation(libs.json) // For JSONObject
}


================================================================================
FILE: settings.gradle.kts
================================================================================
pluginManagement {
  repositories {
    google {
      content {
        includeGroupByRegex("com\\.android.*")
        includeGroupByRegex("com\\.google.*")
        includeGroupByRegex("androidx.*")
      }
    }
    mavenCentral()
    gradlePluginPortal()
  }
  plugins {
    id("com.android.application") version "8.10.0"
    id("com.android.library") version "8.9.3"
    id("org.jetbrains.kotlin.android") version "2.1.20"
  }
}
dependencyResolutionManagement {
  repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
  repositories {
    google()
    mavenCentral()
  }
}

rootProject.name = "CueDetat"

include(":app")


