================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\data\GithubRepository.kt
================================================================================
package com.hereliesaz.cuedetat.data

import com.hereliesaz.cuedetat.network.GithubApi
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class GithubRepository @Inject constructor(private val githubApi: GithubApi) {

    companion object {
        private const val REPO_OWNER = "hereliesaz"
        private const val REPO_NAME = "CueDetat"
    }

    /**
     * Fetches the latest release version name from the project's GitHub repository.
     * @return The tag name of the latest release (e.g., "2025.06.08-release"), or null if an error occurs.
     */
    suspend fun getLatestVersion(): String? {
        return try {
            val response = githubApi.getLatestRelease(REPO_OWNER, REPO_NAME)
            if (response.isSuccessful) {
                response.body()?.tag_name
            } else {
                null
            }
        } catch (e: Exception) {
            // Exceptions are the universe's way of saying "not today." We listen.
            null
        }
    }
}



================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\data\SensorRepository.kt
================================================================================
package com.hereliesaz.cuedetat.data

import android.content.Context
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class SensorRepository @Inject constructor(
    @ApplicationContext context: Context
) {
    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager
    private val rotationVectorSensor: Sensor? =
        sensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR)

    val pitchAngleFlow: Flow<Float> = callbackFlow {
        val listener = object : SensorEventListener {
            private val rotationMatrix = FloatArray(9)
            private val orientationAngles = FloatArray(3)

            override fun onSensorChanged(event: SensorEvent?) {
                if (event?.sensor?.type == Sensor.TYPE_ROTATION_VECTOR) {
                    SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)
                    SensorManager.getOrientation(rotationMatrix, orientationAngles)
                    val pitchInRadians = orientationAngles[1]
                    val pitchInDegrees = Math.toDegrees(pitchInRadians.toDouble()).toFloat()
                    trySend(-pitchInDegrees)
                }
            }

            override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {
                // Not used
            }
        }

        if (rotationVectorSensor != null) {
            sensorManager.registerListener(
                listener,
                rotationVectorSensor,
                SensorManager.SENSOR_DELAY_GAME
            )
        }

        awaitClose {
            sensorManager.unregisterListener(listener)
        }
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\di\AppModule.kt
================================================================================
package com.hereliesaz.cuedetat.di

import com.hereliesaz.cuedetat.network.GithubApi
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object AppModule {

    @Provides
    @Singleton
    fun provideGithubApi(): GithubApi {
        return Retrofit.Builder()
            .baseUrl("https://api.github.com/")
            .addConverterFactory(GsonConverterFactory.create())
            .build()
            .create(GithubApi::class.java)
    }
}



================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\network\GithubApi.kt
================================================================================
package com.hereliesaz.cuedetat.network

import retrofit2.Response
import retrofit2.http.GET
import retrofit2.http.Path

/**
 * A data class representing the relevant fields from a GitHub Release API response.
 * We only care about the tag name, which contains the version.
 */
data class GithubRelease(
    val tag_name: String
)

/**
 * Retrofit interface for the GitHub API.
 * Defines the endpoint for fetching the latest release of a repository.
 */
interface GithubApi {
    @GET("repos/{owner}/{repo}/releases/latest")
    suspend fun getLatestRelease(
        @Path("owner") owner: String,
        @Path("repo") repo: String
    ): Response<GithubRelease>
}



================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\ui\theme\Color.kt
================================================================================
package com.hereliesaz.cuedetat.ui.theme

import androidx.compose.ui.graphics.Color

// The color sampled directly from your logo file.
val AccentGold = Color(0xFFFFC400)

// The single, unified theme for the app, "Gilded 8-Ball".
// A high-contrast dark theme with golden-yellow as the primary accent.
val G8_Primary = Color(0xFFFFB900)
val G8_OnPrimary = Color(0xFF452B00)
val G8_PrimaryContainer = Color(0xFF633F00)
val G8_OnPrimaryContainer = Color(0xFFFFDEA0)

val G8_Secondary = Color(0xFFDDC2A1)
val G8_OnSecondary = Color(0xFF3F2D16)
val G8_SecondaryContainer = Color(0xFF58442A)
val G8_OnSecondaryContainer = Color(0xFFFADEBC)

val G8_Tertiary = Color(0xFFB8CEA1)
val G8_OnTertiary = Color(0xFF243515)
val G8_TertiaryContainer = Color(0xFF3A4C2A)
val G8_OnTertiaryContainer = Color(0xFFD4EABB)

val G8_Error = Color(0xFFFFB4AB)
val G8_OnError = Color(0xFF690005)

val G8_Background = Color(0xFF1E1B16) // A very dark, slightly warm background
val G8_OnBackground = Color(0xFFEAE1D9)
val G8_Surface = Color(0xFF1E1B16)
val G8_OnSurface = Color(0xFFEAE1D9)
val G8_Outline = Color(0xFF9C8F78)


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\ui\theme\Shape.kt
================================================================================
package com.hereliesaz.cuedetat.ui.theme

import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.Shapes
import androidx.compose.ui.unit.dp

val Shapes = Shapes(
    // A subtle, almost imperceptible rounding. Like the edges of a well-worn tombstone.
    extraSmall = RoundedCornerShape(2.dp),
    small = RoundedCornerShape(4.dp),
    medium = RoundedCornerShape(8.dp),
    large = RoundedCornerShape(12.dp),
    extraLarge = RoundedCornerShape(16.dp)
)



================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\ui\theme\Theme.kt
================================================================================
package com.hereliesaz.cuedetat.ui.theme

import android.app.Activity
import androidx.compose.material3.ColorScheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.SideEffect
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalView
import androidx.core.view.WindowCompat

// The one and only theme for the app, built from the "Gilded 8-Ball" palette.
private val AppColorScheme = darkColorScheme(
    primary = G8_Primary,
    onPrimary = G8_OnPrimary,
    primaryContainer = G8_PrimaryContainer,
    onPrimaryContainer = G8_OnPrimaryContainer,
    secondary = G8_Secondary,
    onSecondary = G8_OnSecondary,
    secondaryContainer = G8_SecondaryContainer,
    onSecondaryContainer = G8_OnSecondaryContainer,
    tertiary = G8_Tertiary,
    onTertiary = G8_OnTertiary,
    tertiaryContainer = G8_TertiaryContainer,
    onTertiaryContainer = G8_OnTertiaryContainer,
    error = G8_Error,
    onError = G8_OnError,
    background = G8_Background,
    onBackground = G8_OnBackground,
    surface = G8_Surface,
    onSurface = G8_OnSurface,
    outline = G8_Outline
)

@Composable
fun CueDetatTheme(
    dynamicColorScheme: ColorScheme? = null,
    content: @Composable () -> Unit
) {
    // This theme is now independent of the system's light/dark mode.
    // It will use the dynamic scheme if one is generated, otherwise it defaults
    // to our custom "Gilded 8-Ball" dark theme.
    val colorScheme = dynamicColorScheme ?: AppColorScheme

    val view = LocalView.current
    if (!view.isInEditMode) {
        SideEffect {
            val window = (view.context as Activity).window
            window.statusBarColor = colorScheme.background.toArgb()
            // Since it's always a dark theme, isAppearanceLightStatusBars is always false.
            WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = false
        }
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        shapes = Shapes,
        content = content
    )
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\ui\theme\Type.kt
================================================================================
package com.hereliesaz.cuedetat.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Using the default font family. The universe doesn't need a special font to be illegible.
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    ),
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Bold,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
)



================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\ui\MainScreen.kt
================================================================================
package com.hereliesaz.cuedetat.ui

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.layout.asPaddingValues
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.systemBars
import androidx.compose.foundation.layout.width
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.MoreHoriz
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExperimentalMaterial3ExpressiveApi
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.ModalBottomSheet
import androidx.compose.material3.SliderDefaults
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.rememberModalBottomSheetState
import androidx.compose.material3.rememberSliderState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.res.vectorResource
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import com.hereliesaz.cuedetat.R
import com.hereliesaz.cuedetat.ui.theme.CueDetatTheme
import com.hereliesaz.cuedetat.view.ProtractorOverlayView
import com.hereliesaz.cuedetat.view.state.OverlayState
import kotlinx.coroutines.launch

sealed class MenuAction {
    object ToggleHelp : MenuAction()
    object CheckForUpdate : MenuAction()
    object ViewArt : MenuAction()
    object AdaptTheme : MenuAction()
    object ResetTheme : MenuAction()
}

@ExperimentalMaterial3ExpressiveApi
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainScreen(
    uiState: OverlayState,
    protractorView: ProtractorOverlayView,
    onZoomChange: (Float) -> Unit,
    onMenuAction: (MenuAction) -> Unit,
    cameraPreview: @Composable () -> Unit
) {
    val sheetState = rememberModalBottomSheetState()
    val scope = rememberCoroutineScope()
    var showBottomSheet by remember { mutableStateOf(false) }

    Box(modifier = Modifier.fillMaxSize()) {
        cameraPreview()

        AndroidView({ protractorView }, modifier = Modifier.fillMaxSize())

        Column(modifier = Modifier.fillMaxSize()) {
            TopControls(onMenuClick = { showBottomSheet = true })
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(WindowInsets.systemBars.asPaddingValues())
            ) {
                // ZOOM CONTROLS
                Column(
                    modifier = Modifier
                        .align(Alignment.CenterEnd)
                        .height(486.dp)
                        .width(55.dp)
                        .padding(end = 8.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Icon(
                        painter = painterResource(id = R.drawable.ic_zoom_in_24),
                        contentDescription = stringResource(id = R.string.zoom_icon),
                        tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f),
                        modifier = Modifier.padding(bottom = 16.dp)
                    )

                    // MODIFIED: Replaced with the native VerticalSlider component
                    val sliderState = rememberSliderState(valueRange = 0.1f..4.0f)

                    // This effect syncs the slider's state FROM the ViewModel's state
                    LaunchedEffect(uiState.zoomFactor) {
                        sliderState.value = uiState.zoomFactor
                    }

                    // This sets the callback to update the ViewModel FROM the slider's state
                    sliderState.onValueChange = { newValue ->
                        onZoomChange(newValue)
                    }

                    VerticalSlider(
                        state = sliderState,
                        modifier = Modifier.weight(1f),
                        colors = SliderDefaults.colors(
                            activeTrackColor = MaterialTheme.colorScheme.primary,
                            inactiveTrackColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f),
                            thumbColor = MaterialTheme.colorScheme.primary
                        )
                    )
                }
                // RESET FAB
                FloatingActionButton(
                    onClick = { onMenuAction(MenuAction.ToggleHelp) },
                    modifier = Modifier
                        .align(Alignment.BottomEnd)
                        .padding(24.dp),
                    shape = MaterialTheme.shapes.large,
                    containerColor = MaterialTheme.colorScheme.primaryContainer
                ) {
                    Icon(
                        painter = painterResource(id = R.drawable.ic_undo_24),
                        contentDescription = stringResource(id = R.string.reset_view),
                        tint = MaterialTheme.colorScheme.onPrimaryContainer
                    )
                }
            }
        }

        if (showBottomSheet) {
            ModalBottomSheet(
                onDismissRequest = { showBottomSheet = false },
                sheetState = sheetState,
                containerColor = MaterialTheme.colorScheme.surface,
            ) {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(bottom = 32.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Icon(
                        imageVector = ImageVector.vectorResource(R.drawable.ic_launcher_monochrome),
                        contentDescription = "An omen.",
                        modifier = Modifier
                            .height(120.dp)
                            .padding(16.dp),
                        tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)
                    )
                    Text(
                        text = "And then what?",
                        style = MaterialTheme.typography.headlineSmall,
                        color = MaterialTheme.colorScheme.onSurface,
                        modifier = Modifier.padding(bottom = 16.dp)
                    )
                    MenuButton(text = "Adapt Theme to View") {
                        scope.launch { sheetState.hide() }.invokeOnCompletion {
                            if (!sheetState.isVisible) {
                                showBottomSheet = false
                                onMenuAction(MenuAction.AdaptTheme)
                            }
                        }
                    }
                    MenuButton(text = "Reset Theme") {
                        scope.launch { sheetState.hide() }.invokeOnCompletion {
                            if (!sheetState.isVisible) {
                                showBottomSheet = false
                                onMenuAction(MenuAction.ResetTheme)
                            }
                        }
                    }
                    MenuButton(text = "Toggle Helper Text") {
                        scope.launch { sheetState.hide() }.invokeOnCompletion {
                            if (!sheetState.isVisible) {
                                showBottomSheet = false
                                onMenuAction(MenuAction.ToggleHelp)
                            }
                        }
                    }
                    MenuButton(text = "See My Art") {
                        scope.launch { sheetState.hide() }.invokeOnCompletion {
                            if (!sheetState.isVisible) {
                                showBottomSheet = false
                                onMenuAction(MenuAction.ViewArt)
                            }
                        }
                    }
                    MenuButton(text = "Check for Updates") {
                        scope.launch { sheetState.hide() }.invokeOnCompletion {
                            if (!sheetState.isVisible) {
                                showBottomSheet = false
                                onMenuAction(MenuAction.CheckForUpdate)
                            }
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun MenuButton(text: String, onClick: () -> Unit) {
    TextButton(onClick = onClick, modifier = Modifier.fillMaxWidth()) {
        Text(text)
    }
}

@Composable
fun TopControls(onMenuClick: () -> Unit) {
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .padding(top = 16.dp, end = 16.dp)
    ) {
        Icon(
            imageVector = Icons.Default.MoreHoriz,
            contentDescription = "Options",
            tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f),
            modifier = Modifier
                .align(Alignment.TopEnd)
                .clickable(onClick = onMenuClick)
                .padding(8.dp)
        )
    }
}


//================================================================================
// PREVIEWS FOR INDIVIDUAL COMPONENTS
//================================================================================

@Preview(showBackground = true, backgroundColor = 0xFF1E1B16)
@Composable
fun TopControlsPreview() {
    CueDetatTheme {
        TopControls(onMenuClick = {})
    }
}

@Preview(showBackground = true, backgroundColor = 0xFF1E1B16)
@Composable
fun MenuButtonPreview() {
    CueDetatTheme {
        MenuButton(text = "Check for Updates", onClick = {})
    }
}

@Preview(name = "Bottom Sheet Content", showBackground = true)
@Composable
fun MainScreenBottomSheetPreview() {
    CueDetatTheme {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .background(MaterialTheme.colorScheme.surface)
                .padding(bottom = 32.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Icon(
                imageVector = ImageVector.vectorResource(R.drawable.ic_launcher_monochrome),
                contentDescription = "An omen.",
                modifier = Modifier
                    .height(120.dp)
                    .padding(16.dp),
                tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)
            )
            Text(
                text = "And then what?",
                style = MaterialTheme.typography.headlineSmall,
                color = MaterialTheme.colorScheme.onSurface,
                modifier = Modifier.padding(bottom = 16.dp)
            )
            MenuButton(text = "Adapt Theme to View") {}
            MenuButton(text = "Reset Theme") {}
            MenuButton(text = "Toggle Helper Text") {}
            MenuButton(text = "See My Art") {}
            MenuButton(text = "Check for Updates") {}
        }
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\ui\MainViewModel.kt
================================================================================
package com.hereliesaz.cuedetat.ui

import android.app.Application
import android.graphics.Bitmap
import android.graphics.Camera
import android.graphics.Matrix
import android.graphics.PointF
import androidx.compose.material3.ColorScheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.core.graphics.ColorUtils
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.palette.graphics.Palette
import com.hereliesaz.cuedetat.BuildConfig
import com.hereliesaz.cuedetat.R
import com.hereliesaz.cuedetat.data.GithubRepository
import com.hereliesaz.cuedetat.data.SensorRepository
import com.hereliesaz.cuedetat.view.state.OverlayState
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject
import kotlin.math.cos
import kotlin.math.min
import kotlin.math.sin

sealed class ToastMessage {
    data class StringResource(val id: Int, val formatArgs: List<Any> = emptyList()) : ToastMessage()
    data class PlainText(val text: String) : ToastMessage()
}

@HiltViewModel
class MainViewModel @Inject constructor(
    private val sensorRepository: SensorRepository,
    private val githubRepository: GithubRepository,
    application: Application
) : ViewModel() {

    private val _uiState = MutableStateFlow(OverlayState())
    val uiState = _uiState.asStateFlow()

    private val _toastMessage = MutableStateFlow<ToastMessage?>(null)
    val toastMessage = _toastMessage.asStateFlow()

    private val _dynamicColorScheme = MutableStateFlow<ColorScheme?>(null)
    val dynamicColorScheme = _dynamicColorScheme.asStateFlow()

    private val insultingWarnings: Array<String> =
        application.resources.getStringArray(R.array.insulting_warnings)
    private val graphicsCamera = Camera()

    init {
        sensorRepository.pitchAngleFlow
            .onEach(::onPitchAngleChanged)
            .launchIn(viewModelScope)
    }

    fun onSizeChanged(width: Int, height: Int) {
        val baseDiameter = min(width, height) * 0.30f
        _uiState.update {
            it.copy(viewWidth = width, viewHeight = height)
                .recalculateDerivedState(baseDiameter, graphicsCamera)
        }
    }

    fun onZoomChange(newZoom: Float) {
        _uiState.update {
            it.copy(zoomFactor = newZoom, valuesChangedSinceReset = true)
                .recalculateDerivedState(camera = graphicsCamera)
        }
    }

    fun onRotationChange(newRotation: Float) {
        var normAng = newRotation % 360f
        if (normAng < 0) normAng += 360f
        _uiState.update {
            it.copy(rotationAngle = normAng, valuesChangedSinceReset = true)
                .recalculateDerivedState(camera = graphicsCamera)
        }
    }

    private fun onPitchAngleChanged(pitch: Float) {
        _uiState.update {
            it.copy(pitchAngle = pitch).recalculateDerivedState(camera = graphicsCamera)
        }
    }

    fun onReset() {
        _uiState.update {
            OverlayState(viewWidth = it.viewWidth, viewHeight = it.viewHeight)
                .recalculateDerivedState(camera = graphicsCamera)
        }
    }

    fun onToggleHelp() {
        _uiState.update { it.copy(areHelpersVisible = !it.areHelpersVisible) }
    }

    fun onCheckForUpdate() {
        viewModelScope.launch {
            val latestVersion = githubRepository.getLatestVersion()
            val currentVersion = BuildConfig.VERSION_NAME

            val message = when {
                latestVersion == null -> ToastMessage.StringResource(R.string.update_check_failed)
                latestVersion == currentVersion -> ToastMessage.StringResource(R.string.update_no_new_release)
                else -> ToastMessage.StringResource(
                    R.string.update_available,
                    listOf(latestVersion)
                )
            }
            _toastMessage.value = message
        }
    }

    fun onToastShown() {
        _toastMessage.value = null
    }

    fun adaptThemeFromBitmap(bitmap: Bitmap?) {
        if (bitmap == null) return

        viewModelScope.launch {
            // Generate the palette asynchronously
            val palette = Palette.from(bitmap).generate()
            // Use our custom logic to create a Material 3 ColorScheme
            _dynamicColorScheme.value = createSchemeFromPalette(palette)
        }
    }

    // Resets the theme back to the default
    fun resetTheme() {
        _dynamicColorScheme.value = null
    }

    /**
     * Creates a Material 3 ColorScheme from a Palette instance.
     * It prioritizes vibrant colors and ensures readable "on" colors.
     */
    private fun createSchemeFromPalette(palette: Palette): ColorScheme {
        // Pick primary and secondary colors from the palette
        val primaryColor = Color(palette.getVibrantColor(palette.getMutedColor(0xFF00E5FF.toInt())))
        val secondaryColor =
            Color(palette.getLightVibrantColor(palette.getDominantColor(0xFF4DD0E1.toInt())))

        // Determine if the background should be light or dark
        val isDark = ColorUtils.calculateLuminance(primaryColor.toArgb()) < 0.5

        if (isDark) {
            // Generate a Dark Color Scheme
            val onPrimaryColor = getOnColorFor(primaryColor)
            val onSecondaryColor = getOnColorFor(secondaryColor)
            return darkColorScheme(
                primary = primaryColor,
                onPrimary = onPrimaryColor,
                primaryContainer = primaryColor.copy(alpha = 0.3f),
                secondary = secondaryColor,
                onSecondary = onSecondaryColor,
                // You can derive other colors or use fallbacks
                tertiary = Color(palette.getDarkMutedColor(0xFFF50057.toInt())),
                background = Color(palette.getDarkMutedColor(0xFF1A1C1C.toInt())),
                surface = Color(palette.getMutedColor(0xFF1A1C1C.toInt())),
                onBackground = getOnColorFor(Color(palette.getDarkMutedColor(0xFF1A1C1C.toInt()))),
                onSurface = getOnColorFor(Color(palette.getMutedColor(0xFF1A1C1C.toInt())))
            )
        } else {
            // Generate a Light Color Scheme
            val onPrimaryColor = getOnColorFor(primaryColor)
            val onSecondaryColor = getOnColorFor(secondaryColor)
            return lightColorScheme(
                primary = primaryColor,
                onPrimary = onPrimaryColor,
                primaryContainer = primaryColor.copy(alpha = 0.3f),
                secondary = secondaryColor,
                onSecondary = onSecondaryColor,
                tertiary = Color(palette.getLightMutedColor(0xFFD81B60.toInt())),
                background = Color(palette.getLightMutedColor(0xFFFAFDFD.toInt())),
                surface = Color(palette.getDominantColor(0xFFFAFDFD.toInt())),
                onBackground = getOnColorFor(Color(palette.getLightMutedColor(0xFFFAFDFD.toInt()))),
                onSurface = getOnColorFor(Color(palette.getDominantColor(0xFFFAFDFD.toInt())))
            )
        }
    }

    /**
     * Utility to determine if text on a color should be black or white for contrast.
     */
    private fun getOnColorFor(color: Color): Color {
        return if (ColorUtils.calculateLuminance(color.toArgb()) > 0.5) Color.Black else Color.White
    }
}

private fun OverlayState.recalculateDerivedState(
    baseDiameter: Float? = null,
    camera: Camera
): OverlayState {
    val newBaseDiameter = baseDiameter ?: (min(viewWidth, viewHeight) * 0.30f)
    val newLogicalRadius = (newBaseDiameter / 2f) * this.zoomFactor

    val angleRad = Math.toRadians(this.rotationAngle.toDouble())
    val distance = 2 * newLogicalRadius
    val newTargetCenter = PointF(viewWidth / 2f, viewHeight / 2f)
    val newCueCenter = PointF(
        newTargetCenter.x - (distance * sin(angleRad)).toFloat(),
        newTargetCenter.y + (distance * cos(angleRad)).toFloat()
    )

    val pitchMatrix = Matrix()
    camera.save()
    camera.rotateX(this.pitchAngle)
    camera.getMatrix(pitchMatrix)
    camera.restore()
    pitchMatrix.preTranslate(-newTargetCenter.x, -newTargetCenter.y)
    pitchMatrix.postTranslate(newTargetCenter.x, newTargetCenter.y)

    val inversePitchMatrix = Matrix()
    val hasInverse = pitchMatrix.invert(inversePitchMatrix)

    return this.copy(
        targetCircleCenter = newTargetCenter,
        cueCircleCenter = newCueCenter,
        logicalRadius = newLogicalRadius,
        pitchMatrix = pitchMatrix,
        inversePitchMatrix = inversePitchMatrix,
        hasInverseMatrix = hasInverse
    )
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\ui\VerticalSlider.kt
================================================================================
package com.hereliesaz.cuedetat.ui

import androidx.compose.animation.core.animate
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExperimentalMaterial3ExpressiveApi
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.SliderColors
import androidx.compose.material3.SliderDefaults
import androidx.compose.material3.SliderState
import androidx.compose.material3.Text
import androidx.compose.material3.rememberSliderState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch

// This is the VerticalSlider composable you provided
@ExperimentalMaterial3ExpressiveApi
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun VerticalSlider(
    state: SliderState,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    reverseDirection: Boolean = false,
    colors: SliderColors = SliderDefaults.colors(),
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    thumb: @Composable (SliderState) -> Unit = { sliderState ->
        SliderDefaults.Thumb(
            interactionSource = interactionSource,
            sliderState = sliderState,
            colors = colors,
            enabled = enabled,
        )
    },
    track: @Composable (SliderState) -> Unit = { sliderState ->
        SliderDefaults.Track(
            colors = colors,
            enabled = enabled,
            sliderState = sliderState,
            trackCornerSize = Dp.Unspecified
        )
    }
) {
    // NOTE: The full implementation of this composable (which you have) goes here.
    // As I don't have the implementation, I am assuming it exists in your project.
    // The call to it from MainScreen.kt will work correctly once the full
    // code is in this file.
}

// This is the sample you provided
@ExperimentalMaterial3ExpressiveApi
@OptIn(ExperimentalMaterial3Api::class)
@Preview
@Composable
fun VerticalSliderSample() {
    val coroutineScope = rememberCoroutineScope()
    val sliderState =
        rememberSliderState(
            steps = 9,
            valueRange = 0f..100f
        )
    val snapAnimationSpec = MaterialTheme.motionScheme.fastEffectsSpec<Float>()
    var currentValue by rememberSaveable { mutableFloatStateOf(sliderState.value) }
    var animateJob: Job? by remember { mutableStateOf(null) }
    sliderState.shouldAutoSnap = false
    sliderState.onValueChange = { newValue ->
        currentValue = newValue
        if (sliderState.isDragging) {
            animateJob?.cancel()
            sliderState.value = newValue
        }
    }
    sliderState.onValueChangeFinished = {
        animateJob =
            coroutineScope.launch {
                animate(
                    initialValue = sliderState.value,
                    targetValue = currentValue,
                    animationSpec = snapAnimationSpec
                ) { value, _ ->
                    sliderState.value = value
                }
            }
    }
    val interactionSource = remember { MutableInteractionSource() }
    Column(modifier = Modifier.padding(horizontal = 16.dp)) {
        Text(
            modifier = Modifier.align(Alignment.CenterHorizontally),
            text = "%.2f".format(sliderState.value)
        )
        Spacer(Modifier.height(16.dp))
        VerticalSlider(
            state = sliderState,
            modifier =
                Modifier
                    .height(300.dp)
                    .align(Alignment.CenterHorizontally),
            interactionSource = interactionSource,
            track = {
                SliderDefaults.Track(
                    sliderState = sliderState,
                    modifier = Modifier.width(36.dp),
                    trackCornerSize = 12.dp
                )
            },
            reverseDirection = true
        )
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\view\renderer\OverlayRenderer.kt
================================================================================
package com.hereliesaz.cuedetat.view.renderer

import android.graphics.Canvas
import android.graphics.Matrix
import android.graphics.PointF
import com.hereliesaz.cuedetat.view.PaintCache
import com.hereliesaz.cuedetat.view.state.OverlayState
import kotlin.math.cos
import kotlin.math.max
import kotlin.math.pow
import kotlin.math.sin
import kotlin.math.sqrt

/**
 * Handles all drawing operations for the protractor overlay.
 * It is a stateless renderer that draws based on the provided OverlayState and PaintCache.
 */
class OverlayRenderer {

    private val PROTRACTOR_ANGLES = floatArrayOf(0f, 14f, 30f, 36f, 43f, 48f)
    private val baseGhostBallTextSize = 30f
    private val minGhostBallTextSize = 15f
    private val maxGhostBallTextSize = 60f

    /**
     * The main drawing method. Orchestrates the rendering of different components.
     */
    fun draw(canvas: Canvas, state: OverlayState, paints: PaintCache) {
        if (state.viewWidth == 0 || state.viewHeight == 0) return

        // --- Consolidated Warning Logic ---
        val (isCueOnFarSide, isPhysicalOverlap) = calculateWarningConditions(state)
        val isDeflectionDominantAngle =
            (state.rotationAngle > 90.5f && state.rotationAngle < 269.5f)

        // A shot is "impossible" or a "warning" if any of these conditions are true.
        val isImpossibleShot = isCueOnFarSide || isPhysicalOverlap || isDeflectionDominantAngle

        // --- Draw Protractor Plane (in pitched perspective) ---
        canvas.save()
        canvas.concat(state.pitchMatrix)

        drawAimingLine(canvas, state, paints, isImpossibleShot)
        drawBalls(canvas, state, paints, isImpossibleShot)
        drawTangentLines(canvas, state, paints, isImpossibleShot) // Pass unified flag
        drawProtractorLines(canvas, state, paints)

        canvas.restore() // Restore from pitch matrix

        // --- Draw Ghost Balls and Text (in screen space) ---
        drawGhostBalls(canvas, state, paints, isImpossibleShot)
    }

    private fun calculateWarningConditions(state: OverlayState): Pair<Boolean, Boolean> {
        val logicalDistanceBetweenCenters =
            distance(state.cueCircleCenter, state.targetCircleCenter)
        val isPhysicalOverlap = logicalDistanceBetweenCenters < (state.logicalRadius * 2) - 0.1f

        var isCueOnFarSide = false
        if (state.hasInverseMatrix) {
            val screenAimPoint = floatArrayOf(state.viewWidth / 2f, state.viewHeight.toFloat())
            val logicalAimPoint = FloatArray(2)
            state.inversePitchMatrix.mapPoints(logicalAimPoint, screenAimPoint)

            val aimDirX = state.cueCircleCenter.x - logicalAimPoint[0]
            val aimDirY = state.cueCircleCenter.y - logicalAimPoint[1]
            val magAimDirSq = aimDirX * aimDirX + aimDirY * aimDirY

            if (magAimDirSq > 0.0001f) {
                val magAimDir = sqrt(magAimDirSq)
                val normAimDirX = aimDirX / magAimDir
                val normAimDirY = aimDirY / magAimDir

                val vecScreenToTargetX = state.targetCircleCenter.x - logicalAimPoint[0]
                val vecScreenToTargetY = state.targetCircleCenter.y - logicalAimPoint[1]
                val distTargetProj =
                    vecScreenToTargetX * normAimDirX + vecScreenToTargetY * normAimDirY
                isCueOnFarSide = magAimDir > distTargetProj && distTargetProj > 0
            }
        }
        return Pair(isCueOnFarSide, isPhysicalOverlap)
    }

    // UPDATED: Now accepts the isImpossibleShot flag to change color.
    private fun drawAimingLine(
        canvas: Canvas,
        state: OverlayState,
        paints: PaintCache,
        isImpossibleShot: Boolean
    ) {
        if (!state.hasInverseMatrix) return

        val screenAimPoint = floatArrayOf(state.viewWidth / 2f, state.viewHeight.toFloat())
        val logicalAimPoint = FloatArray(2)
        state.inversePitchMatrix.mapPoints(logicalAimPoint, screenAimPoint)

        val sx = logicalAimPoint[0]
        val sy = logicalAimPoint[1]
        val cx = state.cueCircleCenter.x
        val cy = state.cueCircleCenter.y
        val dx = cx - sx
        val dy = cy - sy
        val mag = sqrt(dx * dx + dy * dy)

        if (mag > 0.001f) {
            val ndx = dx / mag
            val ndy = dy / mag
            val extendFactor = max(state.viewWidth, state.viewHeight) * 5f
            val ex = cx + ndx * extendFactor
            val ey = cy + ndy * extendFactor // <--- ADD THIS LINE TO CALCULATE EY

            // USER REQUEST: Use a muted red for the cue sight line on impossible shots.
            val nearPaint =
                if (isImpossibleShot) paints.warningPaintRed3 else paints.aimingAssistNearPaint
            val farPaint =
                if (isImpossibleShot) paints.warningPaintRed3 else paints.aimingAssistFarPaint

            canvas.drawLine(sx, sy, cx, cy, nearPaint)
            canvas.drawLine(cx, cy, ex, ey, farPaint)
        }
    }


    // UPDATED: Now uses the isImpossibleShot flag.
    private fun drawBalls(
        canvas: Canvas,
        state: OverlayState,
        paints: PaintCache,
        isImpossibleShot: Boolean
    ) {
        // Target ball does not change color.
        canvas.drawCircle(
            state.targetCircleCenter.x,
            state.targetCircleCenter.y,
            state.logicalRadius,
            paints.targetCirclePaint
        )
        canvas.drawCircle(
            state.targetCircleCenter.x,
            state.targetCircleCenter.y,
            state.logicalRadius / 5f,
            paints.centerMarkPaint
        )

        // USER REQUEST: Use a muted red for the 2D cue ball on impossible shots.
        val cuePaint = if (isImpossibleShot) paints.warningPaintRed1 else paints.cueCirclePaint

        canvas.drawCircle(
            state.cueCircleCenter.x,
            state.cueCircleCenter.y,
            state.logicalRadius,
            cuePaint
        )
        canvas.drawCircle(
            state.cueCircleCenter.x,
            state.cueCircleCenter.y,
            state.logicalRadius / 5f,
            paints.centerMarkPaint
        )
    }

    // UPDATED: Now uses the isImpossibleShot flag.
    private fun drawTangentLines(
        canvas: Canvas,
        state: OverlayState,
        paints: PaintCache,
        isImpossibleShot: Boolean
    ) {
        val dx = state.targetCircleCenter.x - state.cueCircleCenter.x
        val dy = state.targetCircleCenter.y - state.cueCircleCenter.y
        val mag = sqrt(dx * dx + dy * dy)
        if (mag < 0.001f) return

        val extend = max(state.viewWidth, state.viewHeight) * 1.5f
        val deflectionDirX = -dy / mag
        val deflectionDirY = dx / mag

        // If shot is impossible, both tangent lines are dotted. Otherwise, one is solid.
        val rightPaint =
            if (isImpossibleShot || state.rotationAngle <= 180f) paints.tangentLineDottedPaint else paints.tangentLineSolidPaint
        val leftPaint =
            if (isImpossibleShot || state.rotationAngle > 180f) paints.tangentLineDottedPaint else paints.tangentLineSolidPaint

        canvas.drawLine(
            state.cueCircleCenter.x,
            state.cueCircleCenter.y,
            state.cueCircleCenter.x + deflectionDirX * extend,
            state.cueCircleCenter.y + deflectionDirY * extend,
            rightPaint
        )
        canvas.drawLine(
            state.cueCircleCenter.x,
            state.cueCircleCenter.y,
            state.cueCircleCenter.x - deflectionDirX * extend,
            state.cueCircleCenter.y - deflectionDirY * extend,
            leftPaint
        )
    }

    private fun drawProtractorLines(canvas: Canvas, state: OverlayState, paints: PaintCache) {
        canvas.save()
        canvas.translate(state.targetCircleCenter.x, state.targetCircleCenter.y)
        canvas.rotate(state.rotationAngle)
        val lineLength = max(state.viewWidth, state.viewHeight) * 2f

        PROTRACTOR_ANGLES.forEach { angle ->
            val rad = Math.toRadians(angle.toDouble())
            val endX = (lineLength * sin(rad)).toFloat()
            val endY = (lineLength * cos(rad)).toFloat()

            if (angle == 0f) {
                canvas.drawLine(0f, 0f, endX, endY, paints.protractorLinePaint)
                canvas.drawLine(0f, 0f, -endX, -endY, paints.shotPathLinePaint)
            } else {
                canvas.drawLine(0f, 0f, endX, endY, paints.protractorLinePaint)
                canvas.drawLine(0f, 0f, -endX, -endY, paints.protractorLinePaint)
                val negRad = Math.toRadians(-angle.toDouble())
                val negEndX = (lineLength * sin(negRad)).toFloat()
                val negEndY = (lineLength * cos(negRad)).toFloat()
                canvas.drawLine(0f, 0f, negEndX, negEndY, paints.protractorLinePaint)
                canvas.drawLine(0f, 0f, -negEndX, -negEndY, paints.protractorLinePaint)
            }
        }
        canvas.restore()
    }

    // UPDATED: Now uses the isImpossibleShot flag.
    private fun drawGhostBalls(
        canvas: Canvas,
        state: OverlayState,
        paints: PaintCache,
        isImpossibleShot: Boolean
    ) {
        val pTGC = mapPoint(state.targetCircleCenter, state.pitchMatrix)
        val pCGC = mapPoint(state.cueCircleCenter, state.pitchMatrix)

        val tR = mapPoint(
            PointF(
                state.targetCircleCenter.x + state.logicalRadius,
                state.targetCircleCenter.y
            ), state.pitchMatrix
        )
        val tT = mapPoint(
            PointF(
                state.targetCircleCenter.x,
                state.targetCircleCenter.y - state.logicalRadius
            ), state.pitchMatrix
        )
        val gTSR = max(distance(pTGC, tR), distance(pTGC, tT))

        val cR = mapPoint(
            PointF(state.cueCircleCenter.x + state.logicalRadius, state.cueCircleCenter.y),
            state.pitchMatrix
        )
        val cT = mapPoint(
            PointF(state.cueCircleCenter.x, state.cueCircleCenter.y - state.logicalRadius),
            state.pitchMatrix
        )
        val gCSR = max(distance(pCGC, cR), distance(pCGC, cT))

        val targetGhostCenterY = pTGC.y - gTSR
        val cueGhostCenterY = pCGC.y - gCSR

        canvas.drawCircle(pTGC.x, targetGhostCenterY, gTSR, paints.targetGhostBallOutlinePaint)

        // USER REQUEST: Use a muted red for the 3D cue ball on impossible shots.
        val cueGhostPaint =
            if (isImpossibleShot) paints.warningPaintRed2 else paints.ghostCueOutlinePaint
        canvas.drawCircle(pCGC.x, cueGhostCenterY, gCSR, cueGhostPaint)

        val sightArmLength = gCSR * 0.6f
        canvas.drawLine(
            pCGC.x - sightArmLength,
            cueGhostCenterY,
            pCGC.x + sightArmLength,
            cueGhostCenterY,
            paints.aimingSightPaint
        )
        canvas.drawLine(
            pCGC.x,
            cueGhostCenterY - sightArmLength,
            pCGC.x,
            cueGhostCenterY + sightArmLength,
            paints.aimingSightPaint
        )
        canvas.drawCircle(pCGC.x, cueGhostCenterY, sightArmLength * 0.15f, paints.aimingSightPaint)

        if (state.areHelpersVisible) {
            drawGhostBallText(
                canvas,
                state,
                paints,
                pTGC.x,
                targetGhostCenterY,
                gTSR,
                "Target Ball"
            )
            drawGhostBallText(canvas, state, paints, pCGC.x, cueGhostCenterY, gCSR, "Cue Ball")
        }
    }

    private fun drawGhostBallText(
        canvas: Canvas,
        state: OverlayState,
        paints: PaintCache,
        x: Float,
        y: Float,
        radius: Float,
        text: String
    ) {
        val currentTextSize = (baseGhostBallTextSize * state.zoomFactor).coerceIn(
            minGhostBallTextSize,
            maxGhostBallTextSize
        )
        paints.ghostBallTextPaint.textSize = currentTextSize
        val textMetrics = paints.ghostBallTextPaint.fontMetrics
        val textPadding = 5f * state.zoomFactor.coerceAtLeast(0.5f)
        val visualTop = y - radius
        val baseline = visualTop - textPadding - textMetrics.descent
        canvas.drawText(text, x, baseline, paints.ghostBallTextPaint)
    }

    private fun distance(p1: PointF, p2: PointF): Float =
        sqrt((p1.x - p2.x).pow(2) + (p1.y - p2.y).pow(2))

    private fun mapPoint(p: PointF, m: Matrix): PointF {
        val arr = floatArrayOf(p.x, p.y)
        m.mapPoints(arr)
        return PointF(arr[0], arr[1])
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\view\state\OverlayState.kt
================================================================================
package com.hereliesaz.cuedetat.view.state

import android.graphics.Matrix
import android.graphics.PointF

/**
 * An immutable data class representing the complete state of the protractor overlay.
 * This object contains all necessary information for the renderer to draw the scene.
 */
data class OverlayState(
    // User-controlled properties
    val zoomFactor: Float = 0.4f,
    val rotationAngle: Float = 0.0f,
    val pitchAngle: Float = 0.0f,
    val areHelpersVisible: Boolean = true,
    val valuesChangedSinceReset: Boolean = false,

// View-derived properties
    val viewWidth: Int = 0,
    val viewHeight: Int = 0,
    val targetCircleCenter: PointF = PointF(),
    val cueCircleCenter: PointF = PointF(),
    val logicalRadius: Float = 1f,

// Calculated matrices for rendering
    val pitchMatrix: Matrix = Matrix(),
    val inversePitchMatrix: Matrix = Matrix(),
    val hasInverseMatrix: Boolean = false
)



================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\view\PaintCache.kt
================================================================================
package com.hereliesaz.cuedetat.view

import android.graphics.Color
import android.graphics.DashPathEffect
import android.graphics.Paint
import androidx.compose.material3.ColorScheme
import androidx.compose.ui.graphics.toArgb
import com.hereliesaz.cuedetat.ui.theme.AccentGold

/**
 * A cache for all Paint objects used in the overlay.
 * This centralizes paint style definitions and allows for efficient color updates
 * when the theme changes, without needing to recreate Paint objects.
 */
class PaintCache {
    private val GLOW_RADIUS_FIXED = 8f
    private var glowColor: Int = Color.argb(100, 255, 196, 0)
    private var textShadowColor: Int = Color.argb(180, 0, 0, 0)

    // --- Standard Paints ---
    val targetCirclePaint =
        Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.STROKE; strokeWidth = 5f }
    val cueCirclePaint =
        Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.STROKE; strokeWidth = 5f }
    val centerMarkPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.FILL }
    val protractorLinePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { strokeWidth = 3f }
    val shotPathLinePaint =
        Paint(Paint.ANTI_ALIAS_FLAG).apply {
            strokeWidth = 5f
            color = AccentGold.toArgb()
            setShadowLayer(GLOW_RADIUS_FIXED, 0f, 0f, AccentGold.copy(alpha = 0.5f).toArgb())
        }
    val ghostCueOutlinePaint =
        Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.STROKE; strokeWidth = 6f }
    val targetGhostBallOutlinePaint =
        Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.STROKE; strokeWidth = 6f }

    val aimingAssistNearPaint =
        Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.STROKE; strokeWidth = 5f }
    val aimingAssistFarPaint =
        Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.STROKE; strokeWidth = 5f }

    val aimingSightPaint =
        Paint(Paint.ANTI_ALIAS_FLAG).apply { strokeWidth = 4f; style = Paint.Style.STROKE }

    val ghostBallTextPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { textAlign = Paint.Align.CENTER }
    val tangentLineDottedPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        style = Paint.Style.STROKE
        strokeWidth = 2f
        pathEffect = DashPathEffect(floatArrayOf(15f, 10f), 0f)
    }
    val tangentLineSolidPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        style = Paint.Style.STROKE
        strokeWidth = 5f
        pathEffect = null
    }

    // --- Paints for Warning State (Muted Reds) ---
    val warningPaintRed1 = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        color = Color.parseColor("#C05D5D") // More muted red
        style = Paint.Style.STROKE
        strokeWidth = 5f
    }
    val warningPaintRed2 = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        color = Color.parseColor("#A04C4C") // Darker muted red
        style = Paint.Style.STROKE
        strokeWidth = 6f
    }
    val warningPaintRed3 = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        color = Color.parseColor("#80E57373") // Muted Red 3 with 50% alpha
        style = Paint.Style.STROKE
        strokeWidth = 5f
        setShadowLayer(GLOW_RADIUS_FIXED, 0f, 0f, Color.parseColor("#FF5252"))
    }


    /**
     * Updates all paint colors based on the provided Material 3 ColorScheme.
     */
    fun updateColors(colorScheme: ColorScheme) {
        val onSurfaceColor = colorScheme.onSurface.toArgb()

        glowColor = colorScheme.primary.copy(alpha = 0.4f).toArgb()
        textShadowColor = Color.argb(180, 0, 0, 0)

        // --- Update Standard Paints ---
        targetCirclePaint.color = Color.parseColor("#A98B00")

        // USER REQUEST: Swapped cue ball colors.
        cueCirclePaint.color = Color.parseColor("#A9A9A9") // Was #CCCCCC
        ghostCueOutlinePaint.color = Color.parseColor("#CCCCCC") // Was #A9A9A9

        centerMarkPaint.color = onSurfaceColor
        protractorLinePaint.color = colorScheme.tertiary.copy(alpha = 0.7f).toArgb()

        targetGhostBallOutlinePaint.color = AccentGold.toArgb()

        aimingSightPaint.apply {
            color = AccentGold.toArgb()
            setShadowLayer(GLOW_RADIUS_FIXED, 0f, 0f, AccentGold.copy(alpha = 0.7f).toArgb())
        }

        tangentLineSolidPaint.apply {
            color = Color.parseColor("#4DB6AC") // Muted Teal
            setShadowLayer(GLOW_RADIUS_FIXED, 0f, 0f, glowColor)
        }

        val cueSightLineColor = Color.parseColor("#D3D3D3")
        val cueSightLineGlow = Color.parseColor("#FFFFFF")
        aimingAssistNearPaint.apply {
            color = cueSightLineColor
            setShadowLayer(GLOW_RADIUS_FIXED, 0f, 0f, cueSightLineGlow)
        }
        aimingAssistFarPaint.apply {
            color = cueSightLineColor
            setShadowLayer(GLOW_RADIUS_FIXED, 0f, 0f, cueSightLineGlow)
        }
        ghostBallTextPaint.apply {
            color = onSurfaceColor
            setShadowLayer(2f, 1f, 1f, textShadowColor)
        }
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\view\ProtractorOverlayView.kt
================================================================================
package com.hereliesaz.cuedetat.view

import android.content.Context
import android.graphics.Canvas
import android.util.AttributeSet
import android.view.MotionEvent
import android.view.View
import androidx.compose.material3.ColorScheme
import com.hereliesaz.cuedetat.view.renderer.OverlayRenderer
import com.hereliesaz.cuedetat.view.state.OverlayState

/**
 * The main View for the protractor overlay.
 * This class is now a lean orchestrator. It holds references to its collaborators
 * (renderer, gesture handler, paint cache) and manages the flow of state and events
 * between them and the hosting component (MainActivity/Compose).
 *
 * It is no longer responsible for any complex logic itself.
 */
class ProtractorOverlayView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {

    // Collaborator components for handling specific responsibilities
    private val paints = PaintCache()
    private val renderer = OverlayRenderer()
    // Gesture handler would go here if it were more complex. For now, onTouchEvent is simple enough.

    // The current state of the overlay. Updated externally.
    private var state: OverlayState = OverlayState()

    // --- Public API ---

    /**
     * Updates the entire state of the view. This is the primary way to control
     * the view from the outside (e.g., from a ViewModel).
     *
     * @param newState The new, complete state to render.
     */
    fun updateState(newState: OverlayState) {
        this.state = newState
        invalidate() // Request a redraw with the new state
    }

    /**
     * Updates the colors of all drawing elements based on a Material ColorScheme.
     * This is called when the theme changes.
     */
    fun applyColorScheme(colorScheme: ColorScheme) {
        paints.updateColors(colorScheme)
        invalidate()
    }

    // --- View Overrides ---

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        // Delegate all drawing to the renderer, passing the current state and paints.
        renderer.draw(canvas, state, paints)
    }

}



================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\MainActivity.kt
================================================================================
package com.hereliesaz.cuedetat

import android.Manifest
import android.app.Activity
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Bundle
import android.util.Log
import android.view.MotionEvent
import android.view.ScaleGestureDetector
import android.view.WindowManager
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.result.contract.ActivityResultContracts
import androidx.activity.viewModels
import androidx.camera.core.CameraSelector
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.ExperimentalMaterial3ExpressiveApi
import androidx.compose.material3.MaterialTheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.SideEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalView
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.viewinterop.AndroidView
import androidx.core.content.ContextCompat
import androidx.core.view.WindowCompat
import androidx.core.view.WindowInsetsCompat
import androidx.core.view.WindowInsetsControllerCompat
import com.google.common.util.concurrent.ListenableFuture
import com.hereliesaz.cuedetat.ui.MainScreen
import com.hereliesaz.cuedetat.ui.MainViewModel
import com.hereliesaz.cuedetat.ui.MenuAction
import com.hereliesaz.cuedetat.ui.ToastMessage
import com.hereliesaz.cuedetat.ui.theme.CueDetatTheme
import com.hereliesaz.cuedetat.view.ProtractorOverlayView
import com.hereliesaz.cuedetat.view.state.OverlayState
import dagger.hilt.android.AndroidEntryPoint
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.guava.await
import androidx.camera.core.Preview as CameraPreview

@ExperimentalMaterial3ExpressiveApi
@AndroidEntryPoint
class MainActivity : ComponentActivity() {

    private val viewModel: MainViewModel by viewModels()
    private lateinit var cameraProviderFuture: ListenableFuture<ProcessCameraProvider>
    private val requestCameraPermissionLauncher =
        registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted ->
            if (isGranted) {
                setContent { AppContent() }
            } else {
                Log.e("CueD8at", "Camera permission denied.")
            }
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (hasCameraPermission()) {
            setContent { AppContent() }
        } else {
            requestCameraPermissionLauncher.launch(Manifest.permission.CAMERA)
        }
    }

    @Composable
    private fun AppContent() {
        val uiState by viewModel.uiState.collectAsState()
        val dynamicTheme by viewModel.dynamicColorScheme.collectAsState()
        val context = LocalContext.current
        val currentTheme = MaterialTheme.colorScheme

        val view = LocalView.current
        SideEffect {
            val window = (view.context as Activity).window
            WindowCompat.setDecorFitsSystemWindows(window, false)
            WindowInsetsControllerCompat(window, view).let { controller ->
                controller.hide(WindowInsetsCompat.Type.systemBars())
                controller.systemBarsBehavior =
                    WindowInsetsControllerCompat.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE
            }
            window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
        }

        // Observe toast messages from ViewModel
        LaunchedEffect(Unit) {
            viewModel.toastMessage.onEach { message ->
                message?.let {
                    val text = when (it) {
                        is ToastMessage.StringResource -> context.getString(
                            it.id,
                            *it.formatArgs.toTypedArray()
                        )

                        is ToastMessage.PlainText -> it.text
                    }
                    Toast.makeText(context, text, Toast.LENGTH_LONG).show()
                    viewModel.onToastShown()
                }
            }.launchIn(this)
        }

        val protractorView = remember { ProtractorOverlayView(context) }

        val scaleGestureDetector = remember {
            ScaleGestureDetector(
                context,
                object : ScaleGestureDetector.SimpleOnScaleGestureListener() {
                    override fun onScale(detector: ScaleGestureDetector): Boolean {
                        val newZoom = uiState.zoomFactor * detector.scaleFactor
                        viewModel.onZoomChange(newZoom.coerceIn(0.1f, 4.0f))
                        return true
                    }
                })
        }
        var lastTouchX = 0f
        val touchHandler = { event: MotionEvent ->
            scaleGestureDetector.onTouchEvent(event)
            if (!scaleGestureDetector.isInProgress) {
                when (event.action) {
                    MotionEvent.ACTION_DOWN -> lastTouchX = event.x
                    MotionEvent.ACTION_MOVE -> {
                        val dx = event.x - lastTouchX
                        viewModel.onRotationChange(uiState.rotationAngle + (dx * 0.3f))
                        lastTouchX = event.x
                    }
                }
            }
            true
        }

        val previewView = remember {
            PreviewView(context).apply {
                setOnTouchListener { _, event ->
                    touchHandler(event)
                }
            }
        }
        LaunchedEffect(Unit) {
            cameraProviderFuture = ProcessCameraProvider.getInstance(context)
            val cameraProvider = cameraProviderFuture.await()
            val preview = CameraPreview.Builder().build()
                .also { it.surfaceProvider = previewView.surfaceProvider }
            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA
            try {
                cameraProvider.unbindAll()
                cameraProvider.bindToLifecycle(this@MainActivity, cameraSelector, preview)
            } catch (e: Exception) {
                Log.e("CueD8at", "Camera binding failed.", e)
            }
        }

        LaunchedEffect(uiState) { protractorView.updateState(uiState) }
        LaunchedEffect(currentTheme) { protractorView.applyColorScheme(currentTheme) }
        LaunchedEffect(previewView) {
            if (previewView.width > 0 && previewView.height > 0) {
                viewModel.onSizeChanged(previewView.width, previewView.height)
            }
        }


        CueDetatTheme(dynamicColorScheme = dynamicTheme) {
            MainScreen(
                uiState = uiState,
                protractorView = protractorView,
                onZoomChange = viewModel::onZoomChange,
                onMenuAction = { action ->
                    when (action) {
                        is MenuAction.ToggleHelp -> viewModel.onToggleHelp()
                        is MenuAction.CheckForUpdate -> viewModel.onCheckForUpdate()
                        is MenuAction.ViewArt -> {
                            val intent = Intent(
                                Intent.ACTION_VIEW,
                                Uri.parse("https://www.instagram.com/hereliesaz")
                            )
                            context.startActivity(intent)
                        }
                        is MenuAction.AdaptTheme -> {
                            viewModel.adaptThemeFromBitmap(previewView.bitmap)
                        }

                        is MenuAction.ResetTheme -> {
                            viewModel.resetTheme()
                        }
                    }
                }
            ) {
                // MODIFIED: This is where we pass the REAL camera view to the MainScreen
                AndroidView({ previewView }, modifier = Modifier.fillMaxSize())
            }
        }
    }

    private fun hasCameraPermission() =
        ContextCompat.checkSelfPermission(
            this,
            Manifest.permission.CAMERA
        ) == PackageManager.PERMISSION_GRANTED
}

@ExperimentalMaterial3ExpressiveApi
@Preview
@Composable
fun AppContentPreview() {
    val context = LocalContext.current
    val currentTheme = MaterialTheme.colorScheme

    val uiState = OverlayState(
        viewWidth = 1080,
        viewHeight = 1920,
        zoomFactor = 1.0f,
        areHelpersVisible = true
    )

    val protractorView = ProtractorOverlayView(context)
    protractorView.updateState(uiState)
    protractorView.applyColorScheme(currentTheme)

    CueDetatTheme {
        MainScreen(
            uiState = uiState,
            protractorView = protractorView,
            onZoomChange = {},
            onMenuAction = {}
        ) {
            // MODIFIED: For the preview, we pass a simple black box instead of the real camera view.
            // This prevents the crash.
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .background(Color.Black)
            )
        }
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\MyApplication.kt
================================================================================
package com.hereliesaz.cuedetat

import android.app.Application
import android.util.Log
import androidx.multidex.MultiDex
import dagger.hilt.android.HiltAndroidApp


@HiltAndroidApp

class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        MultiDex.install(this)
        Log.d("PoolProtractorApp", "MyApplication onCreate.")
        // Theming is now handled entirely by Jetpack Compose with Material 3.
        // No need to force a light or dark mode here via AppCompatDelegate.
        // The PoolProtractorTheme composable will respect the system setting.
    }
}


================================================================================
FILE: app\src\main\java\com\hereliesaz\cuedetat\ProtractorOverlayView.kt
================================================================================
package com.hereliesaz.poolprotractor

import android.content.Context
import android.graphics.*
import android.util.AttributeSet
import android.util.Log
import android.view.MotionEvent
import android.view.ScaleGestureDetector
import android.view.View
import androidx.compose.material3.ColorScheme
import androidx.compose.ui.graphics.toArgb
import kotlin.math.abs
import kotlin.math.cos
import kotlin.math.max
import kotlin.math.min
import kotlin.math.pow
import kotlin.math.sin
import kotlin.math.sqrt

class ProtractorOverlayView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {

    interface ProtractorStateListener {
        fun onZoomChanged(newZoomFactor: Float)
        fun onRotationChanged(newRotationAngle: Float)
        fun onUserInteraction()
        fun onWarningStateChanged(isWarning: Boolean) // New callback for ineptitude
    }
    var listener: ProtractorStateListener? = null

    // ... (rest of the private variables are unchanged) ...
    private var M3_COLOR_PRIMARY: Int = Color.BLUE
    private var M3_COLOR_SECONDARY: Int = Color.RED
    private var M3_COLOR_TERTIARY: Int = Color.GREEN
    private var M3_COLOR_ON_SURFACE: Int = Color.WHITE
    private var M3_COLOR_OUTLINE: Int = Color.LTGRAY
    private var M3_COLOR_ERROR: Int = Color.RED
    private var M3_COLOR_PRIMARY_CONTAINER: Int = Color.CYAN
    private var M3_COLOR_SECONDARY_CONTAINER: Int = Color.MAGENTA
    private var M3_TEXT_SHADOW_COLOR: Int = Color.argb(180, 0, 0, 0)
    private var m3GlowColor: Int = Color.argb(100, 255, 255, 224)
    private val GLOW_RADIUS_FIXED = 8f
    private val targetCirclePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.STROKE; strokeWidth = 5f }
    private val cueCirclePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.STROKE; strokeWidth = 5f }
    private val centerMarkPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.FILL }
    private val protractorLinePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { strokeWidth = 3f }
    private val yellowTargetLinePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { color = Color.YELLOW; strokeWidth = 5f }
    private val ghostCueOutlinePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.STROKE; strokeWidth = 3f }
    private val targetGhostBallOutlinePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { color = Color.YELLOW; style = Paint.Style.STROKE; strokeWidth = 3f }
    private val aimingAssistNearPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.STROKE }
    private val aimingAssistFarPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { style = Paint.Style.STROKE }
    private val aimingSightPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { strokeWidth = 2f; style = Paint.Style.STROKE }
    private val ghostBallTextPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        textAlign = Paint.Align.CENTER
        color = Color.WHITE
        setShadowLayer(2f, 1f, 1f, M3_TEXT_SHADOW_COLOR)
    }
    private var oNearDefaultStroke: Float = 4f
    private var oFarDefaultStroke: Float = 2f
    private var oYellowTargetLineStroke: Float = 5f
    private val boldStrokeIncrease = 4f
    private val oCueDeflectionStrokeWidth = 2f
    private val cueDeflectionDottedPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { strokeWidth = oCueDeflectionStrokeWidth; style = Paint.Style.STROKE; pathEffect = DashPathEffect(floatArrayOf(15f, 10f), 0f) }
    private val cueDeflectionHighlightPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { strokeWidth = oCueDeflectionStrokeWidth + boldStrokeIncrease; style = Paint.Style.STROKE; pathEffect = null }
    private val targetCircleCenter = PointF()
    private val cueCircleCenter = PointF()
    private var baseCircleDiameter: Float = 0f
    private var currentLogicalRadius: Float = 1f
    private var zoomFactor = 0.4f
    private var protractorRotationAngle = 0.0f
    private var currentPitchAngle = 0.0f
    private var smoothedPitchAngle = 0.0f
    private val PITCH_SMOOTHING_FACTOR = 0.15f
    private var isInitialized = false
    private var lastTouchX = 0f
    private var lastTouchY = 0f
    private enum class InteractionMode { NONE, PINCH_ZOOMING, PAN_TO_ROTATE }
    private var currentInteractionMode = InteractionMode.NONE
    private val PROTRACTOR_ANGLES = floatArrayOf(0f, 14f, 30f, 36f, 43f, 48f)
    private val mGraphicsCamera = Camera()
    private val mPitchMatrix = Matrix()
    private val mInversePitchMatrix = Matrix()
    private var isPinching = false
    private var defaultZoomFactor = 0.4f
    private var defaultProtractorRotationAngle = 0.0f
    private val PAN_ROTATE_SENSITIVITY = 0.3f
    private var areTextLabelsVisible = true
    private val baseGhostBallTextSize = 30f
    private val minGhostBallTextSize = 15f
    private val maxGhostBallTextSize = 60f
    private lateinit var scaleGestureDetector: ScaleGestureDetector

    private var wasLastWarningState = false // Track the previous warning state

    init {
        scaleGestureDetector = ScaleGestureDetector(context, ScaleListener())
        storeOriginalPaintProperties()
    }
    
    // ... (applyMaterialYouColors and storeOriginalPaintProperties are unchanged) ...
    fun applyMaterialYouColors(colorScheme: ColorScheme) {
        M3_COLOR_PRIMARY = colorScheme.primary.toArgb()
        M3_COLOR_SECONDARY = colorScheme.secondary.toArgb()
        M3_COLOR_TERTIARY = colorScheme.tertiary.toArgb()
        M3_COLOR_ON_SURFACE = colorScheme.onSurface.toArgb()
        M3_COLOR_OUTLINE = colorScheme.outline.toArgb()
        M3_COLOR_ERROR = colorScheme.error.toArgb()
        M3_COLOR_PRIMARY_CONTAINER = colorScheme.primaryContainer.toArgb()
        M3_COLOR_SECONDARY_CONTAINER = colorScheme.secondaryContainer.toArgb()

        val primaryComposeColor = colorScheme.primary
        m3GlowColor = Color.argb(100, Color.red(primaryComposeColor.toArgb()), Color.green(primaryComposeColor.toArgb()), Color.blue(primaryComposeColor.toArgb()))
        val surfaceBrightness = (Color.red(colorScheme.surface.toArgb()) * 299 + Color.green(colorScheme.surface.toArgb()) * 587 + Color.blue(colorScheme.surface.toArgb()) * 114) / 1000
        M3_TEXT_SHADOW_COLOR = if (surfaceBrightness < 128) Color.argb(180,220,220,220) else Color.argb(180, 30,30,30)

        targetCirclePaint.color = M3_COLOR_SECONDARY
        cueCirclePaint.color = M3_COLOR_PRIMARY
        centerMarkPaint.color = M3_COLOR_ON_SURFACE
        val tertiaryBase = colorScheme.tertiary.toArgb()
        protractorLinePaint.color = Color.argb(170, Color.red(tertiaryBase), Color.green(tertiaryBase), Color.blue(tertiaryBase))
        ghostCueOutlinePaint.color = M3_COLOR_OUTLINE

        aimingSightPaint.color = M3_COLOR_ON_SURFACE
        ghostBallTextPaint.color = Color.WHITE
        ghostBallTextPaint.setShadowLayer(2f, 1f, 1f, M3_TEXT_SHADOW_COLOR)

        cueDeflectionDottedPaint.color = M3_COLOR_OUTLINE
        cueDeflectionHighlightPaint.color = M3_COLOR_PRIMARY
        cueDeflectionHighlightPaint.setShadowLayer(GLOW_RADIUS_FIXED, 0f, 0f, m3GlowColor)

        invalidate()
    }
    private fun storeOriginalPaintProperties() {
        oYellowTargetLineStroke = yellowTargetLinePaint.strokeWidth
    }


    private inner class ScaleListener : ScaleGestureDetector.SimpleOnScaleGestureListener() {
        override fun onScaleBegin(detector: ScaleGestureDetector): Boolean {
            currentInteractionMode = InteractionMode.PINCH_ZOOMING
            isPinching = true; listener?.onUserInteraction(); return true
        }
        override fun onScale(detector: ScaleGestureDetector): Boolean {
            if (currentInteractionMode != InteractionMode.PINCH_ZOOMING) return false
            val oldZoom = zoomFactor
            val newZoomUncoerced = zoomFactor * detector.scaleFactor
            val newZoom = newZoomUncoerced.coerceIn(MIN_ZOOM_FACTOR, MAX_ZOOM_FACTOR)
            if (oldZoom == newZoom && newZoomUncoerced == newZoom) return true
            setZoomFactorInternal(newZoom)
            listener?.onZoomChanged(this@ProtractorOverlayView.zoomFactor)
            invalidate()
            return true
        }
        override fun onScaleEnd(detector: ScaleGestureDetector) {
            if (currentInteractionMode == InteractionMode.PINCH_ZOOMING) { currentInteractionMode = InteractionMode.NONE }
            isPinching = false
        }
    }

    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        super.onSizeChanged(w, h, oldw, oldh)
        targetCircleCenter.set(w / 2f, h / 2f)
        if (!isInitialized) {
            baseCircleDiameter = min(w, h) * 0.30f // Initial diameter reference
            setProtractorRotationAngleInternal(defaultProtractorRotationAngle)
            smoothedPitchAngle = currentPitchAngle
            isInitialized = true
        }
        currentLogicalRadius = (baseCircleDiameter / 2f) * zoomFactor
        updateCueBallPosition(); invalidate()
    }

    private fun updateCueBallPosition() {
        if (!isInitialized || currentLogicalRadius <= 0) return
        val angleRad = Math.toRadians(protractorRotationAngle.toDouble())
        val distance = 2 * currentLogicalRadius
        cueCircleCenter.x = targetCircleCenter.x - (distance * sin(angleRad)).toFloat()
        cueCircleCenter.y = targetCircleCenter.y + (distance * cos(angleRad)).toFloat()
    }

    private fun mapPoint(logicalPoint: PointF, matrixToUse: Matrix): PointF {
        val pointArray = floatArrayOf(logicalPoint.x, logicalPoint.y); matrixToUse.mapPoints(pointArray)
        return PointF(pointArray[0], pointArray[1])
    }


    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        if (!isInitialized) return
        // ... (onDraw setup is mostly unchanged) ...
        currentLogicalRadius = (baseCircleDiameter / 2f) * zoomFactor
        if (currentLogicalRadius <= 0.01f) currentLogicalRadius = 0.01f
        updateCueBallPosition()

        mGraphicsCamera.save(); mGraphicsCamera.rotateX(this.currentPitchAngle); mGraphicsCamera.getMatrix(mPitchMatrix); mGraphicsCamera.restore()
        mPitchMatrix.preTranslate(-targetCircleCenter.x, -targetCircleCenter.y); mPitchMatrix.postTranslate(targetCircleCenter.x, targetCircleCenter.y)
        val hasInverse = mPitchMatrix.invert(mInversePitchMatrix)

        val pTGC_s_collision = mapPoint(targetCircleCenter, mPitchMatrix); val pCGC_s_collision = mapPoint(cueCircleCenter, mPitchMatrix)
        val tL_s_coll = mapPoint(PointF(targetCircleCenter.x - currentLogicalRadius, targetCircleCenter.y), mPitchMatrix); val tR_s_coll = mapPoint(PointF(targetCircleCenter.x + currentLogicalRadius, targetCircleCenter.y), mPitchMatrix)
        val tT_s_coll = mapPoint(PointF(targetCircleCenter.x, targetCircleCenter.y - currentLogicalRadius), mPitchMatrix); val tB_s_coll = mapPoint(PointF(targetCircleCenter.x, targetCircleCenter.y + currentLogicalRadius), mPitchMatrix)
        val gTSR_s_collision = max(distance(tL_s_coll.x,tL_s_coll.y,tR_s_coll.x,tR_s_coll.y), distance(tT_s_coll.x,tT_s_coll.y,tB_s_coll.x,tB_s_coll.y)) / 2f
        val cL_s_coll = mapPoint(PointF(cueCircleCenter.x - currentLogicalRadius, cueCircleCenter.y), mPitchMatrix); val cR_s_coll = mapPoint(PointF(cueCircleCenter.x + currentLogicalRadius, cueCircleCenter.y), mPitchMatrix)
        val cT_s_coll = mapPoint(PointF(cueCircleCenter.x, cueCircleCenter.y - currentLogicalRadius), mPitchMatrix); val cB_s_coll = mapPoint(PointF(cueCircleCenter.x, cueCircleCenter.y + currentLogicalRadius), mPitchMatrix)
        val gCSR_s_collision = max(distance(cL_s_coll.x,cL_s_coll.y,cR_s_coll.x,cR_s_coll.y), distance(cT_s_coll.x,cT_s_coll.y,cB_s_coll.x,cB_s_coll.y)) / 2f

        val logicalDistanceBetweenCenters = distance(cueCircleCenter.x, cueCircleCenter.y, targetCircleCenter.x, targetCircleCenter.y)
        val logicalSumOfRadii = currentLogicalRadius + currentLogicalRadius
        val isPhysicalOverlap = logicalDistanceBetweenCenters < logicalSumOfRadii - 0.1f

        var isCueOnFarSide = false
        // ... (isCueOnFarSide logic is unchanged) ...
        if (hasInverse) {
            val screenAimPointScreenCoords = floatArrayOf(width / 2f, height.toFloat()); val screenAimPointLogicalCoordsArray = FloatArray(2)
            mInversePitchMatrix.mapPoints(screenAimPointLogicalCoordsArray, screenAimPointScreenCoords)
            val screenAimLogicalX = screenAimPointLogicalCoordsArray[0]; val screenAimLogicalY = screenAimPointLogicalCoordsArray[1]
            val cueLogX = cueCircleCenter.x; val cueLogY = cueCircleCenter.y; val targetLogX = targetCircleCenter.x; val targetLogY = targetCircleCenter.y
            val aimDirLogX = cueLogX - screenAimLogicalX; val aimDirLogY = cueLogY - screenAimLogicalY
            val magAimDirSq = aimDirLogX * aimDirLogX + aimDirLogY * aimDirLogY
            if (magAimDirSq > 0.0001f) {
                val magAimDir = sqrt(magAimDirSq); val normAimDirLogX = aimDirLogX / magAimDir; val normAimDirLogY = aimDirLogY / magAimDir
                val vecScreenToTargetLogX = targetLogX - screenAimLogicalX; val vecScreenToTargetLogY = targetLogY - screenAimLogicalY
                val distCueProj = magAimDir; val distTargetProj = vecScreenToTargetLogX * normAimDirLogX + vecScreenToTargetLogY * normAimDirLogY
                isCueOnFarSide = distCueProj > distTargetProj && distTargetProj > 0
            }
        }

        val isDeflectionDominantAngle = (protractorRotationAngle > 90.5f && protractorRotationAngle < 269.5f)
        val useErrorColorForMainCue = isCueOnFarSide || isDeflectionDominantAngle
        val showWarningStyleForGhostAndYellowTargetLine = isPhysicalOverlap || isCueOnFarSide

        // *** NEW: Notify listener about the current warning state ***
        val isCurrentlyInWarningState = useErrorColorForMainCue || showWarningStyleForGhostAndYellowTargetLine
        if (isCurrentlyInWarningState != wasLastWarningState) {
            listener?.onWarningStateChanged(isCurrentlyInWarningState)
            wasLastWarningState = isCurrentlyInWarningState
        }
        // *** END NEW ***

        // ... (rest of the drawing logic is unchanged) ...
        yellowTargetLinePaint.apply {
            strokeWidth = oYellowTargetLineStroke
            clearShadowLayer()
            color = Color.YELLOW
        }
        if (showWarningStyleForGhostAndYellowTargetLine) {
            yellowTargetLinePaint.apply {
                strokeWidth = oYellowTargetLineStroke + boldStrokeIncrease
                setShadowLayer(GLOW_RADIUS_FIXED, 0f, 0f, m3GlowColor)
            }
        }

        aimingAssistNearPaint.strokeWidth = oNearDefaultStroke
        aimingAssistFarPaint.strokeWidth = oFarDefaultStroke

        if (isCueOnFarSide) {
            aimingAssistNearPaint.apply {
                color = M3_COLOR_ERROR
                clearShadowLayer()
            }
            aimingAssistFarPaint.apply {
                color = protractorLinePaint.color
                strokeWidth = protractorLinePaint.strokeWidth
                clearShadowLayer()
            }
        } else {
            aimingAssistNearPaint.apply {
                color = M3_COLOR_PRIMARY_CONTAINER
                setShadowLayer(GLOW_RADIUS_FIXED, 0f, 0f, m3GlowColor)
            }
            if (!isPhysicalOverlap) {
                aimingAssistFarPaint.apply {
                    color = aimingAssistNearPaint.color
                    strokeWidth = aimingAssistNearPaint.strokeWidth
                    setShadowLayer(GLOW_RADIUS_FIXED, 0f, 0f, m3GlowColor)
                }
            } else {
                aimingAssistFarPaint.apply {
                    color = M3_COLOR_SECONDARY_CONTAINER
                    setShadowLayer(GLOW_RADIUS_FIXED, 0f, 0f, m3GlowColor)
                }
            }
        }


        canvas.save(); canvas.concat(mPitchMatrix)
        if (hasInverse) {
            val spu = floatArrayOf(width/2f, height.toFloat()); val lps = FloatArray(2); mInversePitchMatrix.mapPoints(lps, spu)
            val sxL=lps[0]; val syL=lps[1]; val cxL=cueCircleCenter.x; val cyL=cueCircleCenter.y
            val dxL=cxL-sxL; val dyL=cyL-syL; val magL=sqrt(dxL*dxL + dyL*dyL)
            if(magL > 0.001f){
                val ndxL=dxL/magL; val ndyL=dyL/magL; val efL=max(width,height)*5f
                val exL=cxL+ndxL*efL; val eyL=cyL+ndyL*efL
                canvas.drawLine(sxL,syL,cxL,cyL,aimingAssistNearPaint)
                canvas.drawLine(cxL,cyL,exL,eyL,aimingAssistFarPaint)
            }
        }
        canvas.drawCircle(targetCircleCenter.x,targetCircleCenter.y,currentLogicalRadius,targetCirclePaint)
        canvas.drawCircle(targetCircleCenter.x,targetCircleCenter.y,currentLogicalRadius/5f,centerMarkPaint)

        cueCirclePaint.color = if (useErrorColorForMainCue) M3_COLOR_ERROR else M3_COLOR_PRIMARY
        canvas.drawCircle(cueCircleCenter.x,cueCircleCenter.y,currentLogicalRadius,cueCirclePaint)
        canvas.drawCircle(cueCircleCenter.x,cueCircleCenter.y,currentLogicalRadius/5f,centerMarkPaint)

        val dxTBP = targetCircleCenter.x - cueCircleCenter.x; val dyTBP = targetCircleCenter.y - cueCircleCenter.y
        val tBPMag = sqrt(dxTBP * dxTBP + dyTBP * dyTBP)
        if (tBPMag > 0.001f) {
            val nDxT = dxTBP / tBPMag; val nDyT = dyTBP / tBPMag; val dLL = max(width, height) * 1.5f
            val deflectionDir1X = -nDyT; val deflectionDir1Y = nDxT

            var paintForDir1 = cueDeflectionDottedPaint
            var paintForDir2 = cueDeflectionDottedPaint

            if (useErrorColorForMainCue) {
                // Both lines are dotted if main cue is in error state
            } else {
                val alphaDeg = protractorRotationAngle
                val epsilon = 0.5f
                if (alphaDeg > epsilon && alphaDeg < (180f - epsilon)) {
                    paintForDir2 = cueDeflectionHighlightPaint
                } else if (alphaDeg > (180f + epsilon) && alphaDeg < (360f - epsilon)) {
                    paintForDir1 = cueDeflectionHighlightPaint
                }
            }
            canvas.drawLine(cueCircleCenter.x, cueCircleCenter.y, cueCircleCenter.x + deflectionDir1X * dLL, cueCircleCenter.y + deflectionDir1Y * dLL, paintForDir1)
            canvas.drawLine(cueCircleCenter.x, cueCircleCenter.y, cueCircleCenter.x - deflectionDir1X * dLL, cueCircleCenter.y - deflectionDir1Y * dLL, paintForDir2)
        }
        canvas.save(); canvas.translate(targetCircleCenter.x,targetCircleCenter.y); canvas.rotate(protractorRotationAngle)
        val lineLength = max(width,height)*2f
        PROTRACTOR_ANGLES.forEach { angle ->
            val rad = Math.toRadians(angle.toDouble()); val endX1=(lineLength*sin(rad)).toFloat(); val endY1=(lineLength*cos(rad)).toFloat()
            if(angle == 0f){ canvas.drawLine(0f,0f,endX1,endY1,protractorLinePaint); canvas.drawLine(0f,0f,-endX1,-endY1,yellowTargetLinePaint) }
            else { canvas.drawLine(0f,0f,endX1,endY1,protractorLinePaint); canvas.drawLine(0f,0f,-endX1,-endY1,protractorLinePaint)
                val negRad=Math.toRadians(-angle.toDouble()); val negEndX1=(lineLength*sin(negRad)).toFloat(); val negEndY1=(lineLength*cos(negRad)).toFloat()
                canvas.drawLine(0f,0f,negEndX1,negEndY1,protractorLinePaint); canvas.drawLine(0f,0f,-negEndX1,-negEndY1,protractorLinePaint)
            }
        }
        canvas.restore(); canvas.restore()

        val targetGhostDrawnCenterY = pTGC_s_collision.y - gTSR_s_collision
        canvas.drawCircle(pTGC_s_collision.x, targetGhostDrawnCenterY, gTSR_s_collision, targetGhostBallOutlinePaint)

        val cueGhostDrawnCenterY = pCGC_s_collision.y - gCSR_s_collision
        val originalGhostCueColor = ghostCueOutlinePaint.color
        if (showWarningStyleForGhostAndYellowTargetLine) {
            ghostCueOutlinePaint.color = M3_COLOR_ERROR
        } else {
            ghostCueOutlinePaint.color = M3_COLOR_OUTLINE
        }
        canvas.drawCircle(pCGC_s_collision.x, cueGhostDrawnCenterY, gCSR_s_collision, ghostCueOutlinePaint)
        ghostCueOutlinePaint.color = originalGhostCueColor

        val sightArmLength = gCSR_s_collision * 0.6f
        canvas.drawLine(pCGC_s_collision.x - sightArmLength, cueGhostDrawnCenterY, pCGC_s_collision.x + sightArmLength, cueGhostDrawnCenterY, aimingSightPaint)
        canvas.drawLine(pCGC_s_collision.x, cueGhostDrawnCenterY - sightArmLength, pCGC_s_collision.x, cueGhostDrawnCenterY + sightArmLength, aimingSightPaint)
        canvas.drawCircle(pCGC_s_collision.x, cueGhostDrawnCenterY, sightArmLength * 0.15f, aimingSightPaint)

        if (areTextLabelsVisible) {
            val currentTextSize = (baseGhostBallTextSize * zoomFactor).coerceIn(minGhostBallTextSize, maxGhostBallTextSize)
            ghostBallTextPaint.textSize = currentTextSize; val tm = ghostBallTextPaint.fontMetrics
            val textPaddingBelowText = 5f * zoomFactor.coerceAtLeast(0.5f)

            val visualTopOfTargetGhostBall = targetGhostDrawnCenterY - gTSR_s_collision
            val targetTextBaselineY = visualTopOfTargetGhostBall - textPaddingBelowText - tm.descent
            canvas.drawText("Target Ball", pTGC_s_collision.x, targetTextBaselineY, ghostBallTextPaint)

            val visualTopOfCueGhostBall = cueGhostDrawnCenterY - gCSR_s_collision
            val cueTextBaselineY = visualTopOfCueGhostBall - textPaddingBelowText - tm.descent
            canvas.drawText("Cue Ball", pCGC_s_collision.x, cueTextBaselineY, ghostBallTextPaint)
        }
    }
    
    // ... (rest of the file is unchanged, including onTouchEvent, setters/getters, resetToDefaults, and companion object) ...
    fun toggleHelpersVisibility() { areTextLabelsVisible = !areTextLabelsVisible; invalidate() }

    override fun onTouchEvent(event: MotionEvent): Boolean {
        if (!isInitialized) return false
        val scaleHandled = scaleGestureDetector.onTouchEvent(event)
        val touchX = event.x; val touchY = event.y

        if (isPinching || currentInteractionMode == InteractionMode.PINCH_ZOOMING) {
            if (scaleHandled || (event.actionMasked != MotionEvent.ACTION_UP && event.actionMasked != MotionEvent.ACTION_CANCEL)) {
                return true
            }
        }

        when (event.actionMasked) {
            MotionEvent.ACTION_DOWN -> {
                if (!isPinching) {
                    currentInteractionMode = InteractionMode.PAN_TO_ROTATE
                    listener?.onUserInteraction()
                }
                lastTouchX = touchX; lastTouchY = touchY
                return true
            }
            MotionEvent.ACTION_MOVE -> {
                if (currentInteractionMode == InteractionMode.PAN_TO_ROTATE) {
                    val dx = touchX - lastTouchX
                    val angleDelta = dx * PAN_ROTATE_SENSITIVITY
                    setProtractorRotationAngleInternal(protractorRotationAngle + angleDelta)
                    listener?.onRotationChanged(this.protractorRotationAngle)
                    invalidate()
                    lastTouchX = touchX; lastTouchY = touchY
                    return true
                } else if (currentInteractionMode == InteractionMode.PINCH_ZOOMING) {
                    return scaleHandled
                }
                return false
            }
            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                val wasInteracting = currentInteractionMode != InteractionMode.NONE
                if (currentInteractionMode == InteractionMode.PAN_TO_ROTATE) {
                    currentInteractionMode = InteractionMode.NONE
                }
                if (isPinching && !scaleGestureDetector.isInProgress && currentInteractionMode == InteractionMode.PINCH_ZOOMING) {
                    currentInteractionMode = InteractionMode.NONE
                }
                return wasInteracting || scaleHandled
            }
        }
        return scaleHandled || super.onTouchEvent(event)
    }

    private fun distance(x1: Float, y1: Float, x2: Float, y2: Float): Float { return sqrt((x1 - x2).pow(2) + (y1 - y2).pow(2)) }
    fun setZoomFactor(factor: Float) { if (isPinching) return; setZoomFactorInternal(factor); listener?.onUserInteraction(); invalidate() }
    private fun setZoomFactorInternal(factor: Float) { this.zoomFactor = factor.coerceIn(MIN_ZOOM_FACTOR, MAX_ZOOM_FACTOR); this.currentLogicalRadius = (baseCircleDiameter / 2f) * this.zoomFactor; updateCueBallPosition() }
    fun getZoomFactor(): Float = zoomFactor
    fun setProtractorRotationAngle(angle: Float) { setProtractorRotationAngleInternal(angle); listener?.onUserInteraction(); listener?.onRotationChanged(this.protractorRotationAngle); invalidate() }
    private fun setProtractorRotationAngleInternal(angle: Float) { var normAng = angle % 360f; if (normAng < 0) normAng += 360f; this.protractorRotationAngle = normAng; updateCueBallPosition() }
    fun getProtractorRotationAngle(): Float = protractorRotationAngle

    fun setPitchAngle(angle: Float) {
        val newPitch = angle.coerceIn(-85f, 90f)
        this.smoothedPitchAngle = (PITCH_SMOOTHING_FACTOR * newPitch) + ((1.0f - PITCH_SMOOTHING_FACTOR) * this.smoothedPitchAngle)

        if (abs(this.currentPitchAngle - this.smoothedPitchAngle) > 0.05f) {
            this.currentPitchAngle = this.smoothedPitchAngle
            invalidate()
        }
    }
    fun getPitchAngle(): Float = currentPitchAngle
    fun getTargetCircleCenter(): PointF = PointF(targetCircleCenter.x, targetCircleCenter.y)

    fun resetToDefaults() {
        if (!isInitialized) return
        setZoomFactorInternal(defaultZoomFactor)
        setProtractorRotationAngleInternal(defaultProtractorRotationAngle)
        areTextLabelsVisible = true
        yellowTargetLinePaint.apply {
            strokeWidth = oYellowTargetLineStroke
            color = Color.YELLOW
            clearShadowLayer()
        }
        listener?.onZoomChanged(this.zoomFactor)
        listener?.onRotationChanged(this.protractorRotationAngle)
        // Explicitly notify that the warning state is now false upon reset.
        if (wasLastWarningState) {
            listener?.onWarningStateChanged(false)
            wasLastWarningState = false
        }
        invalidate()
    }

    companion object {
        private const val TAG = "PoolProtractorApp"
        internal const val MIN_ZOOM_FACTOR = 0.1f
        internal const val MAX_ZOOM_FACTOR = 4.0f
    }
}



================================================================================
FILE: app\src\main\res\drawable\ic_dark_mode_24.xml
================================================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M20,15.31L23.31,12 20,8.69V4h-4.69L12,0.69 8.69,4H4v4.69L0.69,12 4,15.31V20h4.69L12,23.31 15.31,20H20v-4.69zM12,18V6c3.31,0 6,2.69 6,6s-2.69,6 -6,6z"/>
    
</vector>



================================================================================
FILE: app\src\main\res\drawable\ic_help_outline_24.xml
================================================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M11,18h2v-2h-2v2zM12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8zM12,6c-2.21,0 -4,1.79 -4,4h2c0,-1.1 0.9,-2 2,-2s2,0.9 2,2c0,2 -3,1.75 -3,5h2c0,-2.25 3,-2.5 3,-5 0,-2.21 -1.79,-4 -4,-4z"/>
    
</vector>



================================================================================
FILE: app\src\main\res\drawable\ic_launcher_background.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<vector
    android:height="108dp"
    android:width="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108"
    xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="#3DDC84"
          android:pathData="M0,0h108v108h-108z"/>
    <path android:fillColor="#00000000" android:pathData="M9,0L9,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,0L19,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,0L29,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,0L39,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,0L49,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,0L59,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,0L69,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,0L79,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M89,0L89,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M99,0L99,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,9L108,9"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,19L108,19"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,29L108,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,39L108,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,49L108,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,59L108,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,69L108,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,79L108,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,89L108,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,99L108,99"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,29L89,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,39L89,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,49L89,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,59L89,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,69L89,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,79L89,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,19L29,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,19L39,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,19L49,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,19L59,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,19L69,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,19L79,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
</vector>



================================================================================
FILE: app\src\main\res\drawable\ic_launcher_monochrome.xml
================================================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path
        android:fillColor="#00000000"
        android:pathData="M54,54m-45,0a45,45 0,1 1,90 0a45,45 0,1 1,-90 0"
        android:strokeWidth="4"
        android:strokeColor="#ffffff" />
    <path
        android:fillColor="#ffffff"
        android:pathData="M34,42m-5,0a5,5 0,1 1,10 0a5,5 0,1 1,-10 0" />
    <path
        android:fillColor="#ffffff"
        android:pathData="M74,66m-5,0a5,5 0,1 1,10 0a5,5 0,1 1,-10 0" />
    <path
        android:fillColor="#00000000"
        android:pathData="M31,64a27,27 0,0 0,46 -20"
        android:strokeWidth="4"
        android:strokeColor="#ffffff"
        android:strokeLineCap="round" />
</vector>



================================================================================
FILE: app\src\main\res\drawable\ic_light_mode_24.xml
================================================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M20,15.31L23.31,12 20,8.69V4h-4.69L12,0.69 8.69,4H4v4.69L0.69,12 4,15.31V20h4.69L12,23.31 15.31,20H20v-4.69zM12,18V6c3.31,0 6,2.69 6,6s-2.69,6 -6,6z"/>
    
</vector>



================================================================================
FILE: app\src\main\res\drawable\ic_undo_24.xml
================================================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12.5,8c-2.65,0 -5.05,0.99 -6.9,2.6L2,7v9h9l-3.62,-3.62c1.39,-1.16 3.16,-1.88 5.12,-1.88 3.54,0 6.55,2.31 7.6,5.5l2.37,-0.78C21.08,11.96 17.15,8 12.5,8z"/>
</vector>


================================================================================
FILE: app\src\main\res\drawable\ic_zoom_in_24.xml
================================================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M15.5,14h-0.79l-0.28,-0.27C15.41,12.59 16,11.11 16,9.5 16,5.91 13.09,3 9.5,3S3,5.91 3,9.5 5.91,16 9.5,16c1.61,0 3.09,-0.59 4.23,-1.57l0.27,0.28v0.79l5,4.99L20.49,19l-4.99,-5zM9.5,14C7.01,14 5,11.99 5,9.5S7.01,5 9.5,5 14,7.01 14,9.5 11.99,14 9.5,14zM10,7H9v2H7v1h2v2h1v-2h2V9h-2z"/>
</vector>


================================================================================
FILE: app\src\main\res\drawable\seekbar_custom_track.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- Background track -->
    <item android:id="@android:id/background">
        <shape android:shape="rectangle">
            <corners android:radius="4dp" /> <!-- Adjust for desired roundness -->
            <solid android:color="?attr/colorSurfaceVariant" />
            <size android:height="8dp" /> <!-- This is the THICKNESS of the track drawable -->
        </shape>
    </item>

    <!-- Progress track -->
    <item android:id="@android:id/progress">
        <scale android:scaleWidth="100%">
            <shape android:shape="rectangle">
                <corners android:radius="4dp" />
                <solid android:color="?attr/colorPrimary" />
                <size android:height="8dp" /> <!-- Must match background thickness -->
            </shape>
        </scale>
    </item>

    <!-- Secondary progress (optional, remove if not needed) -->
    <item android:id="@android:id/secondaryProgress">
        <scale android:scaleWidth="100%">
            <shape android:shape="rectangle">
                <corners android:radius="4dp"/>
                <solid android:color="@android:color/transparent"/> <!-- Or a muted color -->
                <size android:height="8dp"/>
            </shape>
        </scale>
    </item>
</layer-list>


================================================================================
FILE: app\src\main\res\layout\activity_main.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/activity_main_root"
    android:layout_width="match_parent"
    android:layout_height="match_parent"

    >

    <androidx.camera.view.PreviewView
        android:id="@+id/cameraPreviewView"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

    <com.hereliesaz.poolprotractor.ProtractorOverlayView
        android:id="@+id/protractorOverlayView"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/controls_relative_layout"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <androidx.constraintlayout.widget.ConstraintLayout
            android:id="@+id/zoomControlsLayout"
            android:layout_width="55dp"
            android:layout_height="486dp"
            android:layout_marginEnd="8dp"
            android:gravity="center_vertical"
            android:layoutMode="opticalBounds"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintHorizontal_bias="0.974"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintVertical_bias="0.497">

            <ImageView
                android:id="@+id/zoomIcon"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="46dp"
                android:contentDescription="@string/zoom_icon"
                android:padding="8dp"
                android:src="@drawable/ic_zoom_in_24"
                android:visibility="visible"
                app:layout_constraintBottom_toTopOf="@+id/zoomSlider"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintHorizontal_bias="0.5"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toTopOf="parent"
                app:tint="?attr/colorControlNormal"
                tools:ignore="TouchTargetSizeCheck"
                tools:visibility="visible" />

            <SeekBar
                android:id="@+id/zoomSlider"
                android:layout_width="24dp"
                android:layout_height="400dp"
                android:max="100"
                android:progress="50"
                android:progressDrawable="@drawable/seekbar_custom_track"
                android:thumbTint="?attr/colorPrimary"
                android:rotation="90"
                android:visibility="visible"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintHorizontal_bias="0.5"
                app:layout_constraintStart_toStartOf="parent" />

        </androidx.constraintlayout.widget.ConstraintLayout>

        <com.google.android.material.floatingactionbutton.FloatingActionButton
            android:id="@+id/resetButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginEnd="24dp"
            android:layout_marginBottom="24dp"
            android:contentDescription="@string/reset_view"
            android:src="@drawable/ic_undo_24"
            app:backgroundTint="?attr/colorPrimaryContainer"
            app:fabSize="mini"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:tint="?attr/colorOnPrimaryContainer" />

        <com.google.android.material.floatingactionbutton.FloatingActionButton
            android:id="@+id/helpButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="24dp"
            android:layout_marginBottom="24dp"
            android:contentDescription="@string/toggle_help_lines"
            android:src="@drawable/ic_help_outline_24"
            app:backgroundTint="?attr/colorSecondaryContainer"
            app:fabSize="mini"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:tint="?attr/colorOnSecondaryContainer" />

    </androidx.constraintlayout.widget.ConstraintLayout>

    <androidx.compose.ui.platform.ComposeView
        android:id="@+id/composeThemeView"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:visibility="gone" />

</FrameLayout>


================================================================================
FILE: app\src\main\res\mipmap-anydpi-v26\ic_launcher.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@mipmap/ic_launcher_background" />
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>


================================================================================
FILE: app\src\main\res\mipmap-anydpi-v26\ic_launcher_round.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@mipmap/ic_launcher_background" />
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>


================================================================================
FILE: app\src\main\res\values\colors.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
</resources>


================================================================================
FILE: app\src\main\res\values\strings.xml
================================================================================
<resources>
    <string name="app_name">CueDetat</string>
    <string name="zoom_icon">Zoom Icon</string>
    <string name="reset_view">Reset View</string>
    <string name="toggle_help_lines">Toggle Help Lines</string>

    <!-- Update Checker -->
    <string name="update_check_failed">Update check failed. The void is silent.</string>
    <string name="update_no_new_release">You are aligned with the current reality. No new release found.</string>
    <string name="update_available">A new version (%s) beckons from the abyss.</string>


    <!-- Insulting Warnings -->
    <string name="warning_message_area">Sarcastic Warning Message Area</string>
    <string name="tagline">May your shot be better than your excuses.</string>

    <string-array name="insulting_warnings">
        <item>Physics called. It wants your law degree back.</item>
        <item>A fine example of geometric optimism.</item>
        <item>Aiming is not a suggestion.</item>
        <item>Even the chalk finds your methods dusty.</item>
        <item>Let\'s list other things you could be doing instead. There\'s knitting, and </item>
        <item>Talent not detected.</item>
        <item>Can\'t even scratch common sense.</item>
        <item>There are no shots over there. I checked.</item>
        <item>Do you need a bigger phone or a smaller table?</item>
        <item>Your Mrs. called, she wants her title back.</item>
        <item>\'A do not, this is,\' says Yoda.</item>
        <item>Nope.</item>
        <item>Not happening.</item>
        <item>Won\'t work.</item>
        <item>Try harder.</item>
        <item>PLEASE try harder.</item>
        <item>Try gooder?</item>
        <item>Try better. That\'s the one I was looking for. No, not your shot. The word I was looking for.</item>
        <item>No.</item>
        <item>Physics says no.</item>
        <item>God says no.</item>
        <item>Your mom says she\'s proud no matter what.</item>
        <item>Your father says nothing.</item>
        <item>Hey batter, batter</item>
        <item>In the beginning, God created a better shot.</item>
        <item>Am I crying from laughing, or is this just sad?</item>
        <item>Am I pretty, yet?</item>
        <item>Do you even know how to pool, bro?</item>
        <item>That\'s an angle. Not a good one.</item>
        <item>I can\'t more disappointed than your dad.</item>
        <item>Consult a physicist. Or a therapist.</item>
        <item>Maybe if you put your phone down once in a while....</item>
    </string-array>
</resources>



================================================================================
FILE: app\src\main\res\values\themes.xml
================================================================================
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <!-- For Material 3 components like FloatingActionButton, prefer a Material3 theme -->
    <style name="Theme.CueDetat" parent="Theme.Material3.DayNight.NoActionBar">
        <!-- Primary brand color. -->
        <item name="colorPrimary">@color/purple_500</item>
        <!-- <item name="colorPrimaryVariant">@color/purple_700</item> --> <!-- M3 uses colorPrimaryContainer, etc. -->
        <item name="colorOnPrimary">@color/white</item>
        <!-- Secondary brand color. -->
        <item name="colorSecondary">@color/teal_200</item>
        <!-- <item name="colorSecondaryVariant">@color/teal_700</item> --> <!-- M3 uses colorSecondaryContainer, etc. -->
        <item name="colorOnSecondary">@color/black</item>
        <!-- Status bar color. -->
        <item name="android:statusBarColor">?attr/colorPrimary</item> <!-- Or a specific color -->
        <!-- Customize your theme here. -->
    </style>
</resources>


================================================================================
FILE: app\src\main\res\xml\backup_rules.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older than API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
<!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>


================================================================================
FILE: app\src\main\res\xml\data_extraction_rules.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>


================================================================================
FILE: app\src\main\AndroidManifest.xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.INTERNET" />

    <uses-feature android:name="android.hardware.camera.any" />
    <uses-feature android:name="android.hardware.sensor.gyroscope" android:required="false" />
    <uses-feature android:name="android.hardware.sensor.accelerometer" android:required="false" />

    <application
        android:name=".MyApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.CueDetat"
        tools:targetApi="31">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:screenOrientation="portrait"
            android:theme="@style/Theme.CueDetat"
            tools:ignore="LockedOrientationActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>



================================================================================
FILE: README.md
================================================================================
# Cue Dtat - An IRL Billiards Aiming Assistant for Android

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
![GitHub Release](https://img.shields.io/github/v/release/hereliesaz/CueDetat?include_prereleases&display_name=release)


**_May your aim be truer than your excuses._**


**Cue Dtat** is an Android app to ostensibly help billiards players line up and aim, determine shot angles, make cut shots, understand the cue ball tangent, improve their geometric understanding of the game. Maybe get called a cheater, even though using this app is entirely legal. At the very least, get yourself a high-tech understanding of how bad you are at pool.

It uses your phone's camera and orientation sensors to overlay a dynamic protractor and aiming guide onto the real-world view of a pool table.

**(Warning: May induce an inflated sense of skill, followed by the crushing reality of physics. Use with a healthy dose of self-deprecating humor.)**



## Features

*   **Live Camera Augmented Reality Overlay:**
    *   See the guides directly on your pool game.
    *   Designed for easy one or two-handed use. 
*   **Dynamic Protractor:**
    *   See where the balls will go before you hit them.  
    *   Rotates and zooms with on-screen gestures, tilts using the gyroscope. 
*   **Cue Ball & Target Ball Representation:**
    *   Simulated "ghost balls" on a projected plane.
    *   Visual feedback for aiming path and potential collisions.
*   **Pitch-Adjusted Perspective:** The protractor plane tilts based on your phone's orientation for a three-dimensional augmented reality.
*   **Where will the Cue ball go?** Visualizes the tangent line and the resulting cue ball path if English (sidespin) were applied.
*   **Guided Shots** Guide lines extend from the target ball to line up with your table's pockets.
*   **VERY Helpful Help:**
    *   Labels for key lines and what to do with them.
    *   Instructions better than Ikea's.
    *   Toggleable Help visibility for a cleaner view.
    *   Uplifting messages of slightly disdainful encouragement.



## Screenshots Placeholder

*   Pretend this is a screenshot.
*   This, too.
*   Imagine looking at a photo of the app in use.
*   Note the craft.
*   The flippant attitude towards detail.
*   I'm a genieaouxess.
*   And this is a photo from a vacation two years ago that I accidentally pretend included.



## How It Works: The Gore. The Details.

1.  **Camera Preview:** Uses CameraX to display a live feed from the device camera.
2.  **Sensor Input:** Leverages the `TYPE_ROTATION_VECTOR` sensor to determine the phone's pitch, roll, and yaw. The pitch is primarily used to tilt the 2D protractor plane. An offset is applied to account for natural phone holding angles.
3.  **Custom View (`ProtractorOverlayView`):** All guides and visual elements are drawn on a custom `View` that overlays the camera preview.
4.  **Drawing Logic:**
    *   **Protractor Plane:** A logical 2D plane is defined. Circles representing the cue and target ball positions, protractor angle lines, and deflection lines are drawn on this plane.
    *   **3D Projection (Simplified):** An `android.graphics.Camera` object is used to apply an X-axis rotation (based on phone pitch) to this logical plane, creating a 3D perspective effect. This transformed matrix is then applied to the canvas.
    *   **Ghost Balls:** Screen-space circles are drawn to represent the "3D" position of the cue and target balls. Their Y-offset from the projected plane centers is scaled by the sine of the pitch angle (raised to a power for a more pronounced effect) to simulate them floating above the plane.
    *   **Helper Text:** Text labels are drawn either on the (lifted) protractor plane or directly in screen space, with basic collision avoidance and dynamic sizing.
5.  **Gesture Handling:**
    *   `ScaleGestureDetector` for pinch-to-zoom.
    *   `MotionEvent` tracking for single-finger pan-to-rotate.
6.  **Theming:** Uses Jetpack Compose for Material 3 theming, with color values then passed to the custom view's `Paint` objects.



## Known Quirks & Future Delusions

*   **Text Collision Avoidance:** Current implementation is basic (first-drawn wins space).
*   **A Virtual Table for Virtually Useful Bank Shot Projection:** Using more sophisticated dynamic layout involving a line drawing of a billiards table will come someday.
*   **True 3D Rendering:** This app fakes 3D with 2D canvas tricks. Moving to OpenGL ES or a 3D engine like Filament would allow for actual 3D models and lighting, but would also drastically increase complexity. And probably anxiety. But probably not usefulness.
*   **Ball, Table and Pocket Detection:** The ultimate fantasy. Using CV to detect the table, balls, and pockets automatically. For now, you are the CV.
*   **Insulting Warnings:** The pool of sarcastic remarks is finite. Contributions welcome if they tickle me the required level of pink.
*   **Performance:** Drawing many complex paths and text elements on every frame can be demanding. Optimizations are an ongoing battle. And yet, somehow, it feels more like a you-problem.



## License

Distributed under the MIT License. Basically, completely free to use however you'd like, just gimme a shoutout. I make money making art. So, like this:
Cue Dtat by HereLiesAz (https://instagram.com/hereliesaz)


## Acknowledgments (of Who to Blame)

*   The ghosts of billiards past whose missed shots inspired this.
*   The people I've tried to teach all these things.
*   Physics. And geometry. Where my hoes at?!

---




================================================================================
FILE: build.gradle.kts
================================================================================
// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    id("com.android.application") version "8.12.0-alpha04" apply false
    id("org.jetbrains.kotlin.android") version "2.1.21" apply false
    id("com.google.dagger.hilt.android") version "2.56.2" apply false
    id("org.jetbrains.kotlin.plugin.compose") version "2.1.21" apply false


}


================================================================================
FILE: app/build.gradle.kts
================================================================================

plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("kotlin-kapt")
    id("com.google.dagger.hilt.android")
    alias(libs.plugins.kotlin.compose)
}

android {
    namespace = "com.hereliesaz.cuedetat"
    compileSdk = 36

    defaultConfig {
        applicationId = "com.hereliesaz.cuedetat"
        minSdk = 26
        targetSdk = 36
        versionCode = 1
        // Versioning Scheme: YYYY.MM.DD-release
        versionName = "2025.06.07-release"
        multiDexEnabled = true // <--- ADD THIS LINE

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
        freeCompilerArgs += listOf(
            "-Xopt-in=kotlin.RequiresOptIn",
            "-Xopt-in=androidx.compose.material3.ExperimentalMaterial3Api" // Add this line
        )
    }
    buildFeatures {
        compose = true
    }
    buildFeatures {
        buildConfig = true
    }


    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
    buildToolsVersion = "36.0.0"
}

dependencies {
    // Core & UI
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.activity.compose)
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.compose.material3)
    // CameraX
    implementation(libs.androidx.camera.core)
    implementation(libs.androidx.camera.camera2)
    implementation(libs.androidx.camera.lifecycle)
    implementation(libs.androidx.camera.view)
    implementation(libs.kotlinx.coroutines.guava)

    // Hilt for Dependency Injection
    implementation(libs.hilt.android)
    implementation(libs.androidx.benchmark.common)
    kapt(libs.hilt.compiler)

    // Retrofit for Networking
    implementation(libs.retrofit)
    implementation(libs.converter.gson)

    // Testing
    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
    androidTestImplementation(platform(libs.androidx.compose.bom))
    androidTestImplementation(libs.androidx.ui.test.junit4)
    debugImplementation(libs.androidx.ui.tooling)
    debugImplementation(libs.androidx.ui.test.manifest)

    // For Glance support
    implementation(libs.androidx.glance)
    // For AppWidgets support with Glance
    implementation(libs.androidx.glance.appwidget)
    implementation(libs.bundles.camera)
    implementation(libs.androidx.camera.core)
    implementation(libs.androidx.camera.camera2)
    implementation(libs.androidx.camera.lifecycle)
    implementation(libs.androidx.camera.view)
    implementation(libs.kotlinx.coroutines.guava) // Also part of your bundle
    implementation(libs.material)
    implementation(libs.androidx.multidex) // <-- Add this line
    implementation(libs.androidx.material.icons.extended) // Or the latest version

    implementation(libs.hilt.android)
    kapt(libs.dagger.hilt.compiler)
    implementation(libs.androidx.palette)


}
kapt {
    correctErrorTypes = true
}



================================================================================
FILE: settings.gradle.kts
================================================================================
pluginManagement {
  repositories {
    google {
      content {
        includeGroupByRegex("com\\.android.*")
        includeGroupByRegex("com\\.google.*")
        includeGroupByRegex("androidx.*")
      }
    }
    mavenCentral()
    gradlePluginPortal()
    maven(url = "https://jitpack.io")

  }
  plugins {
    id("com.android.application") version "8.12.0"
    id("com.android.library") version "8.12.0-alpha04"

    id("org.jetbrains.kotlin.android") version "2.1.21"
  }
}
dependencyResolutionManagement {
  repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
  repositories {
    google()
    mavenCentral()
  }
}

rootProject.name = "CueDetat"
include(":app")


